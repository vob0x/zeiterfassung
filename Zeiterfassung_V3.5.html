<!DOCTYPE html>
<html lang="de" data-theme="cyber">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
<meta name="theme-color" content="#0A0B0F">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<title>Zeiterfassung</title>
<link rel="manifest" href="manifest.json">
<link rel="apple-touch-icon" href="icons/icon-192.png">
<link rel="icon" type="image/png" sizes="192x192" href="icons/icon-192.png">
<link rel="icon" type="image/png" sizes="512x512" href="icons/icon-512.png">
<link rel="preconnect" href="https://fonts.googleapis.com">
<link href="https://fonts.googleapis.com/css2?family=Outfit:wght@300;400;500;600;700;800&family=Space+Mono:wght@400;700&family=DM+Sans:wght@300;400;500;600;700&family=Sora:wght@300;400;500;600;700;800&display=swap" rel="stylesheet">
<style>
/* ============================================================
   CSS CUSTOM PROPERTIES – CYBER THEME (Default)
   ============================================================ */
:root {
    --bg: #0A0B0F;
    --bg-gradient: linear-gradient(160deg, #0A0B0F 0%, #111318 40%, #0D0E13 100%);
    --surface: rgba(18, 20, 28, 0.78);
    --surface-solid: #131520;
    --surface-hover: rgba(201, 169, 98, 0.04);
    --surface-active: rgba(201, 169, 98, 0.08);
    --surface-elevated: rgba(20, 22, 32, 0.94);
    --border: rgba(201, 169, 98, 0.08);
    --border-hover: rgba(201, 169, 98, 0.20);
    --text: #E8E4DF;
    --text-secondary: #908B83;
    --text-muted: #4D4941;
    --neon-cyan: #C9A962;
    --neon-magenta: #C48B9F;
    --neon-violet: #9B8EC4;
    --neon-green: #6EC49E;
    --neon-yellow: #E5A84B;
    --neon-red: #D4706E;
    --neon-orange: #D4956A;
    --glow-cyan: 0 0 24px rgba(201, 169, 98, 0.10), 0 0 60px rgba(201, 169, 98, 0.03);
    --glow-magenta: 0 0 20px rgba(196, 139, 159, 0.10);
    --glow-soft: 0 0 40px rgba(201, 169, 98, 0.05);
    --font-display: 'Sora', sans-serif;
    --font: 'DM Sans', sans-serif;
    --font-mono: 'Space Mono', monospace;
    --radius: 14px;
    --radius-sm: 8px;
    --radius-lg: 20px;
    --radius-xl: 28px;
    --shadow: 0 4px 30px rgba(0, 0, 0, 0.40);
    --shadow-lg: 0 12px 50px rgba(0, 0, 0, 0.50);
    --shadow-glow: 0 4px 30px rgba(201, 169, 98, 0.06);
    --timer-size: 220px;
    --timer-stroke: #C9A962;
    --timer-glow: drop-shadow(0 0 14px rgba(201, 169, 98, 0.30));
    --danger: #D4706E;
    --success: #6EC49E;
    --warning: #E5A84B;
    --transition-fast: 0.15s cubic-bezier(0.4, 0, 0.2, 1);
    --transition: 0.25s cubic-bezier(0.4, 0, 0.2, 1);
    --transition-slow: 0.4s cubic-bezier(0.4, 0, 0.2, 1);
}

/* ============================================================
   LIGHT THEME
   ============================================================ */
[data-theme="light"] {
    --bg: #F6F5F2;
    --bg-gradient: linear-gradient(160deg, #F6F5F2 0%, #EFEEE9 40%, #F4F3F0 100%);
    --surface: rgba(255, 255, 255, 0.85);
    --surface-solid: #FFFFFF;
    --surface-hover: rgba(37, 99, 235, 0.03);
    --surface-active: rgba(37, 99, 235, 0.06);
    --surface-elevated: rgba(255, 255, 255, 0.97);
    --border: #E8E5E0;
    --border-hover: #C7D2E4;
    --text: #1A1814;
    --text-secondary: #5F5D58;
    --text-muted: #A3A09A;
    --neon-cyan: #2563EB;
    --neon-magenta: #DB2777;
    --neon-violet: #7C3AED;
    --neon-green: #059669;
    --neon-yellow: #D97706;
    --neon-red: #DC2626;
    --neon-orange: #EA580C;
    --glow-cyan: 0 2px 12px rgba(37, 99, 235, 0.1);
    --glow-magenta: 0 2px 12px rgba(219, 39, 119, 0.1);
    --glow-soft: 0 2px 20px rgba(37, 99, 235, 0.06);
    --font-display: 'Outfit', sans-serif;
    --font: 'DM Sans', sans-serif;
    --font-mono: 'Space Mono', monospace;
    --shadow: 0 1px 3px rgba(0,0,0,0.04), 0 4px 16px rgba(0,0,0,0.03);
    --shadow-lg: 0 4px 20px rgba(0,0,0,0.06), 0 12px 40px rgba(0,0,0,0.04);
    --shadow-glow: 0 4px 20px rgba(37, 99, 235, 0.06);
    --timer-stroke: #2563EB;
    --timer-glow: drop-shadow(0 2px 12px rgba(37,99,235,0.18));
    --danger: #DC2626;
    --success: #059669;
    --warning: #D97706;
}

/* ============================================================
   RESET & BASE
   ============================================================ */
*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
html { scroll-behavior: smooth; overflow-x: hidden; }
body {
    font-family: var(--font);
    background: var(--bg);
    color: var(--text);
    min-height: 100vh;
    line-height: 1.55;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
    letter-spacing: 0.01em;
    transition: background 0.5s ease, color 0.3s ease;
    overflow-x: hidden;
}

/* Animated gradient mesh background */
body::before {
    content: '';
    position: fixed; inset: 0;
    background:
        radial-gradient(ellipse 80% 60% at 20% 30%, rgba(201,169,98,0.05) 0%, transparent 60%),
        radial-gradient(ellipse 60% 80% at 80% 70%, rgba(167,139,250,0.05) 0%, transparent 55%),
        radial-gradient(ellipse 70% 50% at 50% 90%, rgba(244,114,182,0.04) 0%, transparent 50%),
        var(--bg-gradient);
    background-size: 200% 200%, 200% 200%, 200% 200%, 100% 100%;
    animation: meshDrift 25s ease-in-out infinite alternate;
    pointer-events: none; z-index: 0;
}
@keyframes meshDrift {
    0%   { background-position: 0% 0%, 100% 100%, 50% 100%, 0% 0%; }
    33%  { background-position: 30% 20%, 70% 80%, 20% 60%, 0% 0%; }
    66%  { background-position: 60% 40%, 40% 60%, 80% 40%, 0% 0%; }
    100% { background-position: 100% 60%, 0% 40%, 50% 20%, 0% 0%; }
}
[data-theme="light"] body::before {
    background:
        radial-gradient(ellipse 80% 60% at 20% 30%, rgba(37,99,235,0.04) 0%, transparent 60%),
        radial-gradient(ellipse 60% 80% at 80% 70%, rgba(124,58,237,0.03) 0%, transparent 55%),
        radial-gradient(ellipse 70% 50% at 50% 90%, rgba(219,39,119,0.02) 0%, transparent 50%),
        var(--bg-gradient);
    background-size: 200% 200%, 200% 200%, 200% 200%, 100% 100%;
}

/* Subtle noise texture overlay */
body::after {
    content: '';
    position: fixed; inset: 0;
    background: url("data:image/svg+xml,%3Csvg viewBox='0 0 256 256' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)' opacity='0.015'/%3E%3C/svg%3E");
    pointer-events: none; z-index: 9999;
    opacity: 0.4;
}
[data-theme="light"] body::after { opacity: 0.2; }

/* ============================================================
   TOP BAR
   ============================================================ */
.top-bar {
    display: flex; align-items: center; justify-content: space-between;
    padding: 14px 24px;
    background: rgba(10, 11, 15, 0.72);
    border-bottom: 1px solid var(--border);
    backdrop-filter: blur(28px) saturate(1.2); -webkit-backdrop-filter: blur(28px) saturate(1.2);
    position: fixed; top: 0; left: 0; right: 0; z-index: 100;
    transition: all var(--transition);
    gap: 8px;
}
[data-theme="light"] .top-bar { backdrop-filter: blur(24px); -webkit-backdrop-filter: blur(24px); background: rgba(255,255,255,0.82); border-bottom-color: rgba(0,0,0,0.06); }

.app-logo {
    display: flex; align-items: center; gap: 10px;
    font-family: var(--font-display); font-weight: 700; font-size: 16px;
    letter-spacing: -0.02em; color: var(--neon-cyan);
    min-width: 0; overflow: hidden; flex-shrink: 1;
}
.app-logo .logo-icon { opacity: 0.9; }

.top-bar-actions { display: flex; align-items: center; gap: 8px; position: relative; flex-shrink: 0; }

/* Hamburger Menu (mobile) */
.ham-btn { display: none; background: none; border: 1px solid var(--border); border-radius: var(--radius-sm); padding: 8px; cursor: pointer; color: var(--text-secondary); transition: all var(--transition-fast); min-width: 40px; min-height: 40px; align-items: center; justify-content: center; }
.ham-btn svg { width: 18px; height: 18px; stroke: currentColor; fill: none; stroke-width: 1.6; stroke-linecap: round; pointer-events: none; }
.ham-btn:hover { color: var(--text); border-color: var(--border-hover); }
#headerSyncBtn.sync-active { color: var(--neon-green); border-color: rgba(110,196,158,0.25); }
#headerSyncBtn.sync-active .btn-icon svg { stroke: var(--neon-green); }
.ham-menu { display: none; position: absolute; top: calc(100% + 8px); right: 0; min-width: 220px; background: var(--surface-elevated); border: 1px solid var(--border); border-radius: var(--radius); padding: 6px; box-shadow: var(--shadow-lg); z-index: 300; backdrop-filter: blur(28px) saturate(1.2); -webkit-backdrop-filter: blur(28px) saturate(1.2); }
.ham-menu.open { display: flex; flex-direction: column; gap: 2px; animation: modalIn 0.2s ease; }
.ham-menu .btn { width: 100%; justify-content: flex-start; gap: 10px; padding: 12px 14px; border-radius: var(--radius-sm); font-size: 13px; border: none; background: transparent; }
.ham-menu .btn:hover { background: var(--surface-hover); }
.ham-menu .btn .btn-label, .ham-menu .btn .ham-label { display: inline !important; }
[data-theme="light"] .ham-menu { background: rgba(255,255,255,0.96); }

@media (max-width: 640px) {
    .ham-btn { display: flex; }
    .top-bar-actions .btn.ham-hide { display: none; }
    .top-bar-actions .btn-label { display: none; }
    .top-bar-actions .btn { min-width: 40px; min-height: 40px; padding: 8px; justify-content: center; }
    .top-bar-actions .lang-toggle { min-height: 40px; padding: 6px 10px; }
    .top-bar-actions { gap: 4px; }
}
@media (max-width: 768px) {
    .top-bar-actions .btn-label { display: none; }
    .top-bar { padding: 12px 16px; }
    .app-logo { font-size: 14px; gap: 8px; }
}

/* ============================================================
   BUTTONS
   ============================================================ */
.btn {
    display: inline-flex; align-items: center; gap: 6px;
    padding: 9px 18px;
    border: 1px solid var(--border);
    border-radius: var(--radius-sm);
    background: var(--surface);
    color: var(--text-secondary);
    font-family: var(--font-display); font-size: 11px; font-weight: 600;
    letter-spacing: 0.02em;
    cursor: pointer; transition: all var(--transition);
    white-space: nowrap;
    position: relative; overflow: hidden;
}
/* Ripple effect on click */
.btn .ripple {
    position: absolute; border-radius: 50%;
    background: currentColor; opacity: 0.12;
    transform: scale(0); animation: rippleAnim 0.5s ease-out forwards;
    pointer-events: none;
}
@keyframes rippleAnim { to { transform: scale(4); opacity: 0; } }
.btn:hover { border-color: var(--border-hover); color: var(--text); transform: translateY(-1px); box-shadow: var(--glow-soft); }
.btn:active { transform: translateY(0) scale(0.98); }
.btn-primary { background: rgba(201,169,98,0.07); border-color: rgba(201,169,98,0.18); color: var(--neon-cyan); }
.btn-primary:hover { background: rgba(201,169,98,0.12); border-color: rgba(201,169,98,0.30); box-shadow: var(--glow-cyan); }
.btn-danger { color: var(--neon-red); border-color: rgba(212,112,110,0.18); }
.btn-danger:hover { background: rgba(248,113,113,0.06); border-color: rgba(248,113,113,0.35); }
.btn-success { color: var(--neon-green); border-color: rgba(52,211,153,0.2); }
.btn-success:hover { background: rgba(52,211,153,0.06); border-color: rgba(52,211,153,0.35); }
.btn .btn-icon { display: inline-flex; align-items: center; justify-content: center; width: 16px; height: 16px; pointer-events: none; }
.btn .btn-icon svg { width: 100%; height: 100%; stroke: currentColor; fill: none; stroke-width: 1.6; stroke-linecap: round; stroke-linejoin: round; pointer-events: none; }
.app-logo .logo-icon { width: 20px; height: 20px; display: inline-flex; align-items: center; }
.app-logo .logo-icon svg { width: 100%; height: 100%; stroke: var(--neon-cyan); fill: none; stroke-width: 1.8; stroke-linecap: round; stroke-linejoin: round; }
.nav-icon svg, .bnav-icon svg { pointer-events: none; }
.btn:disabled { opacity: 0.35; cursor: not-allowed; transform: none; }

[data-theme="light"] .btn { background: var(--surface-solid); }
[data-theme="light"] .btn-primary { background: #EFF6FF; border-color: #BFDBFE; color: #2563EB; }
[data-theme="light"] .btn-primary:hover { background: #DBEAFE; border-color: #93C5FD; box-shadow: var(--glow-cyan); }
[data-theme="light"] .btn-danger { color: #DC2626; border-color: #FECACA; }
[data-theme="light"] .btn-danger:hover { background: #FEF2F2; }
[data-theme="light"] .btn-success { color: #059669; border-color: #A7F3D0; }
[data-theme="light"] .btn-success:hover { background: #ECFDF5; }

/* ============================================================
   NAV TABS
   ============================================================ */
.nav-bar {
    display: flex; align-items: center; gap: 0;
    padding: 0 24px;
    background: var(--surface-elevated);
    border-bottom: 1px solid var(--border);
    position: fixed; top: 54px; left: 0; right: 0; z-index: 99;
    overflow-x: auto; overflow-y: hidden;
    -webkit-overflow-scrolling: touch;
    scrollbar-width: none;
    backdrop-filter: blur(28px) saturate(1.2); -webkit-backdrop-filter: blur(28px) saturate(1.2);
}
.nav-bar::-webkit-scrollbar { display: none; }
[data-theme="light"] .nav-bar { background: var(--surface-solid); }
@media (max-width: 900px) {
    .nav-bar { padding: 0 12px; }
    .nav-tab { padding: 12px 12px; font-size: 11px; }
    .nav-icon { width: 13px; height: 13px; }
}

/* Animated sliding indicator */
.nav-indicator {
    position: absolute; bottom: 0; left: 0; height: 2px;
    background: linear-gradient(90deg, transparent, var(--neon-cyan), transparent); border-radius: 2px 2px 0 0;
    transition: left var(--transition), width var(--transition);
    box-shadow: 0 0 8px rgba(201,169,98,0.25);
}
[data-theme="light"] .nav-indicator { background: #2563EB; box-shadow: 0 0 8px rgba(37,99,235,0.2); }

.nav-tab {
    padding: 14px 20px;
    font-family: var(--font-display); font-size: 12px; font-weight: 600;
    letter-spacing: 0.01em;
    color: var(--text-muted); cursor: pointer;
    border-bottom: 2px solid transparent;
    transition: color var(--transition-fast);
    white-space: nowrap;
    display: flex; align-items: center; gap: 6px;
}
.nav-icon { width: 15px; height: 15px; flex-shrink: 0; display: inline-block; vertical-align: middle; }
.nav-icon svg { width: 100%; height: 100%; stroke: currentColor; fill: none; stroke-width: 1.6; stroke-linecap: round; stroke-linejoin: round; }
.bnav-icon { width: 22px; height: 22px; display: block; margin: 0 auto 1px; }
.bnav-icon svg { width: 100%; height: 100%; stroke: currentColor; fill: none; stroke-width: 1.5; stroke-linecap: round; stroke-linejoin: round; }
    transition: color var(--transition);
    white-space: nowrap;
    position: relative;
}
.nav-tab:hover { color: var(--text-secondary); }
.nav-tab.active { color: var(--neon-cyan); border-bottom-color: transparent; }
[data-theme="light"] .nav-tab.active { color: #2563EB; }

/* Timer-Indikator im Tab (pulsierender Punkt) */
.timer-dot {
    display: none; width: 7px; height: 7px;
    border-radius: 50%; background: var(--neon-green);
    margin-left: 5px; vertical-align: middle;
}
.timer-dot.running {
    display: inline-block;
    animation: timerPulse 1.5s ease-in-out infinite;
}
.timer-dot.paused {
    display: inline-block;
    background: var(--neon-yellow);
    animation: none;
}
@keyframes timerPulse {
    0%, 100% { opacity: 1; box-shadow: 0 0 0 0 rgba(110,196,158,0.35); }
    50% { opacity: 0.6; box-shadow: 0 0 6px 2px rgba(110,196,158,0.20); }
}
[data-theme="light"] .timer-dot.running { background: #22C55E; }
[data-theme="light"] .timer-dot.paused { background: #F59E0B; }

/* ============================================================
   MAIN CONTENT
   ============================================================ */
.main-content { max-width: 1100px; margin: 0 auto; padding: 28px 24px; padding-top: 110px; padding-bottom: 100px; position: relative; z-index: 1; overflow-x: hidden; }

.view { display: none; }
.view.active { display: block; animation: viewIn 0.45s cubic-bezier(0.22, 1, 0.36, 1); }
@keyframes viewIn { from { opacity: 0; transform: translateY(16px) scale(0.99); } to { opacity: 1; transform: translateY(0) scale(1); } }

/* Staggered entrance for cards and sections */
.view.active > .card,
.view.active > .kpi-strip,
.view.active > .dash-mid,
.view.active > .timer-layout,
.view.active > .manage-grid,
.view.active > .team-dash-grid,
.view.active > .entries-header { animation: staggerIn 0.5s cubic-bezier(0.22, 1, 0.36, 1) both; }
.view.active > *:nth-child(1) { animation-delay: 0s; }
.view.active > *:nth-child(2) { animation-delay: 0.07s; }
.view.active > *:nth-child(3) { animation-delay: 0.13s; }
.view.active > *:nth-child(4) { animation-delay: 0.19s; }
.view.active > *:nth-child(5) { animation-delay: 0.25s; }
.view.active > *:nth-child(6) { animation-delay: 0.3s; }
@keyframes staggerIn { from { opacity: 0; transform: translateY(20px); } to { opacity: 1; transform: translateY(0); } }

/* ============================================================
   CARDS & PANELS – Premium Glass v2
   ============================================================ */
.card {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: var(--radius-lg);
    padding: 22px;
    backdrop-filter: blur(24px) saturate(1.15); -webkit-backdrop-filter: blur(24px) saturate(1.15);
    transition: border-color var(--transition), box-shadow var(--transition), transform var(--transition);
    position: relative;
    overflow: hidden;
    min-width: 0;
}
.card::before {
    content: ''; position: absolute; inset: 0; border-radius: inherit;
    background: linear-gradient(135deg, rgba(201,169,98,0.02) 0%, transparent 50%, rgba(155,142,196,0.012) 100%);
    pointer-events: none; opacity: 0; transition: opacity var(--transition);
}
.card:hover { border-color: var(--border-hover); transform: translateY(-2px); box-shadow: var(--shadow-glow); }
.card:hover::before { opacity: 1; }
[data-theme="light"] .card { background: var(--surface-solid); backdrop-filter: none; -webkit-backdrop-filter: none; box-shadow: var(--shadow); }
[data-theme="light"] .card:hover { box-shadow: var(--shadow-lg); transform: translateY(-2px); }
[data-theme="light"] .card::before { background: linear-gradient(135deg, rgba(37,99,235,0.015) 0%, transparent 50%, rgba(124,58,237,0.01) 100%); }

.card-title {
    font-family: var(--font-display); font-size: 13px; font-weight: 700;
    letter-spacing: -0.01em;
    color: var(--text-muted); margin-bottom: 14px;
    display: flex; align-items: center; gap: 8px;
}

/* ============================================================
   FORM ELEMENTS
   ============================================================ */
.form-group { margin-bottom: 14px; }
.form-label {
    display: block; margin-bottom: 6px;
    font-family: var(--font-display); font-size: 11px; font-weight: 600;
    letter-spacing: 0.02em; color: var(--text-muted);
}
.form-select, .form-input {
    width: 100%; padding: 10px 14px;
    border: 1px solid var(--border); border-radius: var(--radius-sm);
    background: rgba(16,17,24,0.88); color: #E2E8F0;
    font-family: var(--font); font-size: 13px;
    outline: none; transition: all var(--transition);
    -webkit-appearance: none; appearance: none;
}
.form-select { background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%234D4941' d='M6 8L1 3h10z'/%3E%3C/svg%3E"); background-repeat: no-repeat; background-position: right 12px center; padding-right: 32px; cursor: pointer; }
.form-select:focus, .form-input:focus { border-color: rgba(201,169,98,0.30); box-shadow: 0 0 0 3px rgba(201,169,98,0.05); }
.form-input::placeholder { color: var(--text-muted); }
.form-select option { background: #1A1C26; color: #E8E4DF; }
[data-theme="light"] .form-select option { background: #fff; color: #1E293B; }

[data-theme="light"] .form-select, [data-theme="light"] .form-input { background-color: var(--surface-solid); color: var(--text); border-color: var(--border); }
[data-theme="light"] .form-select { background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%235F5D58' d='M6 8L1 3h10z'/%3E%3C/svg%3E"); }
[data-theme="light"] .form-select:focus, [data-theme="light"] .form-input:focus { border-color: #93C5FD; box-shadow: 0 0 0 3px rgba(37,99,235,0.06); }

/* ============================================================
   TIMER VIEW
   ============================================================ */
.timer-layout { display: grid; grid-template-columns: 1fr 1fr; gap: 24px; align-items: start; }
@media (max-width: 768px) { .timer-layout { grid-template-columns: 1fr; } }

.timer-fields { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 12px; }
@media (max-width: 600px) { .timer-fields { grid-template-columns: 1fr; } }
.timer-fields .form-group.full-width { grid-column: 1 / -1; }

/* Kreisförmiger Timer */
.timer-circle-wrap {
    display: flex; flex-direction: column; align-items: center; justify-content: center;
    padding: 20px 0;
}
.timer-circle {
    width: var(--timer-size); height: var(--timer-size);
    position: relative;
    filter: var(--timer-glow);
    transition: filter var(--transition);
}
.timer-circle:hover { filter: var(--timer-glow) brightness(1.05); }
.timer-circle svg { width: 100%; height: 100%; transform: rotate(-90deg); }
.timer-circle .track { fill: none; stroke: var(--border); stroke-width: 4; }
.timer-circle .progress { fill: none; stroke: var(--timer-stroke); stroke-width: 4.5; stroke-linecap: round; stroke-dasharray: 628.32; stroke-dashoffset: 628.32; transition: stroke-dashoffset 0.5s ease; }
.timer-display {
    position: absolute; inset: 0;
    display: flex; flex-direction: column; align-items: center; justify-content: center;
}
.timer-time {
    font-family: var(--font-mono); font-size: 42px; font-weight: 700;
    color: var(--text); letter-spacing: 4px;
    transition: color var(--transition);
    text-shadow: 0 0 30px rgba(201,169,98,0.07);
}
[data-theme="light"] .timer-time { text-shadow: none; }
.timer-sub {
    font-family: var(--font-display); font-size: 10px; font-weight: 600;
    letter-spacing: 0.05em;
    color: var(--text-muted); margin-top: 4px;
}

.timer-controls { display: flex; gap: 12px; margin-top: 22px; justify-content: center; }
.timer-btn {
    width: 56px; height: 56px;
    border-radius: 50%;
    border: 2px solid var(--border);
    background: var(--surface);
    color: var(--text-secondary);
    font-size: 18px; cursor: pointer;
    display: flex; align-items: center; justify-content: center;
    transition: all 0.25s cubic-bezier(0.22, 1, 0.36, 1);
    position: relative;
}
.timer-btn:hover { border-color: var(--border-hover); color: var(--text); transform: scale(1.12); }
.timer-btn:active { transform: scale(0.92); }
.timer-btn.start { border-color: rgba(201,169,98,0.25); color: var(--neon-cyan); }
.timer-btn.start:hover { background: rgba(201,169,98,0.07); box-shadow: var(--glow-cyan); }
.timer-btn.stop { border-color: rgba(212,112,110,0.25); color: var(--neon-red); }
.timer-btn.stop:hover { background: rgba(248,113,113,0.08); }
.timer-btn.running { border-color: var(--neon-cyan); color: var(--neon-cyan); animation: pulse 2s infinite; }
@keyframes pulse { 0%, 100% { box-shadow: 0 0 0 0 rgba(201,169,98,0.18); } 50% { box-shadow: 0 0 0 12px rgba(201,169,98,0); } }
[data-theme="light"] .timer-btn { background: var(--surface-solid); }
[data-theme="light"] .timer-btn.start { border-color: #93C5FD; color: #2563EB; }
[data-theme="light"] .timer-btn.running { border-color: #2563EB; color: #2563EB; }
.timer-btn.split { border-color: rgba(167,139,250,0.3); color: var(--neon-violet); font-size: 16px; }
.timer-btn.split:hover { background: rgba(155,142,196,0.07); }
[data-theme="light"] .timer-btn.split { border-color: #C4B5FD; color: #7C3AED; }

/* Split-Modal */
.split-modal { max-width: 600px; }
.split-total-bar {
    display: flex; align-items: center; gap: 12px;
    margin-bottom: 20px; padding: 14px 16px;
    background: rgba(0,0,0,0.15); border-radius: var(--radius-sm);
    border: 1px solid var(--border);
}
[data-theme="light"] .split-total-bar { background: #F8FAFC; }
.split-total-time {
    font-family: var(--font-mono); font-size: 24px; font-weight: 700;
    color: var(--neon-cyan); white-space: nowrap;
}
[data-theme="light"] .split-total-time { color: #2563EB; }
.split-total-label { font-size: 12px; color: var(--text-muted); }

/* Verteilungsbalken */
.split-alloc-bar {
    height: 8px; border-radius: 4px;
    background: rgba(0,0,0,0.2); overflow: hidden;
    display: flex; margin-bottom: 16px;
}
[data-theme="light"] .split-alloc-bar { background: #E2E8F0; }
.split-alloc-seg { height: 100%; transition: width 0.3s ease; }

/* Split-Zeilen */
.split-rows { display: flex; flex-direction: column; gap: 10px; margin-bottom: 16px; max-height: 340px; overflow-y: auto; }
.split-row {
    display: grid; grid-template-columns: 1fr 1fr 1fr 70px 32px; gap: 8px;
    align-items: end; padding: 12px; border-radius: var(--radius-sm);
    border: 1px solid var(--border); background: rgba(0,0,0,0.08);
}
[data-theme="light"] .split-row { background: #FAFAFA; }
.split-row .form-group { margin-bottom: 0; }
.split-row .form-label { font-size: 9px; margin-bottom: 3px; }
.split-row .form-select { font-size: 12px; padding: 6px 8px; }

.split-pct-wrap { text-align: center; }
.split-pct-input {
    width: 60px; padding: 6px 4px; text-align: center;
    border: 1px solid var(--border); border-radius: var(--radius-sm);
    background: rgba(0,0,0,0.25); color: var(--text);
    font-family: var(--font-mono); font-size: 14px; font-weight: 600; outline: none;
}
[data-theme="light"] .split-pct-input { background: var(--surface-solid); }
.split-pct-input:focus { border-color: rgba(167,139,250,0.4); }
.split-pct-dur {
    font-family: var(--font-mono); font-size: 10px;
    color: var(--text-muted); margin-top: 2px;
}

.split-remove-btn {
    background: none; border: none; cursor: pointer;
    color: var(--text-muted); font-size: 16px; padding: 4px;
    border-radius: 4px; transition: all 0.15s; align-self: center;
}
.split-remove-btn:hover { color: var(--neon-red); background: var(--surface-hover); }

.split-add-row {
    display: flex; align-items: center; justify-content: center; gap: 6px;
    padding: 8px; border: 1px dashed var(--border); border-radius: var(--radius-sm);
    color: var(--text-muted); font-size: 12px; cursor: pointer; transition: all 0.15s;
}
.split-add-row:hover { border-color: var(--border-hover); color: var(--text-secondary); background: var(--surface-hover); }

.split-remaining {
    font-family: var(--font-mono); font-size: 12px; font-weight: 600;
    text-align: center; padding: 6px 0;
}
.split-remaining.ok { color: var(--neon-green); }
.split-remaining.over { color: var(--neon-red); }
.split-remaining.under { color: var(--neon-yellow); }

@media (max-width: 600px) {
    .split-row { grid-template-columns: 1fr 1fr; }
    .split-row .form-group:nth-child(3) { grid-column: 1 / -1; }
    .split-pct-wrap { grid-column: 1; }
    .split-remove-btn { grid-column: 2; justify-self: end; }
}
[data-theme="light"] @keyframes pulse { 0%, 100% { box-shadow: 0 0 0 0 rgba(59,130,246,0.2); } 50% { box-shadow: 0 0 0 10px rgba(59,130,246,0); } }

/* Status-Anzeige */
.timer-status {
    text-align: center; margin-top: 14px;
    font-family: var(--font-display); font-size: 11px; font-weight: 600;
    letter-spacing: 0.03em;
}
.timer-status.idle { color: var(--text-muted); }
.timer-status.active { color: var(--neon-cyan); }
[data-theme="light"] .timer-status.active { color: #2563EB; }

/* ============================================================
   EINTRÄGE-TABELLE
   ============================================================ */
.entries-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px; flex-wrap: wrap; gap: 10px; }
.entries-filters { display: flex; gap: 8px; align-items: center; flex-wrap: wrap; }
.filter-input {
    padding: 7px 10px;
    border: 1px solid var(--border); border-radius: var(--radius-sm);
    background: rgba(16,17,24,0.88); color: #E2E8F0;
    font-family: var(--font-mono); font-size: 12px; outline: none;
    width: 130px;
}
.filter-input::-webkit-calendar-picker-indicator { filter: invert(0.7); }
[data-theme="light"] .filter-input { background: var(--surface-solid); color: var(--text); }
[data-theme="light"] .filter-input::-webkit-calendar-picker-indicator { filter: none; }
.filter-input:focus { border-color: rgba(201,169,98,0.25); }
[data-theme="light"] .filter-input:focus { border-color: #93C5FD; }
.filter-select {
    padding: 7px 10px; border: 1px solid var(--border); border-radius: var(--radius-sm);
    background: rgba(16,17,24,0.88); color: #E2E8F0; font-family: var(--font); font-size: 12px;
    outline: none; min-width: 110px; max-width: 160px; cursor: pointer; appearance: none;
    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='10' height='6'%3E%3Cpath d='M0 0l5 6 5-6z' fill='%23908B83'/%3E%3C/svg%3E");
    background-repeat: no-repeat; background-position: right 8px center; padding-right: 24px;
}
.filter-select option { background: #1A1C26; color: #E8E4DF; }
[data-theme="light"] .filter-select { background-color: var(--surface-solid); color: var(--text); background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='10' height='6'%3E%3Cpath d='M0 0l5 6 5-6z' fill='%23667'/%3E%3C/svg%3E"); }
[data-theme="light"] .filter-select option { background: #fff; color: #1E293B; }
.filter-select:focus { border-color: rgba(201,169,98,0.25); }
[data-theme="light"] .filter-select:focus { border-color: #93C5FD; }
.filter-row { display: flex; gap: 6px; align-items: center; flex-wrap: wrap; }
.filter-text { padding: 7px 10px; border: 1px solid var(--border); border-radius: var(--radius-sm); background: rgba(16,17,24,0.88); color: #E2E8F0; font-family: var(--font); font-size: 12px; outline: none; width: 140px; }
[data-theme="light"] .filter-text { background-color: var(--surface-solid); }
.filter-text:focus { border-color: rgba(201,169,98,0.25); }
[data-theme="light"] .filter-text:focus { border-color: #93C5FD; }
.filter-active-bar { display: flex; align-items: center; gap: 8px; padding: 6px 12px; margin-bottom: 10px; border-radius: var(--radius-sm); background: rgba(201,169,98,0.05); border: 1px solid rgba(201,169,98,0.12); font-size: 11px; color: var(--neon-cyan); }
[data-theme="light"] .filter-active-bar { background: rgba(37,99,235,0.04); border-color: rgba(37,99,235,0.12); color: #2563EB; }
.filter-active-bar .filter-tag { display: inline-flex; align-items: center; gap: 4px; padding: 2px 8px; border-radius: 10px; background: rgba(201,169,98,0.08); font-weight: 500; }
[data-theme="light"] .filter-active-bar .filter-tag { background: rgba(37,99,235,0.08); }
.filter-active-bar .filter-clear-all { cursor: pointer; padding: 2px 8px; border-radius: 10px; border: 1px solid rgba(212,112,110,0.18); color: var(--danger); margin-left: auto; }
.filter-active-bar .filter-clear-all:hover { background: rgba(248,113,113,0.08); }
.dash-filters { display: flex; gap: 6px; align-items: center; flex-wrap: wrap; margin: 0 0 10px 0; }
.dash-filter-select { padding: 7px 10px; border: 1px solid var(--border); border-radius: 20px; background: rgba(16,17,24,0.88); color: #E2E8F0; font-family: var(--font); font-size: 12px; outline: none; min-width: 100px; max-width: 160px; cursor: pointer; appearance: none; background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='10' height='6'%3E%3Cpath d='M0 0l5 6 5-6z' fill='%23908B83'/%3E%3C/svg%3E"); background-repeat: no-repeat; background-position: right 10px center; padding-right: 26px; }
.dash-filter-select option { background: #1A1C26; color: #E8E4DF; }
[data-theme="light"] .dash-filter-select { background-color: var(--surface-solid); color: var(--text); background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='10' height='6'%3E%3Cpath d='M0 0l5 6 5-6z' fill='%23667'/%3E%3C/svg%3E"); }
[data-theme="light"] .dash-filter-select option { background: #fff; color: #1E293B; }
.dash-filter-select:focus { border-color: rgba(201,169,98,0.30); }
[data-theme="light"] .dash-filter-select:focus { border-color: #93C5FD; }

.entries-table { width: 100%; border-collapse: collapse; }
.entries-table th {
    font-family: var(--font-display); font-size: 11px; font-weight: 600;
    letter-spacing: 0.02em;
    color: var(--text-muted); text-align: left;
    padding: 12px 10px; border-bottom: 1px solid var(--border);
}
.entries-table td {
    padding: 12px 10px; font-size: 13px;
    border-bottom: 1px solid rgba(0,0,0,0.08);
    vertical-align: middle;
    transition: background var(--transition-fast);
}
[data-theme="light"] .entries-table td { border-bottom-color: var(--border); }
.entries-table tr:hover td { background: var(--surface-hover); }
.entries-table .col-actions { text-align: right; white-space: nowrap; }
.entries-table .col-duration { font-family: var(--font-mono); font-weight: 500; color: var(--neon-cyan); }
[data-theme="light"] .entries-table .col-duration { color: #2563EB; }
.entries-table .col-date { font-family: var(--font-mono); font-size: 12px; }
.entries-table .col-time { font-family: var(--font-mono); font-size: 12px; color: var(--text-secondary); }

.entry-actions { display: flex; gap: 4px; justify-content: flex-end; }
.entry-btn {
    background: none; border: none; cursor: pointer;
    color: var(--text-muted); font-size: 14px; padding: 4px;
    border-radius: 4px; transition: all 0.15s;
}
.entry-btn:hover { color: var(--text); background: var(--surface-hover); }
.entry-btn.delete:hover { color: var(--neon-red); }

.no-entries {
    text-align: center; padding: 50px 20px;
    color: var(--text-muted); font-size: 13px;
}
.no-entries .icon { font-size: 48px; margin-bottom: 14px; display: block; animation: emptyFloat 3s ease-in-out infinite; }
@keyframes emptyFloat { 0%,100% { transform: translateY(0); } 50% { transform: translateY(-8px); } }
.no-entries p { max-width: 300px; margin: 0 auto; line-height: 1.6; }

.table-scroll { overflow-x: auto; }

/* ============================================================
   DASHBOARD – Variante 5: KPIs + Heatmap + Balken + Zeitverlauf
   ============================================================ */

/* KPI-Leiste */
.kpi-strip { display: grid; grid-template-columns: repeat(4, 1fr); gap: 12px; margin-bottom: 18px; }
@media (max-width: 768px) { .kpi-strip { grid-template-columns: 1fr 1fr; gap: 10px; } }
@media (max-width: 600px) { .kpi-strip { grid-template-columns: 1fr; } }
.kpi-card {
    background: var(--surface); border: 1px solid var(--border);
    border-radius: var(--radius-lg); padding: 18px 18px;
    text-align: center;
    backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px);
    transition: all var(--transition);
    position: relative; overflow: hidden;
}
.kpi-card::before {
    content: ''; position: absolute; top: 0; left: 0; right: 0; height: 3px;
    background: linear-gradient(90deg, transparent 10%, var(--neon-cyan), transparent 90%);
    opacity: 0.6;
}
.kpi-card::after {
    content: ''; position: absolute; inset: 0;
    background: radial-gradient(ellipse at 50% 0%, rgba(201,169,98,0.04) 0%, transparent 70%);
    pointer-events: none;
}
.kpi-card:hover { transform: translateY(-3px); border-color: var(--border-hover); box-shadow: var(--shadow-glow); }
[data-theme="light"] .kpi-card { background: var(--surface-solid); backdrop-filter: none; box-shadow: var(--shadow); }
[data-theme="light"] .kpi-card::before { background: linear-gradient(90deg, transparent 10%, #2563EB, transparent 90%); opacity: 0.5; }
[data-theme="light"] .kpi-card::after { background: radial-gradient(ellipse at 50% 0%, rgba(37,99,235,0.03) 0%, transparent 70%); }
[data-theme="light"] .kpi-card:hover { box-shadow: var(--shadow-lg); }
.kpi-value {
    font-family: var(--font-mono); font-size: 36px; font-weight: 700;
    color: var(--neon-cyan); line-height: 1.1;
    transition: color var(--transition);
    position: relative; z-index: 1;
}
[data-theme="light"] .kpi-value { color: #2563EB; }
.kpi-label {
    font-family: var(--font-display); font-size: 11px; font-weight: 600;
    letter-spacing: 0.02em;
    color: var(--text-muted); margin-top: 8px;
    position: relative; z-index: 1;
}

/* Perioden-Auswahl */
.dash-period { display: flex; gap: 6px; margin-bottom: 14px; flex-wrap: wrap; align-items: center; }
.period-btn {
    padding: 7px 16px;
    border: 1px solid var(--border); border-radius: 20px;
    background: transparent; color: var(--text-muted);
    font-family: var(--font-display); font-size: 11px; font-weight: 600;
    letter-spacing: 0.01em;
    cursor: pointer; transition: all var(--transition);
}
.period-btn:hover { color: var(--text-secondary); border-color: var(--border-hover); }
.period-btn.active { color: var(--neon-cyan); border-color: rgba(201,169,98,0.25); background: rgba(201,169,98,0.05); }
[data-theme="light"] .period-btn.active { color: #2563EB; border-color: #BFDBFE; background: #EFF6FF; }

/* Mittlere Zone: 2-Spalter */
.dash-mid { display: grid; grid-template-columns: 1fr 1fr; gap: 14px; margin-bottom: 14px; min-width: 0; }
.dash-mid > * { min-width: 0; }
@media (max-width: 768px) { .dash-mid { grid-template-columns: 1fr; } }

/* Heatmap: Stakeholder × Projekt */
.heatmap-wrap { overflow-x: auto; max-width: 100%; -webkit-overflow-scrolling: touch; }
.heatmap { border-collapse: collapse; min-width: 280px; }
.heatmap th {
    font-family: var(--font-display); font-size: 9px; font-weight: 600;
    letter-spacing: 1px; text-transform: uppercase; color: var(--text-muted);
    padding: 6px 8px; text-align: center; white-space: nowrap;
}
.heatmap th.hm-row-label { text-align: left; }
.heatmap td {
    padding: 6px 8px; text-align: center;
    font-family: var(--font-mono); font-size: 11px; font-weight: 500;
    border-radius: 4px; transition: all 0.2s; position: relative;
}
.heatmap td.hm-row-label {
    text-align: left; font-family: var(--font); font-size: 12px;
    font-weight: 500; color: var(--text-secondary);
    max-width: 110px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;
}
.heatmap td.hm-cell { cursor: default; transition: all 0.25s ease; }
.heatmap td.hm-cell:hover { outline: 1px solid var(--border-hover); transform: scale(1.08); z-index: 2; box-shadow: var(--glow-soft); }

/* Heatmap-Farbstufen (Cyber) */
.hm-0 { color: var(--text-muted); }
.hm-1 { background: rgba(201,169,98,0.05); color: rgba(201,169,98,0.6); }
.hm-2 { background: rgba(201,169,98,0.10); color: rgba(201,169,98,0.8); }
.hm-3 { background: rgba(201,169,98,0.20); color: rgba(201,169,98,0.95); }
.hm-4 { background: rgba(201,169,98,0.35); color: #fff; }
.hm-5 { background: rgba(201,169,98,0.55); color: #fff; text-shadow: 0 0 6px rgba(201,169,98,0.30); }
[data-theme="light"] .hm-1 { background: #EFF6FF; color: #3B82F6; }
[data-theme="light"] .hm-2 { background: #DBEAFE; color: #2563EB; }
[data-theme="light"] .hm-3 { background: #BFDBFE; color: #1D4ED8; }
[data-theme="light"] .hm-4 { background: #93C5FD; color: #fff; }
[data-theme="light"] .hm-5 { background: #3B82F6; color: #fff; text-shadow: none; }

/* Heatmap Zeilen-/Spaltentotale */
.hm-total { font-weight: 700; color: var(--text-secondary); }

/* Balkendiagramm */
.bar-chart { margin-top: 14px; overflow-x: auto; }
.bar-row { display: flex; align-items: center; gap: 12px; margin-bottom: 10px; }
.bar-label {
    width: 110px; min-width: 110px;
    font-size: 12px; font-weight: 500;
    color: var(--text-secondary);
    overflow: hidden; text-overflow: ellipsis; white-space: nowrap;
}
.bar-track { flex: 1; height: 28px; background: rgba(0,0,0,0.15); border-radius: 6px; overflow: hidden; }
[data-theme="light"] .bar-track { background: #F1F5F9; }
.bar-fill {
    height: 100%; border-radius: 6px;
    display: flex; align-items: center; padding: 0 10px;
    font-family: var(--font-mono); font-size: 10px; font-weight: 700;
    color: rgba(255,255,255,0.9); transition: width 0.8s cubic-bezier(0.22, 1, 0.36, 1);
    min-width: fit-content;
    position: relative; overflow: hidden;
}
.bar-fill::after {
    content: ''; position: absolute; top: 0; left: -100%; width: 100%; height: 100%;
    background: linear-gradient(90deg, transparent, rgba(255,255,255,0.08), transparent);
    animation: barShimmer 3s ease-in-out infinite;
}
@keyframes barShimmer { 0% { left: -100%; } 50%,100% { left: 200%; } }
.bar-fill.c0 { background: linear-gradient(90deg, rgba(201,169,98,0.6), rgba(201,169,98,0.30)); }
.bar-fill.c1 { background: linear-gradient(90deg, rgba(196,139,159,0.65), rgba(196,139,159,0.35)); }
.bar-fill.c2 { background: linear-gradient(90deg, rgba(155,142,196,0.65), rgba(155,142,196,0.35)); }
.bar-fill.c3 { background: linear-gradient(90deg, rgba(110,196,158,0.6), rgba(110,196,158,0.30)); }
.bar-fill.c4 { background: linear-gradient(90deg, rgba(229,168,75,0.65), rgba(229,168,75,0.35)); }
.bar-fill.c5 { background: linear-gradient(90deg, rgba(212,149,106,0.65), rgba(212,149,106,0.35)); }
[data-theme="light"] .bar-fill.c0 { background: linear-gradient(90deg, #3B82F6, #60A5FA); }
[data-theme="light"] .bar-fill.c1 { background: linear-gradient(90deg, #EC4899, #F472B6); }
[data-theme="light"] .bar-fill.c2 { background: linear-gradient(90deg, #8B5CF6, #A78BFA); }
[data-theme="light"] .bar-fill.c3 { background: linear-gradient(90deg, #22C55E, #4ADE80); }
[data-theme="light"] .bar-fill.c4 { background: linear-gradient(90deg, #F59E0B, #FBBF24); }
[data-theme="light"] .bar-fill.c5 { background: linear-gradient(90deg, #F97316, #FB923C); }

/* Zeitverlauf: gestapelte Tagesbalken */
.timeline-chart { margin-top: 12px; overflow-x: auto; }
.tl-row { display: flex; align-items: stretch; gap: 6px; margin-bottom: 4px; }
.tl-label {
    width: 55px; min-width: 55px;
    font-family: var(--font-mono); font-size: 10px; font-weight: 500;
    color: var(--text-muted); display: flex; align-items: center;
}
.tl-label .tl-day { color: var(--text-secondary); margin-left: 3px; }
.tl-bar-wrap {
    flex: 1; display: flex; height: 22px;
    background: rgba(0,0,0,0.12); border-radius: 3px; overflow: hidden;
}
[data-theme="light"] .tl-bar-wrap { background: #F1F5F9; }
.tl-segment {
    height: 100%; display: flex; align-items: center; justify-content: center;
    font-family: var(--font-mono); font-size: 9px; font-weight: 600;
    color: rgba(255,255,255,0.85); overflow: hidden; white-space: nowrap;
    transition: width 0.4s ease;
}
.tl-hours {
    width: 45px; min-width: 45px; text-align: right;
    font-family: var(--font-mono); font-size: 10px; font-weight: 600;
    color: var(--text-secondary); display: flex; align-items: center; justify-content: flex-end;
}
.tl-weekend .tl-label { color: var(--text-muted); opacity: 0.6; }

/* Zeitverlauf-Legende */
.tl-legend { display: flex; flex-wrap: wrap; gap: 12px; margin-top: 10px; padding-top: 8px; border-top: 1px solid var(--border); }
.tl-legend-item { display: flex; align-items: center; gap: 5px; font-size: 11px; color: var(--text-secondary); }
.tl-legend-dot { width: 10px; height: 10px; border-radius: 2px; }

/* ============================================================
   STAMMDATEN / VERWALTUNG
   ============================================================ */
.manage-grid { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 20px; }
@media (max-width: 768px) { .manage-grid { grid-template-columns: 1fr; } }

.manage-list { list-style: none; margin-top: 10px; }
.manage-item {
    display: flex; align-items: center; justify-content: space-between;
    padding: 8px 10px; border-radius: var(--radius-sm);
    font-size: 13px; transition: background 0.15s;
}
.manage-item:hover { background: var(--surface-hover); }
.manage-item .item-name { flex: 1; }
.manage-item .item-actions { display: flex; gap: 2px; }

.manage-add {
    display: flex; gap: 6px; margin-top: 10px;
}
.manage-add input {
    flex: 1; padding: 7px 10px;
    border: 1px solid var(--border); border-radius: var(--radius-sm);
    background: rgba(0,0,0,0.25); color: var(--text);
    font-family: var(--font); font-size: 13px; outline: none;
}
[data-theme="light"] .manage-add input { background: var(--surface-solid); }
.manage-add input:focus { border-color: rgba(201,169,98,0.25); }
[data-theme="light"] .manage-add input:focus { border-color: #93C5FD; }

/* ============================================================
   MODAL
   ============================================================ */
.modal-overlay {
    position: fixed; inset: 0; z-index: 500;
    background: rgba(0,0,0,0.55); backdrop-filter: blur(12px); -webkit-backdrop-filter: blur(12px);
    display: none; align-items: center; justify-content: center;
    padding: 20px; animation: overlayFadeIn 0.2s ease;
}
@keyframes overlayFadeIn { from { opacity: 0; } to { opacity: 1; } }
.modal-overlay.open { display: flex; }
.modal {
    background: var(--surface-solid); border: 1px solid var(--border);
    border-radius: var(--radius-lg); padding: 32px;
    width: 100%; max-width: 480px;
    box-shadow: 0 24px 80px rgba(0,0,0,0.4);
    animation: modalIn 0.3s cubic-bezier(0.4, 0, 0.2, 1);
}
@keyframes modalIn { from { opacity: 0; transform: scale(0.92) translateY(10px); } to { opacity: 1; transform: scale(1) translateY(0); } }
.modal-title {
    font-family: var(--font-display); font-size: 16px; font-weight: 700;
    letter-spacing: -0.01em;
    color: var(--text); margin-bottom: 22px;
}
.modal-actions { display: flex; gap: 10px; justify-content: flex-end; margin-top: 24px; }

/* ============================================================
   TOAST
   ============================================================ */
.toast-container { position: fixed; bottom: 24px; right: 24px; z-index: 600; display: flex; flex-direction: column; gap: 10px; }
.toast {
    padding: 14px 22px; border-radius: var(--radius);
    background: var(--surface-solid); border: 1px solid var(--border);
    color: var(--text); font-size: 13px;
    box-shadow: var(--shadow-lg);
    animation: toastSlideIn 0.35s cubic-bezier(0.4, 0, 0.2, 1);
    max-width: 380px;
    display: flex; align-items: center; gap: 10px;
    backdrop-filter: blur(16px);
    position: relative; overflow: hidden;
}
.toast::after {
    content: ''; position: absolute; bottom: 0; left: 0; right: 0; height: 3px;
    background: var(--neon-cyan);
    animation: toastProgress 3s linear forwards;
}
.toast.success { border-color: rgba(110,196,158,0.25); }
.toast.success::after { background: var(--success); }
.toast.error { border-color: rgba(212,112,110,0.25); }
.toast.error::after { background: var(--danger); }
.toast-undo {
    background: none; border: 1px solid var(--neon-cyan); color: var(--neon-cyan);
    padding: 4px 12px; border-radius: var(--radius-sm); cursor: pointer;
    font-family: var(--font-display); font-size: 11px; font-weight: 600;
    transition: all var(--transition-fast); margin-left: auto; white-space: nowrap;
}
.toast-undo:hover { background: rgba(201,169,98,0.08); }
[data-theme="light"] .toast { background: #1A1814; color: white; border: none; }
[data-theme="light"] .toast.success { background: #059669; }
[data-theme="light"] .toast.error { background: #DC2626; }
[data-theme="light"] .toast-undo { border-color: rgba(255,255,255,0.5); color: white; }
@keyframes toastSlideIn { from { opacity: 0; transform: translateX(40px); } to { opacity: 1; transform: translateX(0); } }
@keyframes toastProgress { from { width: 100%; } to { width: 0; } }

/* ============================================================
   RESPONSIVE / MOBILE
   ============================================================ */
@media (max-width: 640px) {
    .top-bar { padding: 10px 12px; gap: 6px; }
    .app-logo span:not(.logo-icon) { display: none; }
    .app-logo { min-width: 0; flex-shrink: 0; }
    /* Hide top nav on mobile - use bottom nav instead */
    .nav-bar { display: none; }
    .main-content { padding: 16px 14px 120px; padding-top: 60px; }
    .card { padding: 18px; }
    .timer-fields { grid-template-columns: 1fr; }
    .manage-grid { grid-template-columns: 1fr; }
}

/* Mobile Bottom Navigation */
.bottom-nav {
    display: none; position: fixed; bottom: 0; left: 0; right: 0;
    background: var(--surface-elevated); border-top: 1px solid var(--border);
    z-index: 200; padding: 6px 0; padding-bottom: max(6px, env(safe-area-inset-bottom));
    backdrop-filter: blur(24px) saturate(1.3); -webkit-backdrop-filter: blur(24px) saturate(1.3);
}
@media (max-width: 640px) { .bottom-nav { display: flex; justify-content: space-around; } }
.bnav-item {
    display: flex; flex-direction: column; align-items: center; gap: 2px;
    padding: 6px 12px; cursor: pointer; color: var(--text-muted);
    transition: color var(--transition-fast);
    position: relative; -webkit-tap-highlight-color: transparent;
}
.bnav-item span { font-size: 10px; font-family: var(--font-display); font-weight: 600; letter-spacing: 0.02em; }
.bnav-item.active { color: var(--neon-cyan); }
.bnav-item.active::after {
    content: ''; position: absolute; top: 0; left: 50%; transform: translateX(-50%);
    width: 24px; height: 3px; border-radius: 0 0 3px 3px;
    background: var(--neon-cyan);
}
[data-theme="light"] .bnav-item.active { color: #2563EB; }
[data-theme="light"] .bnav-item.active::after { background: #2563EB; }

/* Keyboard shortcut hints */
.kbd-hint {
    display: inline-block; padding: 2px 6px; border-radius: 4px;
    background: rgba(0,0,0,0.2); border: 1px solid var(--border);
    font-family: var(--font-mono); font-size: 10px; color: var(--text-muted);
    margin-left: 6px; vertical-align: middle;
}
[data-theme="light"] .kbd-hint { background: #F1F5F9; }
@media (max-width: 768px) { .kbd-hint { display: none; } }

/* Quick-start recent panel */
.quick-start {
    display: flex; gap: 8px; flex-wrap: wrap; margin-bottom: 12px;
    padding-bottom: 12px; border-bottom: 1px solid var(--border);
}
.quick-chip {
    display: inline-flex; align-items: center; gap: 5px;
    padding: 6px 14px; border-radius: 20px;
    border: 1px solid var(--border); background: var(--surface);
    color: var(--text-secondary); font-size: 11px; font-weight: 500;
    cursor: pointer; transition: all 0.25s cubic-bezier(0.22, 1, 0.36, 1);
    max-width: 200px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;
}
.quick-chip:hover { border-color: var(--neon-cyan); color: var(--neon-cyan); background: var(--surface-hover); transform: translateY(-2px); box-shadow: var(--glow-soft); }
.quick-chip .qc-icon { font-size: 12px; opacity: 0.6; }
[data-theme="light"] .quick-chip { background: var(--surface-solid); }

/* Manual entry time inputs */
.time-inputs { display: flex; gap: 8px; align-items: center; }
.time-inputs input {
    width: 80px; padding: 7px 10px;
    border: 1px solid var(--border); border-radius: var(--radius-sm);
    background: rgba(0,0,0,0.25); color: var(--text);
    font-family: var(--font-mono); font-size: 13px; outline: none; text-align: center;
}
[data-theme="light"] .time-inputs input { background: var(--surface-solid); }
.time-inputs input:focus { border-color: rgba(201,169,98,0.25); }
[data-theme="light"] .time-inputs input:focus { border-color: #93C5FD; }
.time-sep { color: var(--text-muted); font-weight: 600; }

/* Inline-Add Buttons neben Dropdowns */
.field-with-add { display: flex; gap: 4px; align-items: stretch; }
.field-with-add .form-select { flex: 1; min-width: 0; }
.inline-add-btn {
    width: 28px; min-width: 28px; padding: 0;
    border: 1px solid var(--border); border-radius: var(--radius-sm);
    background: var(--surface); color: var(--text-muted);
    font-size: 15px; cursor: pointer; transition: all 0.2s;
    display: flex; align-items: center; justify-content: center;
    flex-shrink: 0;
}
.inline-add-btn:hover { border-color: var(--border-hover); color: var(--neon-cyan); background: var(--surface-hover); }
[data-theme="light"] .inline-add-btn { background: var(--surface-solid); }
[data-theme="light"] .inline-add-btn:hover { color: #2563EB; }

/* Heute-Total Anzeige im Timer */

/* Dashboard Notiz-Filter */
.dash-search { display: flex; gap: 8px; margin: 0 0 12px 0; }
.dash-search-input {
    flex: 1; padding: 9px 14px; border: 1px solid var(--border); border-radius: 20px;
    background: rgba(16,17,24,0.88); color: #E2E8F0; font-family: var(--font); font-size: 13px;
    outline: none; transition: all var(--transition);
}
.dash-search-input:focus { border-color: rgba(201,169,98,0.30); box-shadow: 0 0 0 3px rgba(201,169,98,0.05); }
.dash-search-input::placeholder { color: var(--text-muted); }
[data-theme="light"] .dash-search-input { background-color: var(--surface-solid); color: var(--text); border-color: var(--border); }
[data-theme="light"] .dash-search-input:focus { border-color: #93C5FD; box-shadow: 0 0 0 3px rgba(37,99,235,0.06); }
.dash-search-clear { padding: 8px 14px; border: 1px solid var(--border); border-radius: 20px; background: var(--surface); color: var(--text-muted); cursor: pointer; font-size: 13px; transition: all var(--transition); }
.dash-search-clear:hover { color: var(--danger); border-color: rgba(212,112,110,0.18); }
[data-theme="light"] .dash-search-clear { background-color: var(--surface-solid); }
.dash-filter-active { color: var(--neon-cyan); font-size: 11px; margin: 0 0 12px; font-weight: 500; }
.today-total {
    text-align: center; margin-top: 14px; padding: 10px 16px;
    border: 1px solid var(--border); border-radius: var(--radius-sm);
    background: rgba(0,0,0,0.15);
}
[data-theme="light"] .today-total { background: var(--surface-solid); }
.today-total-label {
    font-family: var(--font-display); font-size: 9px; font-weight: 600;
    letter-spacing: 1.5px; text-transform: uppercase; color: var(--text-muted);
}
.today-total-value {
    font-family: var(--font-mono); font-size: 20px; font-weight: 600;
    color: var(--neon-green); margin-top: 2px;
}
[data-theme="light"] .today-total-value { color: #16A34A; }

/* ============================================================
   TASK SLOTS
   ============================================================ */
.task-slot-list { display: flex; flex-direction: column; gap: 10px; margin-bottom: 14px; }

.task-slot {
    border: 1px solid var(--border); border-radius: var(--radius);
    padding: 14px; padding-left: 18px; background: rgba(0,0,0,0.06);
    transition: all var(--transition); position: relative;
    border-left: 3px solid var(--border);
}
[data-theme="light"] .task-slot { background: #FAFAFA; }
.task-slot:hover { border-color: var(--border-hover); transform: translateX(2px); }
.task-slot.active {
    border-color: rgba(201,169,98,0.30);
    border-left-color: var(--neon-cyan);
    background: rgba(201,169,98,0.025);
    box-shadow: 0 0 25px rgba(201,169,98,0.05), inset 0 1px 0 rgba(201,169,98,0.07);
}
[data-theme="light"] .task-slot.active {
    border-color: #93C5FD; border-left-color: #2563EB; background: #EFF6FF;
    box-shadow: 0 2px 12px rgba(37,99,235,0.06);
}
.task-slot.paused {
    border-color: rgba(251,191,36,0.3);
    border-left-color: var(--neon-yellow);
    background: rgba(251,191,36,0.02);
}
[data-theme="light"] .task-slot.paused { border-color: #FDE68A; border-left-color: #F59E0B; background: #FFFBEB; }

.ts-header {
    display: flex; align-items: center; gap: 8px; margin-bottom: 8px;
}
.ts-play-btn, .ts-stop-btn {
    width: 32px; height: 32px; border-radius: 50%;
    border: 1.5px solid var(--border); background: transparent;
    color: var(--text-muted); font-size: 13px;
    cursor: pointer; transition: all 0.2s;
    display: flex; align-items: center; justify-content: center; flex-shrink: 0;
}
.ts-play-btn:hover { border-color: rgba(201,169,98,0.30); color: var(--neon-cyan); background: rgba(201,169,98,0.05); }
[data-theme="light"] .ts-play-btn:hover { border-color: #93C5FD; color: #2563EB; background: #EFF6FF; }
.ts-play-btn.running { border-color: var(--neon-cyan); color: var(--neon-cyan); animation: pulse 2s infinite; }
.ts-play-btn.paused { border-color: var(--neon-yellow); color: var(--neon-yellow); }
[data-theme="light"] .ts-play-btn.running { border-color: #2563EB; color: #2563EB; }
[data-theme="light"] .ts-play-btn.paused { border-color: #F59E0B; color: #D97706; }

.ts-stop-btn { display: none; }
.task-slot.active .ts-stop-btn,
.task-slot.paused .ts-stop-btn { display: flex; }
.ts-stop-btn:hover { border-color: rgba(248,113,113,0.4); color: var(--neon-red); background: rgba(248,113,113,0.06); }

.ts-elapsed {
    font-family: var(--font-mono); font-size: 14px; font-weight: 700;
    color: var(--neon-cyan); display: none; min-width: 60px;
}
.task-slot.active .ts-elapsed { display: block; }
.task-slot.paused .ts-elapsed { display: block; color: var(--neon-yellow); }
[data-theme="light"] .ts-elapsed { color: #2563EB; }
[data-theme="light"] .task-slot.paused .ts-elapsed { color: #D97706; }

.ts-status {
    font-family: var(--font-display); font-size: 8px; font-weight: 600;
    letter-spacing: 1.5px; text-transform: uppercase;
    padding: 2px 8px; border-radius: 10px; display: none;
}
.task-slot.active .ts-status {
    display: inline-block;
    background: rgba(201,169,98,0.08); color: var(--neon-cyan);
}
.task-slot.paused .ts-status {
    display: inline-block;
    background: rgba(251,191,36,0.12); color: var(--neon-yellow);
}
[data-theme="light"] .task-slot.active .ts-status { background: #DBEAFE; color: #2563EB; }
[data-theme="light"] .task-slot.paused .ts-status { background: #FEF3C7; color: #D97706; }

.ts-spacer { flex: 1; }

.ts-remove-btn {
    background: none; border: none; cursor: pointer;
    color: var(--text-muted); font-size: 14px; padding: 4px 6px;
    border-radius: 4px; transition: all 0.15s; flex-shrink: 0;
    opacity: 0.5;
}
.ts-remove-btn:hover { color: var(--neon-red); opacity: 1; background: var(--surface-hover); }

.ts-fields {
    display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 6px; margin-bottom: 6px;
}
.ts-fields .form-select { font-size: 12px; padding: 6px 26px 6px 8px; }
@media (max-width: 600px) { .ts-fields { grid-template-columns: 1fr; } }

.ts-notiz {
    width: 100%; padding: 5px 8px;
    border: 1px solid var(--border); border-radius: var(--radius-sm);
    background: rgba(0,0,0,0.15); color: var(--text);
    font-family: var(--font); font-size: 12px; outline: none;
}
[data-theme="light"] .ts-notiz { background: var(--surface-solid); }
.ts-notiz:focus { border-color: rgba(201,169,98,0.25); }
.ts-notiz::placeholder { color: var(--text-muted); }

.task-slot-add {
    display: flex; align-items: center; justify-content: center; gap: 6px;
    padding: 10px; border: 1px dashed var(--border); border-radius: var(--radius);
    color: var(--text-muted); font-size: 12px; cursor: pointer; transition: all 0.15s;
}
.task-slot-add:hover { border-color: var(--border-hover); color: var(--text-secondary); background: var(--surface-hover); }

/* Welcome modal specifics */
.welcome-icon { font-size: 48px; text-align: center; margin-bottom: 16px; }
.welcome-text { font-size: 13px; color: var(--text-secondary); line-height: 1.6; margin-bottom: 16px; }
.welcome-or {
    text-align: center; padding: 10px 0;
    font-family: var(--font-display); font-size: 9px; font-weight: 600;
    letter-spacing: 1.5px; text-transform: uppercase; color: var(--text-muted);
}

/* Summaries in entries */
.entries-summary {
    display: flex; gap: 20px; margin-bottom: 16px; flex-wrap: wrap;
}
.summary-item {
    font-size: 12px; color: var(--text-secondary);
}
.summary-item strong {
    font-family: var(--font-mono); color: var(--neon-cyan); font-weight: 600;
}
[data-theme="light"] .summary-item strong { color: #2563EB; }
/* ============================================================
   TEAM VIEW
   ============================================================ */
.team-setup { text-align: center; padding: 30px 20px; }
.team-setup-icon { font-size: 48px; margin-bottom: 12px; }
.team-setup-text { color: var(--text-secondary); font-size: 14px; margin-bottom: 20px; }
.team-setup-actions { display: flex; flex-direction: column; gap: 12px; align-items: center; }
.team-status { display: flex; align-items: center; gap: 8px; padding: 8px 14px; border-radius: var(--radius); background: rgba(52,211,153,0.08); border: 1px solid rgba(52,211,153,0.2); margin-bottom: 10px; font-size: 12px; }
.team-status .dot { width: 8px; height: 8px; border-radius: 50%; background: var(--neon-green); flex-shrink: 0; }
.team-status.offline { background: rgba(248,113,113,0.08); border-color: rgba(212,112,110,0.18); }
.team-status.offline .dot { background: var(--danger); }
.team-name-input { padding: 10px 14px; border: 1px solid var(--border); border-radius: var(--radius-sm); background: var(--surface); color: var(--text); font-family: var(--font); font-size: 14px; width: 220px; text-align: center; outline: none; }
[data-theme="light"] .team-name-input { background-color: var(--surface-solid); }
.team-members { display: flex; gap: 6px; flex-wrap: wrap; margin-bottom: 10px; }
.team-chip { display: inline-flex; align-items: center; gap: 4px; padding: 4px 10px; border-radius: 16px; font-size: 11px; font-weight: 600; border: 1px solid var(--border); background: var(--surface); }
.team-chip .dot { width: 8px; height: 8px; border-radius: 50%; }
.team-chip .count { color: var(--text-muted); font-weight: 400; }
.team-chip.me { border-color: var(--neon-cyan); }

/* Team Person Colors */
.tpc0 { background: #C9A962; } .tpc0t { color: #C9A962; }
.tpc1 { background: #C48B9F; } .tpc1t { color: #C48B9F; }
.tpc2 { background: #9B8EC4; } .tpc2t { color: #9B8EC4; }
.tpc3 { background: #6EC49E; } .tpc3t { color: #6EC49E; }
.tpc4 { background: #E5A84B; } .tpc4t { color: #E5A84B; }
.tpc5 { background: #D4956A; } .tpc5t { color: #D4956A; }
.tpc6 { background: #D4706E; } .tpc6t { color: #D4706E; }
.tpc7 { background: #7EB8C4; } .tpc7t { color: #7EB8C4; }
[data-theme="light"] .tpc0 { background: #3B82F6; } [data-theme="light"] .tpc0t { color: #3B82F6; }
[data-theme="light"] .tpc1 { background: #EC4899; } [data-theme="light"] .tpc1t { color: #EC4899; }
[data-theme="light"] .tpc2 { background: #8B5CF6; } [data-theme="light"] .tpc2t { color: #8B5CF6; }
[data-theme="light"] .tpc3 { background: #22C55E; } [data-theme="light"] .tpc3t { color: #22C55E; }
[data-theme="light"] .tpc4 { background: #F59E0B; } [data-theme="light"] .tpc4t { color: #F59E0B; }
[data-theme="light"] .tpc5 { background: #F97316; } [data-theme="light"] .tpc5t { color: #F97316; }
[data-theme="light"] .tpc6 { background: #EF4444; } [data-theme="light"] .tpc6t { color: #EF4444; }
[data-theme="light"] .tpc7 { background: #06B6D4; } [data-theme="light"] .tpc7t { color: #06B6D4; }

/* Team Matrix & Charts */
.tm-table { width: 100%; border-collapse: collapse; font-size: 11px; }
.tm-table th, .tm-table td { padding: 5px 6px; text-align: center; border-bottom: 1px solid var(--border); }
.tm-table th { font-size: 9px; text-transform: uppercase; letter-spacing: 0.5px; color: var(--text-muted); font-weight: 600; }
.tm-table th:first-child, .tm-table td:first-child { text-align: left; font-weight: 600; }
.tm-table tr:last-child td { border-bottom: none; font-weight: 700; color: var(--neon-cyan); }
.tm-cell.zero { color: var(--text-muted); opacity: 0.4; }
.tm-bar-row { display: flex; align-items: center; gap: 6px; margin-bottom: 3px; }
.tm-bar-label { width: 60px; font-size: 10px; color: var(--text-secondary); text-align: right; flex-shrink: 0; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
.tm-bar-track { flex: 1; height: 18px; background: rgba(255,255,255,0.04); border-radius: 3px; overflow: hidden; }
[data-theme="light"] .tm-bar-track { background: #F1F5F9; }
.tm-bar-fill { height: 100%; border-radius: 3px; display: flex; align-items: center; padding: 0 5px; font-size: 9px; font-weight: 600; color: #fff; min-width: fit-content; transition: width 0.4s; }
.tm-bar-value { width: 38px; font-family: var(--font-mono); font-size: 10px; color: var(--text-secondary); text-align: right; flex-shrink: 0; }
.tm-stacked { display: flex; height: 18px; border-radius: 3px; overflow: hidden; }
.tm-stacked-seg { height: 100%; min-width: 2px; transition: width 0.4s; }
.tm-legend { display: flex; flex-wrap: wrap; gap: 6px; margin-top: 6px; }
.tm-legend-item { display: flex; align-items: center; gap: 3px; font-size: 9px; color: var(--text-secondary); }
.tm-legend-dot { width: 7px; height: 7px; border-radius: 2px; flex-shrink: 0; }
.tm-group { margin-bottom: 8px; }
.tm-group-title { font-weight: 600; font-size: 11px; margin-bottom: 3px; }
.tm-period-bar { display: flex; gap: 4px; flex-wrap: wrap; }
.tm-tl-row { display: flex; align-items: center; gap: 6px; margin-bottom: 2px; }
.tm-tl-date { width: 65px; font-size: 9px; color: var(--text-muted); text-align: right; flex-shrink: 0; }
.tm-tl-total { width: 36px; font-family: var(--font-mono); font-size: 9px; color: var(--text-secondary); text-align: right; flex-shrink: 0; }

/* Team Filter Bar */
.tm-filter-bar { display: flex; gap: 6px; align-items: center; flex-wrap: wrap; margin-top: 10px; }
.tm-filter-select { padding: 5px 8px; border: 1px solid var(--border); border-radius: var(--radius-sm); background: rgba(16,17,24,0.88); color: #E2E8F0; font-family: var(--font); font-size: 11px; outline: none; min-width: 90px; max-width: 150px; cursor: pointer; appearance: none; background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='10' height='6'%3E%3Cpath d='M0 0l5 6 5-6z' fill='%23908B83'/%3E%3C/svg%3E"); background-repeat: no-repeat; background-position: right 6px center; padding-right: 22px; }
.tm-filter-select option { background: #1A1C26; color: #E8E4DF; }
[data-theme="light"] .tm-filter-select { background-color: var(--surface-solid); color: var(--text); background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='10' height='6'%3E%3Cpath d='M0 0l5 6 5-6z' fill='%23908B83'/%3E%3C/svg%3E"); }
[data-theme="light"] .tm-filter-select option { background: #fff; color: #1E293B; }
.tm-filter-select:focus { border-color: rgba(201,169,98,0.25); }
.tm-date-input { padding: 5px 8px; border: 1px solid var(--border); border-radius: var(--radius-sm); background: rgba(16,17,24,0.88); color: #E2E8F0; font-family: var(--font-mono); font-size: 11px; outline: none; width: 120px; }
.tm-date-input::-webkit-calendar-picker-indicator { filter: invert(0.7); }
[data-theme="light"] .tm-date-input { background-color: var(--surface-solid); color: var(--text); }
[data-theme="light"] .tm-date-input::-webkit-calendar-picker-indicator { filter: none; }
.tm-date-input:focus { border-color: rgba(201,169,98,0.25); }
.tm-filter-label { font-size: 10px; color: var(--text-muted); }
.tm-export-btn { padding: 5px 12px; border: 1px solid var(--border); border-radius: var(--radius-sm); background: rgba(52,211,153,0.08); color: var(--neon-green); font-size: 11px; font-weight: 600; cursor: pointer; transition: all var(--transition); }
.tm-export-btn:hover { background: rgba(52,211,153,0.15); border-color: rgba(110,196,158,0.25); }
[data-theme="light"] .tm-export-btn { background: rgba(22,163,74,0.06); color: #16A34A; }
[data-theme="light"] .tm-export-btn:hover { background: rgba(22,163,74,0.12); }

/* Attendance Grid */
.tm-att { width: 100%; border-collapse: collapse; font-size: 10px; }
.tm-att th, .tm-att td { padding: 4px 5px; text-align: center; border-bottom: 1px solid var(--border); }
.tm-att th { font-size: 8px; text-transform: uppercase; letter-spacing: 0.5px; color: var(--text-muted); font-weight: 600; position: sticky; top: 0; background: var(--surface); z-index: 1; }
.tm-att th:first-child, .tm-att td:first-child { text-align: left; font-weight: 600; position: sticky; left: 0; background: var(--surface); z-index: 2; }
.tm-att th:first-child { z-index: 3; }
.tm-att td.h0 { color: var(--text-muted); opacity: 0.3; }
.tm-att td.h-low { color: var(--text-secondary); }
.tm-att td.h-med { color: var(--neon-cyan); font-weight: 600; }
.tm-att td.h-high { color: var(--neon-green); font-weight: 700; }
[data-theme="light"] .tm-att td.h-med { color: #2563EB; }
[data-theme="light"] .tm-att td.h-high { color: #16A34A; }
.tm-att td.weekend { background: rgba(255,255,255,0.02); }
[data-theme="light"] .tm-att td.weekend { background: rgba(0,0,0,0.02); }
.tm-att .total-row td { font-weight: 700; border-top: 2px solid var(--border); color: var(--neon-cyan); }
[data-theme="light"] .tm-att .total-row td { color: #2563EB; }
.tm-att .total-col { font-weight: 700; color: var(--neon-cyan); border-left: 2px solid var(--border); }
[data-theme="light"] .tm-att .total-col { color: #2563EB; }
.tm-att-scroll { overflow-x: auto; max-height: 500px; overflow-y: auto; }

/* Full-width card */
.team-dash-full { margin-top: 10px; }

/* Team Dashboard 2-Column Grid */
.team-dash-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 10px; }
@media (max-width: 900px) { .team-dash-grid { grid-template-columns: 1fr; gap: 8px; } }

/* Compact card variant */
.card-compact { padding: 14px 16px; }
.card-compact .card-title { margin-bottom: 8px; font-size: 11px; cursor: pointer; user-select: none; display: flex; align-items: center; gap: 6px; }
.card-compact .card-title::before { content: '▾'; font-size: 9px; color: var(--text-muted); transition: transform 0.2s; }
.card-compact.collapsed .card-title::before { transform: rotate(-90deg); }
.card-compact .card-body { overflow: hidden; transition: max-height 0.3s ease, opacity 0.2s; max-height: 2000px; opacity: 1; }
.card-compact.collapsed .card-body { max-height: 0; opacity: 0; padding: 0; }

/* Team KPI Strip (inline badges) */
.tm-kpi-strip { display: flex; gap: 10px; flex-wrap: wrap; align-items: center; margin-left: auto; }
.tm-kpi { font-size: 10px; color: var(--text-secondary); white-space: nowrap; }
.tm-kpi strong { font-family: var(--font-mono); font-size: 12px; color: var(--neon-cyan); margin-right: 2px; }
[data-theme="light"] .tm-kpi strong { color: #2563EB; }

/* ============================================================
   MANAGE VIEW: 3-column grid
   ============================================================ */
.manage-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 14px; }
@media (max-width: 900px) { .manage-grid { grid-template-columns: 1fr 1fr; } }
@media (max-width: 550px) { .manage-grid { grid-template-columns: 1fr; } }

/* ============================================================
   RESPONSIVE ENTRIES: Card-View auf Mobile
   ============================================================ */
@media (max-width: 700px) {
    .entries-table thead { display: none; }
    .entries-table, .entries-table tbody, .entries-table tr, .entries-table td {
        display: block; width: 100%;
    }
    .entries-table tr {
        padding: 12px; margin-bottom: 8px;
        border: 1px solid var(--border); border-radius: var(--radius);
        background: var(--surface); position: relative;
    }
    .entries-table tr:hover { transform: none; }
    .entries-table td { padding: 2px 0; border: none; font-size: 13px; }
    .entries-table td:first-child { font-weight: 700; font-size: 14px; margin-bottom: 4px; }
    .entries-table .col-duration { display: inline; font-size: 16px; }
    .entries-table .col-time { display: inline; }
    .entries-table .col-actions { position: absolute; top: 12px; right: 12px; }
    .entries-table td[style*="max-width"] { white-space: normal !important; max-width: none !important; }
}

@media (max-width: 600px) {
    .tm-table { font-size: 10px; }
    .tm-table th, .tm-table td { padding: 4px 3px; }
    .tm-bar-label { width: 50px; font-size: 9px; }
}

/* ============================================================
   DAILY GOAL PROGRESS
   ============================================================ */
.daily-goal {
    margin-top: 16px; padding: 16px 18px;
    border: 1px solid var(--border); border-radius: var(--radius);
    background: rgba(0,0,0,0.12); position: relative; overflow: hidden;
}
[data-theme="light"] .daily-goal { background: var(--surface-solid); box-shadow: var(--shadow); }
.daily-goal-header {
    display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;
}
.daily-goal-label {
    font-family: var(--font-display); font-size: 10px; font-weight: 700;
    letter-spacing: 1.2px; text-transform: uppercase; color: var(--text-muted);
}
.daily-goal-value {
    font-family: var(--font-mono); font-size: 13px; font-weight: 600; color: var(--text-secondary);
}
.daily-goal-bar {
    height: 8px; border-radius: 4px; background: rgba(0,0,0,0.2);
    overflow: hidden; position: relative;
}
[data-theme="light"] .daily-goal-bar { background: #E2E8F0; }
.daily-goal-fill {
    height: 100%; border-radius: 4px;
    background: linear-gradient(90deg, var(--neon-cyan), var(--neon-green));
    transition: width 0.8s cubic-bezier(0.22, 1, 0.36, 1);
    position: relative;
}
.daily-goal-fill.over {
    background: linear-gradient(90deg, var(--neon-green), var(--neon-yellow));
}
.daily-goal-fill::after {
    content: ''; position: absolute; right: 0; top: -2px; bottom: -2px; width: 3px;
    background: white; border-radius: 2px; box-shadow: 0 0 8px rgba(255,255,255,0.4);
}
.daily-goal-marker {
    position: absolute; top: -3px; bottom: -3px; width: 2px;
    background: var(--text-muted); opacity: 0.4;
}

/* ============================================================
   FLOATING ACTION BUTTON
   ============================================================ */
.fab {
    position: fixed; bottom: 24px; right: 24px; z-index: 150;
    width: 56px; height: 56px; border-radius: 50%;
    background: linear-gradient(135deg, #C9A962, #A68B42);
    color: white; border: none; cursor: pointer;
    font-size: 24px; font-weight: 300;
    display: flex; align-items: center; justify-content: center;
    box-shadow: 0 4px 20px rgba(201,169,98,0.25), 0 0 40px rgba(201,169,98,0.08);
    transition: all var(--transition);
}
.fab:hover { transform: scale(1.1) rotate(90deg); box-shadow: 0 6px 30px rgba(201,169,98,0.30); }
.fab:active { transform: scale(0.95); }
[data-theme="light"] .fab {
    background: linear-gradient(135deg, #2563EB, #3B82F6);
    box-shadow: 0 4px 20px rgba(37,99,235,0.3);
}
@media (max-width: 640px) { .fab { bottom: 80px; width: 50px; height: 50px; font-size: 22px; } }

/* ============================================================
   CONFETTI CELEBRATION
   ============================================================ */
.confetti-container {
    position: fixed; inset: 0; z-index: 10000; pointer-events: none;
    overflow: hidden;
}
.confetti-piece {
    position: absolute; width: 8px; height: 8px;
    top: -10px; animation: confettiFall 3s ease-in forwards;
}
@keyframes confettiFall {
    0%   { transform: translateY(0) rotate(0deg) scale(1); opacity: 1; }
    80%  { opacity: 1; }
    100% { transform: translateY(100vh) rotate(720deg) scale(0.3); opacity: 0; }
}

/* ============================================================
   KEYBOARD SHORTCUTS OVERLAY
   ============================================================ */
.kbd-overlay {
    position: fixed; inset: 0; z-index: 1000;
    background: rgba(0,0,0,0.7); backdrop-filter: blur(12px);
    display: none; align-items: center; justify-content: center;
    padding: 20px;
}
.kbd-overlay.open { display: flex; }
.kbd-panel {
    background: var(--surface-solid); border: 1px solid var(--border);
    border-radius: var(--radius-xl); padding: 36px;
    max-width: 480px; width: 100%;
    animation: modalIn 0.3s cubic-bezier(0.22, 1, 0.36, 1);
}
.kbd-title {
    font-family: var(--font-display); font-size: 18px; font-weight: 700;
    color: var(--text); margin-bottom: 20px; text-align: center;
}
.kbd-grid { display: grid; grid-template-columns: auto 1fr; gap: 10px 20px; align-items: center; }
.kbd-key {
    display: inline-flex; align-items: center; justify-content: center;
    min-width: 36px; height: 32px; padding: 0 10px;
    border-radius: 6px; background: rgba(0,0,0,0.15);
    border: 1px solid var(--border);
    font-family: var(--font-mono); font-size: 12px; font-weight: 600;
    color: var(--neon-cyan);
}
[data-theme="light"] .kbd-key { background: #F1F5F9; color: #2563EB; }
.kbd-desc { font-size: 13px; color: var(--text-secondary); }

/* ============================================================
   ENTRY ROW BADGES (category tags in table)
   ============================================================ */
.entry-badge {
    display: inline-block; padding: 2px 8px; border-radius: 12px;
    font-size: 11px; font-weight: 600; letter-spacing: 0.01em;
    background: rgba(201,169,98,0.07); color: var(--neon-cyan);
    border: 1px solid rgba(201,169,98,0.08);
    max-width: 120px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;
}
.entry-badge.sh { background: rgba(201,169,98,0.07); color: var(--neon-cyan); border-color: rgba(201,169,98,0.08); }
.entry-badge.pr { background: rgba(155,142,196,0.07); color: var(--neon-violet); border-color: rgba(155,142,196,0.10); }
.entry-badge.ta { background: rgba(52,211,153,0.08); color: var(--neon-green); border-color: rgba(52,211,153,0.12); }
[data-theme="light"] .entry-badge.sh { background: #EFF6FF; color: #2563EB; border-color: #BFDBFE; }
[data-theme="light"] .entry-badge.pr { background: #F5F3FF; color: #7C3AED; border-color: #DDD6FE; }
[data-theme="light"] .entry-badge.ta { background: #ECFDF5; color: #059669; border-color: #A7F3D0; }

/* ============================================================
   ENHANCED TABLE ROWS
   ============================================================ */
.entries-table tbody tr {
    transition: all 0.2s ease;
}
.entries-table tbody tr:hover td {
    background: var(--surface-hover);
}
.entries-table tbody tr:hover {
    transform: translateX(2px);
}

/* ============================================================
   ENHANCED TOAST with auto-progress & stacking
   ============================================================ */
.toast {
    padding: 14px 22px; border-radius: var(--radius);
    background: var(--surface-elevated); border: 1px solid var(--border);
    color: var(--text); font-size: 13px;
    box-shadow: 0 8px 40px rgba(0,0,0,0.3), 0 0 0 1px rgba(201,169,98,0.04);
    animation: toastSlideIn 0.4s cubic-bezier(0.22, 1, 0.36, 1);
    max-width: 380px;
    display: flex; align-items: center; gap: 10px;
    backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px);
    position: relative; overflow: hidden;
}

/* ============================================================
   ENHANCED MODAL with better glass
   ============================================================ */
.modal {
    background: var(--surface-elevated); border: 1px solid var(--border);
    border-radius: var(--radius-xl); padding: 36px;
    width: 100%; max-width: 480px;
    box-shadow: 0 24px 80px rgba(0,0,0,0.4), 0 0 0 1px rgba(201,169,98,0.025);
    animation: modalIn 0.35s cubic-bezier(0.22, 1, 0.36, 1);
    backdrop-filter: blur(30px); -webkit-backdrop-filter: blur(30px);
}

/* ============================================================
   SELECTION & FOCUS RING
   ============================================================ */
::selection { background: rgba(201,169,98,0.18); color: inherit; }
[data-theme="light"] ::selection { background: rgba(37,99,235,0.15); }
:focus-visible { outline: 2px solid var(--neon-cyan); outline-offset: 2px; }

/* ============================================================
   SCROLLBAR STYLING
   ============================================================ */
::-webkit-scrollbar { width: 6px; height: 6px; }
::-webkit-scrollbar-track { background: transparent; }
::-webkit-scrollbar-thumb { background: rgba(201,169,98,0.12); border-radius: 3px; }
::-webkit-scrollbar-thumb:hover { background: rgba(201,169,98,0.18); }
[data-theme="light"] ::-webkit-scrollbar-thumb { background: rgba(0,0,0,0.12); }
[data-theme="light"] ::-webkit-scrollbar-thumb:hover { background: rgba(0,0,0,0.2); }

/* ============================================================
   SKELETON LOADING
   ============================================================ */
@keyframes skeletonShimmer {
    0% { background-position: -200% 0; }
    100% { background-position: 200% 0; }
}
.skeleton {
    background: linear-gradient(90deg, var(--surface) 25%, rgba(201,169,98,0.025) 50%, var(--surface) 75%);
    background-size: 200% 100%;
    animation: skeletonShimmer 1.8s ease-in-out infinite;
    border-radius: var(--radius-sm);
}

/* ============================================================
   🎨 PREMIUM UX ENHANCEMENTS
   ============================================================ */

/* --- Animated Timer Outer Ring --- */
.timer-circle::before {
    content: ''; position: absolute; inset: -6px;
    border-radius: 50%;
    background: conic-gradient(from 0deg, transparent 0%, rgba(201,169,98,0.12) 25%, transparent 50%, rgba(167,139,250,0.1) 75%, transparent 100%);
    animation: timerRingSpin 8s linear infinite;
    opacity: 0;
    transition: opacity 0.6s ease;
}
.timer-circle.running::before { opacity: 1; }
@keyframes timerRingSpin { to { transform: rotate(360deg); } }
[data-theme="light"] .timer-circle::before {
    background: conic-gradient(from 0deg, transparent 0%, rgba(37,99,235,0.12) 25%, transparent 50%, rgba(124,58,237,0.08) 75%, transparent 100%);
}

/* --- Enhanced Timer Glow when running --- */
.timer-circle.running {
    filter: var(--timer-glow) drop-shadow(0 0 30px rgba(201,169,98,0.12));
}
.timer-circle.running .progress {
    filter: drop-shadow(0 0 6px rgba(201,169,98,0.4));
}

/* --- KPI Cards with gradient borders --- */
.kpi-card {
    position: relative;
}
.kpi-card::before {
    content: ''; position: absolute; top: 0; left: 0; right: 0; height: 3px;
    background: linear-gradient(90deg, transparent 5%, var(--neon-cyan) 30%, var(--neon-violet) 70%, transparent 95%);
    opacity: 0.5; border-radius: 3px 3px 0 0;
}
.kpi-card:nth-child(2)::before {
    background: linear-gradient(90deg, transparent 5%, var(--neon-magenta) 30%, var(--neon-violet) 70%, transparent 95%);
}
.kpi-card:nth-child(3)::before {
    background: linear-gradient(90deg, transparent 5%, var(--neon-green) 30%, var(--neon-cyan) 70%, transparent 95%);
}

/* --- KPI Value Transition --- */
.kpi-value {
    display: inline-block;
    transition: transform 0.5s cubic-bezier(0.22, 1, 0.36, 1), opacity 0.3s ease;
}

/* --- Enhanced Task Slot states with glow --- */
.task-slot.active {
    box-shadow: 0 0 25px rgba(201,169,98,0.07), 0 4px 20px rgba(201,169,98,0.04), inset 0 1px 0 rgba(201,169,98,0.07);
}
.task-slot.active::before {
    content: ''; position: absolute; top: 0; bottom: 0; left: 0; width: 3px;
    background: linear-gradient(180deg, var(--neon-cyan), var(--neon-violet));
    border-radius: 3px 0 0 3px;
    box-shadow: 0 0 12px rgba(201,169,98,0.25);
}
.task-slot.paused::before {
    content: ''; position: absolute; top: 0; bottom: 0; left: 0; width: 3px;
    background: linear-gradient(180deg, var(--neon-yellow), var(--neon-orange));
    border-radius: 3px 0 0 3px;
}

/* --- Pulse animation for running elapsed --- */
.task-slot.active .ts-elapsed {
    animation: elapsedPulse 2s ease-in-out infinite;
}
@keyframes elapsedPulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.7; }
}

/* --- Better Button Micro-Interactions --- */
.btn {
    position: relative;
    overflow: hidden;
}
.btn::after {
    content: ''; position: absolute; inset: 0;
    background: radial-gradient(circle at var(--x, 50%) var(--y, 50%), rgba(201,169,98,0.08) 0%, transparent 60%);
    opacity: 0; transition: opacity 0.3s ease;
    pointer-events: none;
}
.btn:hover::after { opacity: 1; }

/* --- Entry Badge Hover Lift --- */
.entry-badge {
    transition: all 0.2s ease;
    cursor: default;
}
.entry-badge:hover {
    transform: translateY(-1px);
    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
}

/* --- Enhanced Heatmap Cells --- */
.hm-cell {
    transition: all 0.2s ease !important;
}
.hm-cell:hover {
    transform: scale(1.1);
    z-index: 1;
    box-shadow: 0 2px 12px rgba(0,0,0,0.2);
}

/* --- Bar Chart Hover Effect --- */
.bar-row:hover .bar-fill {
    filter: brightness(1.15);
    box-shadow: 0 0 12px rgba(201,169,98,0.12);
}
.bar-row:hover .bar-label {
    color: var(--text);
}

/* --- Timeline Row Hover --- */
.tl-row:hover {
    background: rgba(201,169,98,0.025);
    border-radius: 4px;
}
.tl-row:hover .tl-segment {
    filter: brightness(1.1);
}

/* --- Better Period Button Transition --- */
.period-btn {
    transition: all 0.25s cubic-bezier(0.22, 1, 0.36, 1);
}
.period-btn.active {
    transform: scale(1.05);
    box-shadow: 0 2px 12px rgba(201,169,98,0.12);
}
[data-theme="light"] .period-btn.active {
    box-shadow: 0 2px 12px rgba(37,99,235,0.12);
}

/* --- Enhanced Manage Item Interactions --- */
.manage-item {
    transition: all 0.2s ease;
    border-radius: var(--radius-sm);
}
.manage-item:hover {
    transform: translateX(4px);
    background: var(--surface-hover);
}

/* --- Daily Goal Enhanced Styles --- */
.daily-goal {
    transition: all 0.3s ease;
}
.daily-goal:hover {
    border-color: var(--border-hover);
}
.daily-goal-fill {
    position: relative;
}
.daily-goal-fill::before {
    content: '';
    position: absolute; inset: 0;
    background: linear-gradient(90deg, transparent 60%, rgba(255,255,255,0.15) 80%, transparent 100%);
    background-size: 200% 100%;
    animation: goalShimmer 2s ease-in-out infinite;
}
@keyframes goalShimmer {
    0% { background-position: -200% 0; }
    100% { background-position: 200% 0; }
}

/* --- Smooth Tab Transitions --- */
.nav-tab {
    transition: color 0.2s ease, transform 0.2s ease;
}
.nav-tab:hover {
    transform: translateY(-1px);
}
.nav-tab.active {
    transform: translateY(0);
}

/* --- Better Modal Backdrop --- */
.modal-overlay {
    transition: background 0.3s ease;
}
.modal-overlay.open {
    animation: backdropIn 0.3s ease;
}
@keyframes backdropIn {
    from { background: rgba(0,0,0,0); backdrop-filter: blur(0px); }
    to { background: rgba(0,0,0,0.55); backdrop-filter: blur(8px); }
}

/* --- Quick Chip Enhanced --- */
.quick-chip {
    transition: all 0.25s cubic-bezier(0.22, 1, 0.36, 1);
}
.quick-chip:hover {
    transform: translateY(-2px) scale(1.03);
    box-shadow: 0 4px 16px rgba(201,169,98,0.08);
}
.quick-chip:active {
    transform: translateY(0) scale(0.97);
}

/* --- FAB Enhanced --- */
.fab {
    transition: all 0.3s cubic-bezier(0.22, 1, 0.36, 1);
    animation: fabEntrance 0.5s cubic-bezier(0.22, 1, 0.36, 1);
}
@keyframes fabEntrance {
    from { transform: scale(0) rotate(-180deg); opacity: 0; }
    to { transform: scale(1) rotate(0deg); opacity: 1; }
}
.fab::before {
    content: ''; position: absolute; inset: -3px;
    border-radius: 50%;
    background: linear-gradient(135deg, var(--neon-cyan), var(--neon-violet));
    z-index: -1; opacity: 0;
    transition: opacity 0.3s ease;
    filter: blur(8px);
}
.fab:hover::before { opacity: 0.4; }

/* --- Better Today-Total --- */
.today-total {
    transition: all 0.3s ease;
    position: relative;
    overflow: hidden;
}
.today-total::before {
    content: ''; position: absolute; inset: 0;
    background: radial-gradient(ellipse at 50% 0%, rgba(52,211,153,0.06) 0%, transparent 70%);
    pointer-events: none;
}

/* --- Enhanced Mobile Touch --- */
@media (max-width: 640px) {
    .btn { min-height: 44px; padding: 10px 16px; }
    .timer-btn { width: 58px; height: 58px; font-size: 20px; }
    .ts-play-btn, .ts-stop-btn { width: 38px; height: 38px; font-size: 15px; }
    .period-btn { padding: 10px 18px; font-size: 12px; }
    .entry-badge { font-size: 10px; padding: 3px 8px; }
    .bnav-item { padding: 8px 14px; }
    .kpi-value { font-size: 28px; }
    .task-slot { padding: 16px; padding-left: 20px; }
}

/* --- Better Responsive Dashboard --- */
@media (max-width: 768px) {
    .kpi-strip { grid-template-columns: 1fr 1fr; gap: 10px; }
    .kpi-card { padding: 16px; }
    .kpi-value { font-size: 28px; }
}
@media (max-width: 640px) {
    .kpi-strip { grid-template-columns: 1fr; }
    .kpi-card { padding: 18px; display: flex; align-items: center; gap: 14px; text-align: left; }
    .kpi-card::before { display: none; }
    .kpi-card::after { display: none; }
    .kpi-value { font-size: 32px; }
    .kpi-label { margin-top: 0; }
}

.lang-toggle { padding: 4px 8px; border: 1px solid var(--border); border-radius: var(--radius-sm); background: transparent; color: var(--text-muted); font-family: var(--font-display); font-size: 10px; font-weight: 700; letter-spacing: 1px; cursor: pointer; transition: all var(--transition); text-transform: uppercase; }
.lang-toggle:hover { color: var(--neon-cyan); border-color: rgba(201,169,98,0.25); }
.lang-toggle .lang-active { color: var(--neon-cyan); }
[data-theme="light"] .lang-toggle:hover { color: #2563EB; border-color: #93C5FD; }
[data-theme="light"] .lang-toggle .lang-active { color: #2563EB; }

/* --- Print Optimizations --- */
@media print {
    body::before, body::after, .top-bar, .nav-bar, .bottom-nav, .fab,
    .timer-controls, .entry-actions, .kbd-overlay, .confetti-container,
    .toast-container { display: none !important; }
    .card { break-inside: avoid; box-shadow: none; border: 1px solid #ddd; }
    .entry-badge { border: 1px solid #999; background: #f5f5f5 !important; color: #333 !important; }
}

</style>
</head>
<body>

<!-- ============================================================
     TOP BAR
     ============================================================ -->
<div class="top-bar">
    <div class="app-logo">
        <span class="logo-icon"><svg viewBox="0 0 24 24"><circle cx="12" cy="13" r="8"/><line x1="12" y1="9" x2="12" y2="13"/><line x1="12" y1="13" x2="15" y2="15"/><line x1="12" y1="3" x2="12" y2="5"/><line x1="10" y1="2" x2="14" y2="2"/></svg></span>
        <span>Zeiterfassung</span>
        <span style="font-size:10px; opacity:0.3; margin-left:8px; font-family:var(--font-mono); font-weight:400;">v3.5</span>
    </div>
    <div class="top-bar-actions">
        <button class="btn" onclick="headerFolderAction()" id="headerSyncBtn" data-t-title="title.folderConnect" title="Ordner verbinden">
            <span class="btn-icon"><svg viewBox="0 0 24 24"><path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"/></svg></span>
        </button>
        <button class="lang-toggle" onclick="toggleLang()" id="langBtn" data-t-title="title.langToggle">
            <span id="langLabel">DE | FR</span>
        </button>
        <button class="btn" onclick="toggleTheme()" id="themeBtn" data-t-title="title.themeToggle">
            <span class="btn-icon" id="themeIcon"><svg viewBox="0 0 24 24"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"/></svg></span>
        </button>
        <button class="btn ham-hide" onclick="exportBackup()" data-t-title="title.backup">
            <span class="btn-icon"><svg viewBox="0 0 24 24"><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"/><polyline points="17 21 17 13 7 13 7 21"/><polyline points="7 3 7 8 15 8"/></svg></span>
            <span class="btn-label" data-t="btn.backup2">Backup</span>
        </button>
        <button class="btn ham-hide" onclick="dsbRestore()" data-t-title="title.dsbRestore"><span class="btn-icon"><svg viewBox="0 0 24 24"><path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"/></svg></span><span class="btn-label"> Auto-Backup</span></button>
        <button class="btn ham-hide" onclick="dsbShowStatus()" data-t-title="title.dsbStatus"><span class="btn-icon"><svg viewBox="0 0 24 24"><line x1="18" y1="20" x2="18" y2="10"/><line x1="12" y1="20" x2="12" y2="4"/><line x1="6" y1="20" x2="6" y2="14"/></svg></span><span class="btn-label"> Status</span></button>
        <button class="btn ham-hide" onclick="exportCSV()" data-t-title="title.csvExport">
            <span class="btn-icon"><svg viewBox="0 0 24 24"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg></span>
            <span class="btn-label" data-t="btn.export">Export</span>
        </button>
        <button class="btn ham-hide" onclick="document.getElementById('kbdOverlay').classList.add('open')" data-t-title="title.kbdShortcuts">
            <span class="btn-icon"><svg viewBox="0 0 24 24"><rect x="2" y="4" width="20" height="16" rx="2"/><line x1="6" y1="8" x2="6" y2="8"/><line x1="10" y1="8" x2="10" y2="8"/><line x1="14" y1="8" x2="14" y2="8"/><line x1="18" y1="8" x2="18" y2="8"/><line x1="6" y1="12" x2="6" y2="12"/><line x1="10" y1="12" x2="10" y2="12"/><line x1="14" y1="12" x2="14" y2="12"/><line x1="18" y1="12" x2="18" y2="12"/><line x1="8" y1="16" x2="16" y2="16"/></svg></span>
        </button>
        <button class="ham-btn" onclick="toggleHamMenu(event)" aria-label="Menü">
            <svg viewBox="0 0 24 24"><line x1="4" y1="6" x2="20" y2="6"/><line x1="4" y1="12" x2="20" y2="12"/><line x1="4" y1="18" x2="20" y2="18"/></svg>
        </button>
        <div class="ham-menu" id="hamMenu">
            <button class="btn" onclick="exportBackup(); closeHamMenu();">
                <span class="btn-icon"><svg viewBox="0 0 24 24"><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"/><polyline points="17 21 17 13 7 13 7 21"/><polyline points="7 3 7 8 15 8"/></svg></span>
                <span class="ham-label" data-t="btn.backup2">Backup</span>
            </button>
            <button class="btn" onclick="dsbRestore(); closeHamMenu();">
                <span class="btn-icon"><svg viewBox="0 0 24 24"><path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"/></svg></span>
                <span class="ham-label">Auto-Backup</span>
            </button>
            <button class="btn" onclick="dsbShowStatus(); closeHamMenu();">
                <span class="btn-icon"><svg viewBox="0 0 24 24"><line x1="18" y1="20" x2="18" y2="10"/><line x1="12" y1="20" x2="12" y2="4"/><line x1="6" y1="20" x2="6" y2="14"/></svg></span>
                <span class="ham-label">Backup-Status</span>
            </button>
            <button class="btn" onclick="exportCSV(); closeHamMenu();">
                <span class="btn-icon"><svg viewBox="0 0 24 24"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg></span>
                <span class="ham-label" data-t="btn.export">Export CSV</span>
            </button>
            <button class="btn" onclick="document.getElementById('kbdOverlay').classList.add('open'); closeHamMenu();">
                <span class="btn-icon"><svg viewBox="0 0 24 24"><rect x="2" y="4" width="20" height="16" rx="2"/><line x1="6" y1="8" x2="6" y2="8"/><line x1="10" y1="8" x2="10" y2="8"/><line x1="14" y1="8" x2="14" y2="8"/><line x1="18" y1="8" x2="18" y2="8"/><line x1="8" y1="16" x2="16" y2="16"/></svg></span>
                <span class="ham-label">Tastenkürzel</span>
            </button>
        </div>
    </div>
</div>

<!-- ============================================================
     NAVIGATION TABS
     ============================================================ -->
<div class="nav-bar" id="navBar">
    <div class="nav-tab active" onclick="switchView('timer')"><span class="nav-icon"><svg viewBox="0 0 24 24"><circle cx="12" cy="13" r="8"/><line x1="12" y1="9" x2="12" y2="13"/><line x1="12" y1="13" x2="15" y2="15"/><line x1="12" y1="3" x2="12" y2="5"/><line x1="10" y1="2" x2="14" y2="2"/></svg></span><span data-t="nav.timer">Timer</span><span class="timer-dot" id="navTimerDot"></span></div>
    <div class="nav-tab" onclick="switchView('entries')"><span class="nav-icon"><svg viewBox="0 0 24 24"><line x1="8" y1="6" x2="19" y2="6"/><line x1="8" y1="12" x2="19" y2="12"/><line x1="8" y1="18" x2="19" y2="18"/><circle cx="5" cy="6" r="1" fill="currentColor" stroke="none"/><circle cx="5" cy="12" r="1" fill="currentColor" stroke="none"/><circle cx="5" cy="18" r="1" fill="currentColor" stroke="none"/></svg></span><span data-t="nav.entries">Einträge</span></div>
    <div class="nav-tab" onclick="switchView('dashboard')"><span class="nav-icon"><svg viewBox="0 0 24 24"><rect x="3" y="3" width="7" height="7" rx="1.5"/><rect x="14" y="3" width="7" height="7" rx="1.5"/><rect x="3" y="14" width="7" height="7" rx="1.5"/><rect x="14" y="14" width="7" height="7" rx="1.5"/></svg></span><span data-t="nav.dashboard">Dashboard</span></div>
    <div class="nav-tab" onclick="switchView('manage')"><span class="nav-icon"><svg viewBox="0 0 24 24"><line x1="4" y1="8" x2="20" y2="8"/><line x1="4" y1="16" x2="20" y2="16"/><circle cx="9" cy="8" r="2.5" fill="var(--bg, #0A0B0F)"/><circle cx="15" cy="16" r="2.5" fill="var(--bg, #0A0B0F)"/></svg></span><span data-t="nav.manage">Verwaltung</span></div>
    <div class="nav-tab" onclick="switchView('team')"><span class="nav-icon"><svg viewBox="0 0 24 24"><circle cx="9" cy="7" r="3"/><path d="M2 21v-2a5 5 0 0 1 5-5h4a5 5 0 0 1 5 5v2"/><circle cx="17" cy="9" r="2.5"/><path d="M17 14.5a4 4 0 0 1 4 4V21"/></svg></span><span data-t="nav.team">Team</span></div>
    <div class="nav-indicator" id="navIndicator"></div>
</div>

<!-- Mobile Bottom Navigation -->
<div class="bottom-nav" id="bottomNav">
    <div class="bnav-item active" onclick="switchView('timer')"><span class="bnav-icon"><svg viewBox="0 0 24 24"><circle cx="12" cy="13" r="8"/><line x1="12" y1="9" x2="12" y2="13"/><line x1="12" y1="13" x2="15" y2="15"/><line x1="12" y1="3" x2="12" y2="5"/><line x1="10" y1="2" x2="14" y2="2"/></svg></span><span data-t="bnav.timer">Timer</span></div>
    <div class="bnav-item" onclick="switchView('entries')"><span class="bnav-icon"><svg viewBox="0 0 24 24"><line x1="8" y1="6" x2="19" y2="6"/><line x1="8" y1="12" x2="19" y2="12"/><line x1="8" y1="18" x2="19" y2="18"/><circle cx="5" cy="6" r="1" fill="currentColor" stroke="none"/><circle cx="5" cy="12" r="1" fill="currentColor" stroke="none"/><circle cx="5" cy="18" r="1" fill="currentColor" stroke="none"/></svg></span><span data-t="bnav.entries">Einträge</span></div>
    <div class="bnav-item" onclick="switchView('dashboard')"><span class="bnav-icon"><svg viewBox="0 0 24 24"><rect x="3" y="3" width="7" height="7" rx="1.5"/><rect x="14" y="3" width="7" height="7" rx="1.5"/><rect x="3" y="14" width="7" height="7" rx="1.5"/><rect x="14" y="14" width="7" height="7" rx="1.5"/></svg></span><span data-t="bnav.dashboard">Dashboard</span></div>
    <div class="bnav-item" onclick="switchView('manage')"><span class="bnav-icon"><svg viewBox="0 0 24 24"><line x1="4" y1="8" x2="20" y2="8"/><line x1="4" y1="16" x2="20" y2="16"/><circle cx="9" cy="8" r="2.5" fill="var(--bg, #0A0B0F)"/><circle cx="15" cy="16" r="2.5" fill="var(--bg, #0A0B0F)"/></svg></span><span data-t="bnav.manage">Verwalten</span></div>
    <div class="bnav-item" onclick="switchView('team')"><span class="bnav-icon"><svg viewBox="0 0 24 24"><circle cx="9" cy="7" r="3"/><path d="M2 21v-2a5 5 0 0 1 5-5h4a5 5 0 0 1 5 5v2"/><circle cx="17" cy="9" r="2.5"/><path d="M17 14.5a4 4 0 0 1 4 4V21"/></svg></span><span data-t="bnav.team">Team</span></div>
</div>

<!-- ============================================================
     MAIN CONTENT
     ============================================================ -->
<div class="main-content">

    <!-- ========== TIMER VIEW ========== -->
    <div class="view active" id="view-timer">
        <div class="timer-layout">
            <div class="card">
                <div class="card-title" data-t="tasks">Tasks</div>
                <div class="quick-start" id="quickStart" style="display:none;"></div>
                <div class="task-slot-list" id="taskSlotList"></div>
                <div class="task-slot-add" onclick="addTaskSlot()" data-t="timer.addTask">+ Neuen Task hinzufügen</div>

                <!-- Manueller Eintrag / Saisie manuelle -->
                <div style="margin-top: 16px; padding-top: 14px; border-top: 1px solid var(--border);">
                    <div class="card-title" style="margin-bottom: 10px;" data-t="manual.title">Manuell eintragen</div>
                    <div class="ts-fields" style="margin-bottom: 8px;">
                        <div class="field-with-add">
                            <select class="form-select" id="manualStakeholder"><option value="" data-t="ph.stakeholder">Stakeholder</option></select>
                            <button class="inline-add-btn" onclick="inlineAddForManual('stakeholder','manualStakeholder')" data-t-title="title.newSh">+</button>
                        </div>
                        <div class="field-with-add">
                            <select class="form-select" id="manualProjekt"><option value="" data-t="ph.projekt">Projekt</option></select>
                            <button class="inline-add-btn" onclick="inlineAddForManual('projekt','manualProjekt')" data-t-title="title.newPr">+</button>
                        </div>
                        <div class="field-with-add">
                            <select class="form-select" id="manualTaetigkeit"><option value="" data-t="ph.taetigkeit">Tätigkeit</option></select>
                            <button class="inline-add-btn" onclick="inlineAddForManual('taetigkeit','manualTaetigkeit')" data-t-title="title.newTa">+</button>
                        </div>
                    </div>
                    <div style="margin-bottom: 8px;">
                        <input type="text" class="ts-notiz" id="manualNotiz" placeholder="Notiz (optional)" data-t="ph.notiz" list="notizSuggestions"
                            onfocus="updateNotizDatalist(document.getElementById('manualStakeholder').value, document.getElementById('manualProjekt').value)">
                    </div>
                    <div style="display: flex; gap: 8px; align-items: end; flex-wrap: wrap;">
                        <div class="form-group" style="margin-bottom:0">
                            <label class="form-label" data-t="label.datum">Datum</label>
                            <input type="date" class="form-input" id="manualDate" style="width: 130px;">
                        </div>
                        <div class="form-group" style="margin-bottom:0">
                            <label class="form-label" data-t="label.von">Von</label>
                            <input type="time" class="form-input" id="manualStart" style="width: 100px;">
                        </div>
                        <div class="form-group" style="margin-bottom:0">
                            <label class="form-label" data-t="label.bis">Bis</label>
                            <input type="time" class="form-input" id="manualEnd" style="width: 100px;">
                        </div>
                        <button class="btn btn-primary" onclick="saveManualEntry()" style="margin-bottom:0;">
                            <span class="btn-icon"><svg viewBox="0 0 24 24"><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"/><polyline points="17 21 17 13 7 13 7 21"/><polyline points="7 3 7 8 15 8"/></svg></span> <span data-t="btn.save">Speichern</span>
                        </button>
                    </div>
                </div>
            </div>
            <div class="card" style="display:flex; flex-direction:column; align-items:center; justify-content:center;">
                <div class="timer-circle-wrap">
                    <div class="timer-circle">
                        <svg viewBox="0 0 200 200">
                            <circle class="track" cx="100" cy="100" r="94"/>
                            <circle class="progress" id="timerProgress" cx="100" cy="100" r="94"/>
                        </svg>
                        <div class="timer-display">
                            <div class="timer-time" id="timerDisplay">00:00:00</div>
                            <div class="timer-sub" id="timerLabel" data-t="timer.ready">Bereit</div>
                        </div>
                    </div>
                    <div class="timer-controls">
                        <button class="timer-btn stop" id="btnStopAll" onclick="stopAllTimers()" data-t-title="title.stopAll" disabled>■</button>
                        <button class="timer-btn split" id="btnSplit" onclick="openSplitModal()" data-t-title="title.split" disabled>✂</button>
                    </div>
                    <div class="timer-status idle" id="timerStatus" data-t="timer.startHint">Starte einen Task mit ▶</div>
                    <div class="today-total">
                        <div class="today-total-label" data-t="timer.todayTotal">Heute total</div>
                        <div class="today-total-value" id="todayTotalDisplay">0:00</div>
                    </div>
                    <!-- Daily Goal Progress -->
                    <div class="daily-goal" id="dailyGoalWrap">
                        <div class="daily-goal-header">
                            <div class="daily-goal-label">Tagesziel</div>
                            <div class="daily-goal-value" id="dailyGoalText">0:00 / 8:24</div>
                        </div>
                        <div class="daily-goal-bar">
                            <div class="daily-goal-fill" id="dailyGoalFill" style="width:0%"></div>
                            <div class="daily-goal-marker" style="left:100%"></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- ========== EINTRÄGE VIEW ========== -->
    <div class="view" id="view-entries">
        <div class="card">
            <div class="entries-header">
                <div class="card-title" style="margin-bottom:0;" data-t="entries.title">Erfasste Einträge</div>
                <div class="entries-filters">
                    <div class="filter-row">
                        <input type="date" class="filter-input" id="filterFrom" data-t-title="title.filterVon" onchange="renderEntries()">
                        <span style="color:var(--text-muted); font-size:12px;">bis</span>
                        <input type="date" class="filter-input" id="filterTo" data-t-title="title.filterBis" onchange="renderEntries()">
                        <select class="filter-select" id="filterSh" onchange="renderEntries()" data-t-title="manage.labelSh"><option value="" data-t="all.stakeholder">Alle Stakeholder</option></select>
                        <select class="filter-select" id="filterPr" onchange="renderEntries()" data-t-title="manage.labelPr"><option value="" data-t="all.projekte">Alle Projekte</option></select>
                        <select class="filter-select" id="filterTa" onchange="renderEntries()" data-t-title="manage.labelTa"><option value="" data-t="all.taetigkeiten">Alle Tätigkeiten</option></select>
                        <input type="text" class="filter-text" id="filterNotiz" oninput="onEntryNotizFilter()" placeholder="🔍 Notiz..." data-t="filter.notiz" data-t-title="title.filterNotiz">
                        <button class="btn" onclick="clearFilter()" data-t-title="title.resetFilter">✕ Reset</button>
                    </div>
                </div>
            </div>
            <div class="filter-active-bar" id="entryFilterBar" style="display:none;"></div>
            <div class="entries-summary" id="entriesSummary"></div>
            <div class="table-scroll">
                <table class="entries-table">
                    <thead>
                        <tr>
                            <th data-t="th.datum">Datum</th>
                            <th data-t="th.stakeholder">Stakeholder</th>
                            <th data-t="th.projekt">Projekt</th>
                            <th data-t="th.taetigkeit">Tätigkeit</th>
                            <th data-t="th.von">Von</th>
                            <th data-t="th.bis">Bis</th>
                            <th data-t="th.dauer">Dauer</th>
                            <th data-t="th.notiz">Notiz</th>
                            <th class="col-actions"></th>
                        </tr>
                    </thead>
                    <tbody id="entriesBody"></tbody>
                </table>
            </div>
            <div class="no-entries" id="noEntries" style="display:none;">
                <span class="icon">⏱️</span>
                <span data-t="welcome.noEntries">Noch keine Einträge vorhanden.</span><br>
                <span style="font-size:11px; opacity:0.7; margin-top:6px; display:block;" data-t-html="welcome.hint">Starte einen Timer oder trage Zeit manuell ein.<br>Drücke <strong>Leertaste</strong> für Schnellstart.</span>
            </div>
        </div>
    </div>

    <!-- ========== DASHBOARD VIEW ========== -->
    <div class="view" id="view-dashboard">
        <!-- Perioden-Auswahl -->
        <div class="dash-period" id="dashPeriod">
            <button class="period-btn active" onclick="setDashPeriod('week',this)" data-t="dash.thisWeek">Diese Woche</button>
            <button class="period-btn" onclick="setDashPeriod('month',this)" data-t="dash.thisMonth">Dieser Monat</button>
            <button class="period-btn" onclick="setDashPeriod('year',this)" data-t="dash.thisYear">Dieses Jahr</button>
            <button class="period-btn" onclick="setDashPeriod('all',this)" data-t="dash.all">Gesamt</button>
        </div>
        <!-- Erweiterte Filter -->
        <div class="dash-filters">
            <select class="dash-filter-select" id="dashFilterSh" onchange="renderDashboard()" data-t-title="manage.labelSh"><option value="" data-t="all.stakeholder">Alle Stakeholder</option></select>
            <select class="dash-filter-select" id="dashFilterPr" onchange="renderDashboard()" data-t-title="manage.labelPr"><option value="" data-t="all.projekte">Alle Projekte</option></select>
            <select class="dash-filter-select" id="dashFilterTa" onchange="renderDashboard()" data-t-title="manage.labelTa"><option value="" data-t="all.taetigkeiten">Alle Tätigkeiten</option></select>
            <input type="text" class="dash-search-input" id="dashNotizSearch" placeholder="🔍 Notiz..." data-t="filter.notiz" oninput="onDashNotizFilter()" list="dashNotizList" style="max-width:200px;">
            <button class="dash-search-clear" id="dashFilterClear" onclick="clearDashFilters()" style="display:none;" data-t-title="title.resetDashFilter">✕ Reset</button>
        </div>
        <div class="dash-filter-active" id="dashFilterInfo" style="display:none;"></div>
        <datalist id="dashNotizList"></datalist>

        <!-- Zone A: KPI-Leiste -->
        <div class="kpi-strip">
            <div class="kpi-card">
                <div class="kpi-value" id="kpiToday">00:00</div>
                <div class="kpi-label" data-t="kpi.today">Heute</div>
            </div>
            <div class="kpi-card">
                <div class="kpi-value" id="kpiPresence">00:00</div>
                <div class="kpi-label" data-t="kpi.presence">Anwesenheit</div>
            </div>
            <div class="kpi-card">
                <div class="kpi-value" id="kpiPeriod">00:00</div>
                <div class="kpi-label" id="kpiPeriodLabel" data-t="dash.thisWeek">Diese Woche</div>
            </div>
            <div class="kpi-card">
                <div class="kpi-value" id="kpiEntries">0</div>
                <div class="kpi-label" data-t="kpi.entries">Einträge</div>
            </div>
        </div>

        <!-- Zone B: Heatmap + Tätigkeiten -->
        <div class="dash-mid">
            <div class="card">
                <div class="card-title" data-t="dash.shxpr">Stakeholder × Projekt</div>
                <div class="heatmap-wrap" id="heatmapWrap">
                    <div style="color:var(--text-muted); font-size:12px; padding:10px;" data-t-html="dash.noData">Keine Daten.</div>
                </div>
            </div>
            <div class="card">
                <div class="card-title" data-t="dash.byActivity">Nach Tätigkeit</div>
                <div class="bar-chart" id="chartTaetigkeit"></div>
            </div>
        </div>

        <!-- Zone C: Zeitverlauf -->
        <div class="card">
            <div class="card-title" data-t="dash.timeline">Zeitverlauf</div>
            <div class="timeline-chart" id="timelineChart"></div>
        </div>
    </div>

    <!-- ========== VERWALTUNG VIEW ========== -->
    <div class="view" id="view-manage">
        <div class="manage-grid">
            <div class="card">
                <div class="card-title" data-t="manage.stakeholder">Stakeholder</div>
                <ul class="manage-list" id="listStakeholder"></ul>
                <div class="manage-add">
                    <input type="text" id="addStakeholder" placeholder="Neuer Stakeholder..." data-t="ph.newStakeholder" onkeydown="if(event.key==='Enter')addItem('stakeholder')">
                    <button class="btn btn-primary" onclick="addItem('stakeholder')">+</button>
                </div>
            </div>
            <div class="card">
                <div class="card-title" data-t="manage.projekte">Projekte</div>
                <ul class="manage-list" id="listProjekt"></ul>
                <div class="manage-add">
                    <input type="text" id="addProjekt" placeholder="Neues Projekt..." data-t="ph.newProjekt" onkeydown="if(event.key==='Enter')addItem('projekt')">
                    <button class="btn btn-primary" onclick="addItem('projekt')">+</button>
                </div>
            </div>
            <div class="card">
                <div class="card-title" data-t="manage.taetigkeiten">Tätigkeiten</div>
                <ul class="manage-list" id="listTaetigkeit"></ul>
                <div class="manage-add">
                    <input type="text" id="addTaetigkeit" placeholder="Neue Tätigkeit..." data-t="ph.newTaetigkeit" onkeydown="if(event.key==='Enter')addItem('taetigkeit')">
                    <button class="btn btn-primary" onclick="addItem('taetigkeit')">+</button>
                </div>
            </div>
        </div>
        <div class="card" style="margin-top: 14px;">
            <div class="card-title" data-t="manage.backup">Backup & Wiederherstellung</div>
            <p style="font-size: 12px; color: var(--text-muted); margin-bottom: 12px; line-height: 1.5;" data-t="manage.updateHint">
                <span data-t="manage.backupHint">Vor einem Update: Backup erstellen → HTML-Datei ersetzen → Backup wiederherstellen. Alle Daten bleiben erhalten.</span>
            </p>
            <div style="display: flex; gap: 10px; flex-wrap: wrap; margin-bottom: 16px;">
                <button class="btn btn-success" onclick="exportBackup()"><span data-t="btn.backup">💾 Komplett-Backup</span></button>
                <button class="btn btn-primary" onclick="document.getElementById('backupFileInput').click()"><span data-t="btn.restore">📦 Backup wiederherstellen</span></button>
            </div>
            <input type="file" id="backupFileInput" accept=".json" style="display:none" onchange="handleBackupImport(event)">
            <div style="border-top: 1px solid var(--border); padding-top: 14px; margin-top: 4px;">
                <div class="card-title" style="margin-bottom: 10px;" data-t="manage.csv">CSV (nur Einträge)</div>
                <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                    <button class="btn" onclick="exportCSV()"><span data-t="btn.csvExport">📥 CSV Export</span></button>
                    <button class="btn" onclick="importCSV()"><span data-t="btn.csvImport">📤 CSV Import</span></button>
                </div>
            </div>
            <div style="border-top: 1px solid var(--border); padding-top: 14px; margin-top: 14px;">
                <button class="btn btn-danger" onclick="confirmClearAll()"><span data-t="btn.deleteAll">🗑️ Alle Daten löschen</span></button>
            </div>
            <input type="file" id="csvFileInput" accept=".csv" style="display:none" onchange="handleCSVImport(event)">
        </div>
    </div>

</div>

    <!-- ========== TEAM VIEW ========== -->
    <div class="view" id="view-team">

        <!-- Setup (wenn nicht verbunden) -->
        <div class="card" id="teamSetupCard" style="padding: 20px;">
            <div class="team-setup">
                <div class="team-setup-icon" style="font-size:36px; margin-bottom:8px;">👥</div>
                <div class="team-setup-text" style="margin-bottom:14px;">
                    Gemeinsamen Ordner auf dem Firmenlaufwerk verbinden.<br>
                    Alle Teammitglieder wählen denselben Ordner.
                </div>
                <div class="team-setup-actions">
                    <input type="text" class="team-name-input" id="teamNameInput" placeholder="Dein Name (z.B. Anna)" data-t="ph.teamName" maxlength="30">
                    <button class="btn btn-primary" onclick="teamConnect()" style="padding: 12px 24px;">
                        <span class="btn-icon"><svg viewBox="0 0 24 24"><path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"/></svg></span> Ordner verbinden
                    </button>
                </div>
            </div>
        </div>

        <!-- Verbunden: Status + Dashboard -->
        <div id="teamConnected" style="display:none;">
            <div class="card" style="padding: 16px 20px;">
                <div class="team-status" id="teamStatus">
                    <span class="dot"></span>
                    <span id="teamStatusText">Verbunden als <strong id="teamMyName"></strong></span>
                    <span style="flex:1;"></span>
                    <button class="btn" onclick="teamSync()" style="padding:4px 10px; font-size:11px;">🔄 Sync</button>
                    <button class="btn" onclick="teamDisconnect()" style="padding:4px 10px; font-size:11px;">✕</button>
                </div>
                <div class="team-members" id="teamMembers"></div>
                <!-- Periode + Filter + Export -->
                <div style="display:flex; align-items:center; gap:10px; flex-wrap:wrap; margin-bottom:0;">
                    <div class="tm-period-bar" style="margin-bottom:0;">
                        <button class="period-btn active" onclick="setTeamPeriod('week', this)" data-t="team.week">Woche</button>
                        <button class="period-btn" onclick="setTeamPeriod('month', this)" data-t="team.month">Monat</button>
                        <button class="period-btn" onclick="setTeamPeriod('year', this)" data-t="team.year">Jahr</button>
                        <button class="period-btn" onclick="setTeamPeriod('all', this)" data-t="team.all">Gesamt</button>
                        <button class="period-btn" onclick="setTeamPeriod('custom', this)" data-t="team.custom">Zeitraum</button>
                    </div>
                    <div class="tm-kpi-strip" id="teamKpis"></div>
                </div>
                <!-- Filter-Leiste: Zeitraum + Stakeholder + Projekt + Export -->
                <div class="tm-filter-bar" id="teamFilterBar">
                    <input type="date" class="tm-date-input" id="teamDateFrom" onchange="renderTeamDashboard()" data-t-title="title.filterVon">
                    <span class="tm-filter-label">bis</span>
                    <input type="date" class="tm-date-input" id="teamDateTo" onchange="renderTeamDashboard()" data-t-title="title.filterBis">
                    <select class="tm-filter-select" id="teamFilterSh" onchange="renderTeamDashboard()" data-t-title="manage.labelSh"><option value="" data-t="all.stakeholder">Alle Stakeholder</option></select>
                    <select class="tm-filter-select" id="teamFilterPr" onchange="renderTeamDashboard()" data-t-title="manage.labelPr"><option value="" data-t="all.projekte">Alle Projekte</option></select>
                    <button class="tm-export-btn" onclick="teamExportExcel()" title="Als Excel exportieren für Sitzungen" data-t="team.export">📊 Excel-Export</button>
                </div>
            </div>

            <!-- Tagesübersicht (volle Breite) -->
            <div class="team-dash-full">
                <div class="card card-compact">
                    <div class="card-title" onclick="this.parentElement.classList.toggle('collapsed')" data-t="team.attendance">📅 Tagesübersicht — Wer war wann aktiv</div>
                    <div class="card-body">
                        <div class="tm-att-scroll" id="teamAttendanceContainer"></div>
                    </div>
                </div>
            </div>

            <!-- 2-Spalten Grid: Matrix + Compare -->
            <div class="team-dash-grid">
                <div class="card card-compact">
                    <div class="card-title" onclick="this.parentElement.classList.toggle('collapsed')" data-t="team.shxperson">Stakeholder × Person</div>
                    <div class="card-body">
                        <div style="overflow-x:auto;" id="teamMatrixContainer"></div>
                    </div>
                </div>
                <div class="card card-compact">
                    <div class="card-title" onclick="this.parentElement.classList.toggle('collapsed')" data-t="team.prxperson">Projekt × Person</div>
                    <div class="card-body">
                        <div style="overflow-x:auto;" id="teamProjektMatrixContainer"></div>
                    </div>
                </div>
            </div>

            <!-- 2-Spalten Grid: Balken + Timeline -->
            <div class="team-dash-grid">
                <div class="card card-compact">
                    <div class="card-title" onclick="this.parentElement.classList.toggle('collapsed')" data-t="team.workload">Auslastung pro Person</div>
                    <div class="card-body">
                        <div id="teamCompareContainer"></div>
                        <div class="tm-legend" id="teamCompareLegend"></div>
                    </div>
                </div>
                <div class="card card-compact">
                    <div class="card-title" onclick="this.parentElement.classList.toggle('collapsed')" data-t="team.timeline">Zeitverlauf</div>
                    <div class="card-body">
                        <div id="teamTimelineContainer"></div>
                        <div class="tm-legend" id="teamTimelineLegend"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

<!-- ============================================================
     EDIT MODAL
     ============================================================ -->
<div class="modal-overlay" id="editModal">
    <div class="modal">
        <div class="modal-title" data-t="edit.title">Eintrag bearbeiten</div>
        <input type="hidden" id="editId">
        <div class="form-group">
            <label class="form-label" data-t="label.datum">Datum</label>
            <input type="date" class="form-input" id="editDate">
        </div>
        <div style="display:grid; grid-template-columns:1fr 1fr 1fr; gap:10px;">
            <div class="form-group">
                <label class="form-label" data-t="label.stakeholder">Stakeholder</label>
                <div class="field-with-add">
                    <select class="form-select" id="editStakeholder"></select>
                    <button class="inline-add-btn" onclick="inlineAddForManual('stakeholder','editStakeholder')" data-t-title="title.newSh">+</button>
                </div>
            </div>
            <div class="form-group">
                <label class="form-label" data-t="label.projekt">Projekt</label>
                <div class="field-with-add">
                    <select class="form-select" id="editProjekt"></select>
                    <button class="inline-add-btn" onclick="inlineAddForManual('projekt','editProjekt')" data-t-title="title.newPr">+</button>
                </div>
            </div>
            <div class="form-group">
                <label class="form-label" data-t="label.taetigkeit">Tätigkeit</label>
                <div class="field-with-add">
                    <select class="form-select" id="editTaetigkeit"></select>
                    <button class="inline-add-btn" onclick="inlineAddForManual('taetigkeit','editTaetigkeit')" data-t-title="title.newTa">+</button>
                </div>
            </div>
        </div>
        <div style="display:flex; gap:10px;">
            <div class="form-group" style="flex:1">
                <label class="form-label" data-t="label.von">Von</label>
                <input type="time" class="form-input" id="editStart">
            </div>
            <div class="form-group" style="flex:1">
                <label class="form-label" data-t="label.bis">Bis</label>
                <input type="time" class="form-input" id="editEnd">
            </div>
        </div>
        <div class="form-group">
            <label class="form-label" data-t="label.notiz">Notiz</label>
            <input type="text" class="form-input" id="editNotiz" placeholder="Optional..." list="notizSuggestions"
                onfocus="updateNotizDatalist(document.getElementById('editStakeholder').value, document.getElementById('editProjekt').value)">
        </div>
        <div class="modal-actions">
            <button class="btn" onclick="closeEditModal()" data-t="btn.cancel">Abbrechen</button>
            <button class="btn btn-primary" onclick="saveEdit()" data-t="btn.save">💾 Speichern</button>
        </div>
    </div>
</div>

<!-- ============================================================
     WELCOME MODAL (Auto-Erkennung bei leerem Start)
     ============================================================ -->
<div class="modal-overlay" id="welcomeModal">
    <div class="modal" style="max-width: 420px; text-align: center;">
        <div class="welcome-icon">⏱️</div>
        <div class="modal-title" style="text-align: center;" data-t="welcome.fullTitle">Willkommen bei Zeiterfassung</div>
        <div class="welcome-text">
            Es sind noch keine Daten vorhanden.<br>
            <span data-t="welcome.backupQ">Hast du ein Backup aus einer früheren Version?</span>
        </div>
        <button class="btn btn-primary" onclick="document.getElementById('welcomeBackupInput').click()" style="width: 100%; justify-content: center; padding: 12px;">
            <span class="btn-icon"><svg viewBox="0 0 24 24"><path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"/><polyline points="3.27 6.96 12 12.01 20.73 6.96"/><line x1="12" y1="22.08" x2="12" y2="12"/></svg></span> <span data-t="welcome.restoreBtn">Backup wiederherstellen (.json)</span>
        </button>
        <input type="file" id="welcomeBackupInput" accept=".json" style="display:none" onchange="handleWelcomeBackup(event)">
        <div class="welcome-or" data-t="welcome.or">oder</div>
        <button class="btn" onclick="closeWelcomeModal()" style="width: 100%; justify-content: center; padding: 12px;">
            Neu starten – ich lege alles frisch an
        </button>
    </div>
</div>

<!-- ============================================================
     SPLIT-BUCHUNG MODAL
     ============================================================ -->
<div class="modal-overlay" id="splitModal">
    <div class="modal split-modal">
        <div class="modal-title" data-t="split.modalTitle">✂ Zeit aufteilen</div>
        <div class="split-total-bar">
            <div>
                <div class="split-total-time" id="splitTotalTime">0:00:00</div>
                <div class="split-total-label" data-t="split.label">Bisherige Zeit aufteilen – Timer läuft weiter</div>
            </div>
        </div>
        <div class="split-alloc-bar" id="splitAllocBar"></div>
        <div class="split-rows" id="splitRows"></div>
        <div class="split-add-row" onclick="addSplitRow()" data-t="timer.addSplitTask">+ Weiteren Task hinzufügen</div>
        <div class="split-remaining" id="splitRemaining"></div>
        <div class="modal-actions">
            <button class="btn" onclick="closeSplitModal()" data-t="btn.cancel">Abbrechen</button>
            <button class="btn btn-primary" id="splitSaveBtn" onclick="saveSplitEntries()" data-t="btn.splitSave">✂ Aufteilen & Weiter</button>
        </div>
    </div>
</div>

<!-- Toast Container -->
<div class="toast-container" id="toastContainer"></div>

<!-- Floating Action Button: Quick-Start letzte Aufgabe -->
<button class="fab" id="fabBtn" onclick="fabQuickStart()" data-t-title="fab.resumeLast">▶</button>

<!-- Keyboard Shortcuts Overlay -->
<div class="kbd-overlay" id="kbdOverlay" onclick="if(event.target===this)this.classList.remove('open')">
    <div class="kbd-panel">
        <div class="kbd-title" data-t="kbd.title">⌨️ Tastenkürzel</div>
        <div class="kbd-grid">
            <span class="kbd-key">Space</span><span class="kbd-desc" data-t="kbd.space">Timer starten / pausieren</span>
            <span class="kbd-key">S</span><span class="kbd-desc" data-t="kbd.s">Timer stoppen & speichern</span>
            <span class="kbd-key">N</span><span class="kbd-desc" data-t="kbd.n">Neuen Task hinzufügen</span>
            <span class="kbd-key">1–5</span><span class="kbd-desc" data-t="kbd.tabs">Tab wechseln (Timer / Einträge / ...)</span>
            <span class="kbd-key">F</span><span class="kbd-desc" data-t="kbd.f">Feierabend – alle Timer stoppen</span>
            <span class="kbd-key">?</span><span class="kbd-desc" data-t="kbd.q">Diese Übersicht anzeigen</span>
            <span class="kbd-key">Esc</span><span class="kbd-desc" data-t="kbd.esc">Dialog / Overlay schliessen</span>
        </div>
        <div style="text-align:center; margin-top:20px;">
            <button class="btn" onclick="document.getElementById('kbdOverlay').classList.remove('open')" data-t="btn.close">Schliessen</button>
        </div>
    </div>
</div>

<!-- Confetti Container -->
<div class="confetti-container" id="confettiContainer"></div>

<datalist id="notizSuggestions"></datalist>
<script>
// ============================================================
// DATENMODELL & ZUSTAND
// ============================================================
const APP_KEY = 'zeiterfassung_v1';

// ============================================================
// 🌐 INTERNATIONALISIERUNG (DE / FR)
// ============================================================
let appLang = localStorage.getItem(APP_KEY + '_lang') || 'de';

const I18N = {
    // --- Navigation ---
    'nav.timer':        { de: 'Timer',          fr: 'Chrono' },
    'nav.entries':      { de: 'Einträge',       fr: 'Entrées' },
    'nav.dashboard':    { de: 'Dashboard',      fr: 'Tableau de bord' },
    'nav.manage':       { de: 'Verwaltung',     fr: 'Gestion' },
    'nav.team':         { de: 'Team',           fr: 'Équipe' },
    'bnav.timer':       { de: 'Timer',          fr: 'Chrono' },
    'bnav.entries':     { de: 'Einträge',       fr: 'Entrées' },
    'bnav.dashboard':   { de: 'Dashboard',      fr: 'Tableau' },
    'bnav.manage':      { de: 'Verwalten',      fr: 'Gérer' },
    'bnav.team':        { de: 'Team',           fr: 'Équipe' },

    // --- Timer View ---
    'tasks':            { de: 'Tasks',          fr: 'Tâches' },
    'manual.title':     { de: 'Manuell eintragen', fr: 'Saisie manuelle' },
    'manual.save':      { de: '💾 Speichern',    fr: '💾 Enregistrer' },
    'manual.split':     { de: '✂ Aufteilen & Weiter', fr: '✂ Diviser & continuer' },
    'ph.stakeholder':   { de: 'Stakeholder',    fr: 'Mandant' },
    'ph.projekt':       { de: 'Projekt',        fr: 'Projet' },
    'ph.taetigkeit':    { de: 'Tätigkeit',      fr: 'Activité' },
    'ph.notiz':         { de: 'Notiz (optional)', fr: 'Note (facultatif)' },
    'ph.select':        { de: '— wählen —',     fr: '— choisir —' },
    'from':             { de: 'Von',            fr: 'De' },
    'to':               { de: 'Bis',            fr: 'À' },

    // --- Entries View ---
    'entries.title':    { de: 'Erfasste Einträge', fr: 'Entrées saisies' },
    'entries.count':    { de: 'Einträge',       fr: 'entrées' },
    'entries.total':    { de: 'Total',          fr: 'Total' },
    'entries.of':       { de: 'von',            fr: 'sur' },
    'entries.nodata':   { de: 'Noch keine Einträge vorhanden.', fr: 'Aucune entrée enregistrée.' },
    'entries.nodata2':  { de: 'Starte einen Timer oder trage Zeit manuell ein.', fr: 'Lancez un chrono ou saisissez le temps manuellement.' },
    'entries.nofilter': { de: 'Keine Treffer für aktiven Filter', fr: 'Aucun résultat pour le filtre actif' },
    'entries.total.label': { de: 'Einträge total', fr: 'entrées au total' },
    'all.stakeholder':  { de: 'Alle Stakeholder', fr: 'Tous les mandants' },
    'all.projekte':     { de: 'Alle Projekte',  fr: 'Tous les projets' },
    'all.taetigkeiten': { de: 'Alle Tätigkeiten', fr: 'Toutes les activités' },
    'filter.notiz':     { de: '🔍 Notiz...',    fr: '🔍 Note...' },
    'filter.reset':     { de: '✕ Reset',        fr: '✕ Réinit.' },
    'filter.resetAll':  { de: '✕ Alle zurücksetzen', fr: '✕ Tout réinitialiser' },

    // --- Table Headers ---
    'th.datum':         { de: 'Datum',          fr: 'Date' },
    'th.stakeholder':   { de: 'Stakeholder',    fr: 'Mandant' },
    'th.projekt':       { de: 'Projekt',        fr: 'Projet' },
    'th.taetigkeit':    { de: 'Tätigkeit',      fr: 'Activité' },
    'th.von':           { de: 'Von',            fr: 'De' },
    'th.bis':           { de: 'Bis',            fr: 'À' },
    'th.dauer':         { de: 'Dauer',          fr: 'Durée' },
    'th.notiz':         { de: 'Notiz',          fr: 'Note' },

    // --- Dashboard ---
    'dash.today':       { de: 'Heute',          fr: "Aujourd'hui" },
    'dash.thisWeek':    { de: 'Diese Woche',    fr: 'Cette semaine' },
    'dash.thisMonth':   { de: 'Dieser Monat',   fr: 'Ce mois' },
    'dash.thisYear':    { de: 'Dieses Jahr',    fr: 'Cette année' },
    'dash.all':         { de: 'Gesamt',         fr: 'Total' },
    'dash.week':        { de: 'Diese Woche',    fr: 'Cette semaine' },
    'dash.shxpr':       { de: 'Stakeholder × Projekt', fr: 'Mandant × Projet' },
    'dash.byActivity':  { de: 'Nach Tätigkeit', fr: 'Par activité' },
    'dash.timeline':    { de: 'Zeitverlauf',    fr: 'Chronologie' },
    'dash.nodata':      { de: 'Keine Daten.',   fr: 'Pas de données.' },

    // --- Manage View ---
    'manage.stakeholder': { de: 'Stakeholder',  fr: 'Mandants' },
    'manage.projekte':  { de: 'Projekte',       fr: 'Projets' },
    'manage.taetigkeiten': { de: 'Tätigkeiten', fr: 'Activités' },
    'manage.backup':    { de: 'Backup & Wiederherstellung', fr: 'Sauvegarde & restauration' },
    'manage.csv':       { de: 'CSV (nur Einträge)', fr: 'CSV (entrées uniquement)' },
    'manage.deleteAll': { de: '🗑️ Alle Daten löschen', fr: '🗑️ Supprimer toutes les données' },
    'manage.deleteWarn': { de: 'Vor einem Update: Backup erstellen → HTML-Datei ersetzen → Backup wiederherstellen. Alle Daten bleiben erhalten.', fr: 'Avant une mise à jour : créer une sauvegarde → remplacer le fichier HTML → restaurer la sauvegarde. Toutes les données sont conservées.' },
    'ph.newStakeholder': { de: 'Neuer Stakeholder...', fr: 'Nouveau mandant...' },
    'ph.newProjekt':    { de: 'Neues Projekt...', fr: 'Nouveau projet...' },
    'ph.newTaetigkeit': { de: 'Neue Tätigkeit...', fr: 'Nouvelle activité...' },
    'btn.backup':       { de: 'Komplett-Backup', fr: 'Sauvegarde complète' },
    'btn.restore':      { de: 'Backup wiederherstellen', fr: 'Restaurer la sauvegarde' },
    'btn.csvExport':    { de: 'CSV Export',      fr: 'Export CSV' },
    'btn.csvImport':    { de: 'CSV Import',      fr: 'Import CSV' },
    'btn.dsbRestore':   { de: '🛡️ Auto-Backup laden', fr: '🛡️ Charger sauvegarde auto' },
    'btn.dsbStatus':    { de: '📊 Backup-Status', fr: '📊 État des sauvegardes' },

    // --- Team View ---
    'team.setup.text':  { de: 'Gemeinsamen Ordner auf dem Firmenlaufwerk verbinden.\nAlle Teammitglieder wählen denselben Ordner.', fr: 'Connecter un dossier partagé sur le lecteur réseau.\nTous les membres de l\'équipe choisissent le même dossier.' },
    'team.connect':     { de: 'Ordner verbinden', fr: 'Connecter le dossier' },
    'team.reconnect':   { de: 'Erneut verbinden', fr: 'Reconnecter' },
    'team.lastFolder':  { de: 'Letzter Ordner', fr: 'Dernier dossier' },
    'team.reconnectFail': { de: 'Berechtigung verweigert — bitte Ordner neu wählen.', fr: 'Permission refusée — veuillez resélectionner le dossier.' },
    'team.connected':   { de: 'Verbunden als',  fr: 'Connecté en tant que' },
    'team.sync':        { de: '🔄 Sync',        fr: '🔄 Sync' },
    'team.nodata':      { de: 'Noch keine Daten. Drücke "Sync".', fr: 'Pas encore de données. Appuyez sur « Sync ».' },
    'team.week':        { de: 'Woche',          fr: 'Semaine' },
    'team.month':       { de: 'Monat',          fr: 'Mois' },
    'team.year':        { de: 'Jahr',           fr: 'Année' },
    'team.all':         { de: 'Gesamt',         fr: 'Total' },
    'team.custom':      { de: 'Zeitraum',       fr: 'Période' },
    'team.export':      { de: '📊 Excel-Export', fr: '📊 Export Excel' },
    'team.attendance':  { de: '📅 Tagesübersicht — Wer war wann aktiv', fr: '📅 Vue journalière — Qui était actif quand' },
    'team.shxperson':   { de: 'Stakeholder × Person', fr: 'Mandant × Personne' },
    'team.prxperson':   { de: 'Projekt × Person', fr: 'Projet × Personne' },
    'team.workload':    { de: 'Auslastung pro Person', fr: 'Charge par personne' },
    'team.timeline':    { de: 'Zeitverlauf',    fr: 'Chronologie' },
    'team.hours':       { de: 'Stunden',        fr: 'Heures' },
    'team.persons':     { de: 'Personen',       fr: 'Personnes' },
    'team.perPerson':   { de: '⌀/Person',       fr: '⌀/Personne' },
    'team.perDay':      { de: '⌀/Tag',          fr: '⌀/Jour' },
    'team.total':       { de: 'Total',          fr: 'Total' },
    'team.noperiod':    { de: 'Keine Daten im Zeitraum', fr: 'Aucune donnée pour la période' },
    'team.avgWorkday':  { de: '⌀ / Arbeitstag', fr: '⌀ / Jour ouvrable' },
    'ph.teamName':      { de: 'Dein Name (z.B. Anna)', fr: 'Votre nom (p.ex. Anne)' },

    // --- KPIs ---
    'kpi.today':        { de: 'Heute',          fr: "Aujourd'hui" },
    'kpi.presence':     { de: 'Anwesenheit',    fr: 'Présence' },
    'kpi.entries':      { de: 'Einträge',       fr: 'Entrées' },

    // --- Edit Modal ---
    'edit.title':       { de: 'Eintrag bearbeiten', fr: 'Modifier l\'entrée' },
    'edit.save':        { de: '💾 Speichern',    fr: '💾 Enregistrer' },
    'edit.cancel':      { de: 'Abbrechen',      fr: 'Annuler' },

    // --- Welcome ---
    'welcome.title':    { de: 'Willkommen',     fr: 'Bienvenue' },
    'welcome.text':     { de: 'Erstmalige Nutzung? Starte direkt oder importiere ein bestehendes Backup.', fr: 'Première utilisation ? Commencez directement ou importez une sauvegarde existante.' },
    'welcome.start':    { de: '🚀 Direkt starten', fr: '🚀 Démarrer directement' },
    'welcome.import':   { de: '📂 Backup importieren', fr: '📂 Importer une sauvegarde' },
    'welcome.or':       { de: 'oder',           fr: 'ou' },

    // --- Split Modal ---
    'split.title':      { de: 'Buchung aufteilen', fr: 'Diviser la saisie' },

    // --- Toast Messages ---
    'toast.saved':      { de: 'gespeichert',    fr: 'enregistré' },
    'toast.deleted':    { de: 'gelöscht',       fr: 'supprimé' },
    'toast.midnight':   { de: 'über Mitternacht (2 Einträge)', fr: 'passé minuit (2 entrées)' },
    'toast.manualOk':   { de: 'manuell eingetragen.', fr: 'saisi manuellement.' },
    'toast.midnightManual': { de: 'über Mitternacht eingetragen (2 Einträge).', fr: 'saisi passé minuit (2 entrées).' },
    'toast.tooShort':   { de: 'Timer war zu kurz (< 1 Sekunde).', fr: 'Chrono trop court (< 1 seconde).' },
    'toast.backupOk':   { de: 'Backup gespeichert', fr: 'Sauvegarde enregistrée' },
    'toast.restoreOk':  { de: 'Backup wiederhergestellt', fr: 'Sauvegarde restaurée' },
    'toast.importOk':   { de: 'Einträge importiert.', fr: 'Entrées importées.' },
    'toast.exportOk':   { de: 'Excel-Export heruntergeladen', fr: 'Export Excel téléchargé' },
    'toast.syncOk':     { de: 'Teammitglieder geladen.', fr: 'membres de l\'équipe chargés.' },
    'toast.connected':  { de: 'Verbunden als', fr: 'Connecté en tant que' },
    'toast.disconnected': { de: 'Team-Verbindung getrennt.', fr: 'Connexion équipe déconnectée.' },
    'toast.allDeleted': { de: 'Alle Daten gelöscht.', fr: 'Toutes les données supprimées.' },
    'toast.invalidFile': { de: 'Ungültige Datei', fr: 'Fichier invalide' },
    'toast.aborted':    { de: 'Abgebrochen', fr: 'Annulé' },
    'toast.noBackup':   { de: 'Keine Backups vorhanden.', fr: 'Aucune sauvegarde disponible.' },
    'toast.selectShPr': { de: 'Bitte Stakeholder und Projekt wählen.', fr: 'Veuillez choisir un mandant et un projet.' },
    'toast.selectDate': { de: 'Bitte Datum eingeben.', fr: 'Veuillez saisir une date.' },
    'toast.selectTime': { de: 'Bitte Von- und Bis-Zeit eingeben.', fr: 'Veuillez saisir les heures de début et de fin.' },
    'toast.endAfterStart': { de: 'Bis-Zeit muss nach Von-Zeit liegen.', fr: 'L\'heure de fin doit être après l\'heure de début.' },

    // --- Confirm/Prompt ---
    'confirm.delete':   { de: 'Eintrag löschen?', fr: 'Supprimer l\'entrée ?' },
    'confirm.deleteAll': { de: '⚠️ ACHTUNG: Alle Daten (Einträge + Stammdaten) werden unwiderruflich gelöscht.\n\nDieser Vorgang kann NICHT rückgängig gemacht werden.\n\nFortfahren?', fr: '⚠️ ATTENTION : Toutes les données (entrées + données de base) seront supprimées de manière irréversible.\n\nCette action est IRRÉVERSIBLE.\n\nContinuer ?' },
    'confirm.disconnect': { de: 'Team-Verbindung trennen?', fr: 'Déconnecter l\'équipe ?' },
    'confirm.restore':  { de: 'Aktuelle Daten werden überschrieben.', fr: 'Les données actuelles seront écrasées.' },
    'confirm.replaceData': { de: 'OK = Bestehende Daten ERSETZEN\nAbbrechen = Import abbrechen', fr: 'OK = REMPLACER les données existantes\nAnnuler = Annuler l\'import' },

    // --- Weekdays ---
    'wd.short':         { de: ['So','Mo','Di','Mi','Do','Fr','Sa'], fr: ['Di','Lu','Ma','Me','Je','Ve','Sa'] },
    'wd.long':          { de: ['Sonntag','Montag','Dienstag','Mittwoch','Donnerstag','Freitag','Samstag'], fr: ['Dimanche','Lundi','Mardi','Mercredi','Jeudi','Vendredi','Samedi'] },

    // --- Misc ---
    'running':          { de: 'LÄUFT',          fr: 'EN COURS' },
    'paused':           { de: 'PAUSE',          fr: 'PAUSE' },
    'empty':            { de: '(leer)',         fr: '(vide)' },
    // --- Entries view ---
    'entries.count':    { de: 'Einträge',       fr: 'Entrées' },
    'entries.total':    { de: 'Total:',          fr: 'Total :' },
    'entries.of':       { de: 'von',             fr: 'sur' },
    'entries.noMatch':  { de: 'Keine Treffer für aktiven Filter', fr: 'Aucun résultat pour le filtre actif' },
    'entries.totalSuffix': { de: 'Einträge total', fr: 'entrées au total' },
    'filter.from':      { de: 'Ab',              fr: 'Dès' },
    'filter.to':        { de: 'Bis',             fr: "Jusqu'au" },
    'filter.clearAll':  { de: '✕ Alle zurücksetzen', fr: '✕ Tout réinitialiser' },
    // --- Manage ---
    'manage.noEntries': { de: 'Noch keine Einträge', fr: 'Aucune entrée' },
    'manage.deleted':   { de: 'gelöscht.',       fr: 'supprimé.' },
    'manage.labelSh':   { de: 'Stakeholder',     fr: 'Mandant' },
    'manage.labelPr':   { de: 'Projekt',         fr: 'Projet' },
    'manage.labelTa':   { de: 'Tätigkeit',       fr: 'Activité' },
    // --- Timer / stop ---
    'toast.saved':      { de: 'gespeichert',     fr: 'enregistré' },
    'toast.midnight2':  { de: 'über Mitternacht (2 Einträge)', fr: 'passé minuit (2 entrées)' },
    'toast.confirmStopMulti': { de: 'laufende Timer stoppen und speichern?', fr: 'chronomètres en cours — arrêter et enregistrer ?' },
    'toast.noTimer':    { de: 'Kein Timer aktiv.', fr: 'Aucun chrono actif.' },
    'toast.tooShort2':  { de: 'Timer zu kurz.',  fr: 'Chrono trop court.' },
    'toast.splitRow':   { de: 'Stakeholder und Projekt nötig.', fr: 'Mandant et projet requis.' },
    'label.datum':      { de: 'Datum',           fr: 'Date' },
    'label.von':        { de: 'Von',             fr: 'De' },
    'label.bis':        { de: 'Bis',             fr: 'À' },
    'label.notiz':      { de: 'Notiz',           fr: 'Note' },
    'label.stakeholder': { de: 'Stakeholder',    fr: 'Mandant' },
    'label.projekt':    { de: 'Projekt',         fr: 'Projet' },
    'label.taetigkeit': { de: 'Tätigkeit',       fr: 'Activité' },
    'label.anteil':     { de: 'Anteil',          fr: 'Part' },
    'timer.todayTotal': { de: 'Heute total',     fr: "Aujourd'hui total" },
    'timer.addTask':    { de: '+ Neuen Task hinzufügen', fr: '+ Ajouter une tâche' },
    'timer.addSplitTask': { de: '+ Weiteren Task hinzufügen', fr: '+ Ajouter une tâche' },
    'timer.multipleTasks': { de: 'Mehrere Tasks', fr: 'Plusieurs tâches' },
    'timer.running':    { de: 'LÄUFT',           fr: 'EN COURS' },
    'timer.paused':     { de: 'PAUSE',           fr: 'PAUSE' },
    'split.modalTitle': { de: '✂ Zeit aufteilen', fr: '✂ Diviser le temps' },
    'split.label':      { de: 'Bisherige Zeit aufteilen – Timer läuft weiter', fr: 'Diviser le temps écoulé – le chrono continue' },
    'split.complete':   { de: '✓ 100% verteilt', fr: '✓ 100% réparti' },
    'split.tooMuch':    { de: '% — {n}% zu viel', fr: '% — {n}% de trop' },
    'split.remaining':  { de: '% — noch {n}% übrig', fr: '% — encore {n}% restant' },
    'welcome.fullTitle': { de: 'Willkommen bei Zeiterfassung', fr: 'Bienvenue – Saisie du temps' },
    'welcome.backupQ':  { de: 'Hast du ein Backup aus einer früheren Version?', fr: "As-tu une sauvegarde d'une version précédente ?" },
    'welcome.restoreBtn': { de: '📦 Backup wiederherstellen (.json)', fr: '📦 Restaurer la sauvegarde (.json)' },
    'btn.export':       { de: 'Export',          fr: 'Export' },
    'btn.backup2':      { de: 'Backup',          fr: 'Sauvegarde' },
    'btn.cancel':       { de: 'Abbrechen',       fr: 'Annuler' },
    'btn.save':         { de: 'Speichern',       fr: 'Enregistrer' },
    'btn.splitSave':    { de: '✂ Aufteilen & Weiter', fr: '✂ Diviser & continuer' },
    'prompt.addNew':    { de: 'Neuen {label} hinzufügen:', fr: 'Ajouter un nouveau {label} :' },
    'prompt.rename':    { de: 'Neuer Name:',     fr: 'Nouveau nom :' },
    'toast.duplicate':  { de: 'existiert bereits.', fr: 'existe déjà.' },
    'toast.added':      { de: 'hinzugefügt.',    fr: 'ajouté.' },
    'toast.renamed':    { de: 'Umbenannt zu',    fr: 'Renommé en' },
    'toast.csvExported': { de: 'CSV exportiert.', fr: 'CSV exporté.' },
    'toast.csvEmpty':   { de: 'CSV ist leer.',   fr: 'CSV est vide.' },
    'toast.teamSync':   { de: 'Teammitglieder geladen.', fr: "membres de l'équipe chargés." },
    'manage.backupHint': { de: 'Vor einem Update: Backup erstellen → HTML-Datei ersetzen → Backup wiederherstellen. Alle Daten bleiben erhalten.', fr: 'Avant une mise à jour : créer une sauvegarde → remplacer le fichier HTML → restaurer la sauvegarde. Toutes les données sont conservées.' },
    'team.exportLabel': { de: 'Excel-Export',    fr: 'Export Excel' },
    'toast.splitSaved': { de: 'Einträge gespeichert – Timer laufen weiter.', fr: 'Entrées enregistrées – les chronos continuent.' },
    'toast.entryUpdated': { de: 'Eintrag aktualisiert.', fr: 'Entrée mise à jour.' },
    'toast.entryDeleted': { de: 'Eintrag gelöscht.', fr: 'Entrée supprimée.' },
    'toast.entryRestored': { de: 'Eintrag wiederhergestellt.', fr: 'Entrée restaurée.' },
    'toast.connected':  { de: 'Verbunden als',   fr: 'Connecté en tant que' },
    // --- Backup ---
    'toast.backupLoaded': { de: 'Backup geladen:', fr: 'Sauvegarde chargée :' },
    'toast.backupSaved2': { de: 'Backup gespeichert', fr: 'Sauvegarde enregistrée' },
    'toast.backupRestored': { de: 'Backup wiederhergestellt:', fr: 'Sauvegarde restaurée :' },
    'toast.backupReadError': { de: 'Fehler beim Lesen der Backup-Datei:', fr: 'Erreur de lecture du fichier de sauvegarde :' },
    'toast.invalidBackup': { de: 'Ungültige Backup-Datei.', fr: 'Fichier de sauvegarde invalide.' },
    'toast.invalidNoEntries': { de: 'Ungültige Datei: Keine Einträge gefunden.', fr: 'Fichier invalide : aucune entrée trouvée.' },
    'toast.noExport':   { de: 'Keine Einträge zum Exportieren.', fr: "Aucune entrée à exporter." },
    'toast.error':      { de: 'Fehler:',         fr: 'Erreur :' },
    'toast.allDeleted2': { de: 'Alle Daten gelöscht. (Notfall-Backup unter dsb_lastResort gespeichert)', fr: 'Toutes les données supprimées. (Sauvegarde d\'urgence sous dsb_lastResort)' },
    'toast.imported':   { de: 'Einträge importiert.', fr: 'entrées importées.' },
    // --- Backup confirm ---
    'backup.contains':  { de: 'Backup enthält:', fr: 'La sauvegarde contient :' },
    'backup.entries':   { de: 'Einträge',        fr: 'entrées' },
    // --- CSV export headers ---
    'csv.datum':        { de: 'Datum',            fr: 'Date' },
    'csv.stakeholder':  { de: 'Stakeholder',      fr: 'Mandant' },
    'csv.projekt':      { de: 'Projekt',          fr: 'Projet' },
    'csv.taetigkeit':   { de: 'Tätigkeit',        fr: 'Activité' },
    'csv.von':          { de: 'Von',              fr: 'De' },
    'csv.bis':          { de: 'Bis',              fr: 'À' },
    'csv.dauer':        { de: 'Dauer (h)',        fr: 'Durée (h)' },
    'csv.notiz':        { de: 'Notiz',            fr: 'Note' },
    'csv.wochentag':    { de: 'Wochentag',        fr: 'Jour' },
    // --- FAB ---
    'fab.goTimer':      { de: 'Zum laufenden Timer', fr: 'Aller au chrono actif' },
    'fab.resume':       { de: 'Timer fortsetzen', fr: 'Reprendre le chrono' },
    'fab.resumeLast':   { de: 'Letzte Aufgabe fortsetzen', fr: 'Reprendre la dernière tâche' },
    // --- Team KPIs ---
    'team.kpiTotal':    { de: 'Total',            fr: 'Total' },
    'team.kpiPersons':  { de: 'Personen',         fr: 'Personnes' },
    'team.kpiEntries':  { de: 'Einträge',         fr: 'Entrées' },
    'team.kpiPerPerson': { de: '⌀/Person',        fr: '⌀/Personne' },
    'team.kpiPerDay':   { de: '⌀/Tag',            fr: '⌀/Jour' },
    // --- Team Attendance ---
    'team.attTitle':    { de: 'TAGESÜBERSICHT',   fr: 'VUE JOURNALIÈRE' },
    'team.attAvgDay':   { de: '⌀ / Arbeitstag',  fr: '⌀ / Jour ouvrable' },
    'team.shXperson':   { de: 'STAKEHOLDER × PERSON', fr: 'MANDANT × PERSONNE' },
    'team.prXperson':   { de: 'PROJEKT × PERSON', fr: 'PROJET × PERSONNE' },
    // --- Heatmap ---
    'heatmap.total':    { de: 'Total',            fr: 'Total' },
    // --- DSB ---
    'dsb.cancelled':    { de: 'Abgebrochen.',     fr: 'Annulé.' },
    'dsb.crcWarn':      { de: '⚠️ Dieses Backup hat einen CRC-Fehler (möglicherweise beschädigt).\n\nTrotzdem verwenden?', fr: '⚠️ Cette sauvegarde a une erreur CRC (possiblement corrompue).\n\nL\'utiliser quand même ?' },
    'dsb.confirmRestore': { de: 'Sicher? {count} Einträge aus {source} wiederherstellen?\n\nAktuelle Daten werden überschrieben.', fr: 'Sûr ? Restaurer {count} entrées de {source} ?\n\nLes données actuelles seront écrasées.' },
    'dsb.restored':     { de: '🛡️ {count} Einträge aus {source} wiederhergestellt!', fr: '🛡️ {count} entrées restaurées depuis {source} !' },
    'dsb.heartbeatFound': { de: '🛡️ Laufende Timer nach Absturz gefunden:\n\n{names}\n\nTimer wiederherstellen?', fr: '🛡️ Chronos actifs trouvés après crash :\n\n{names}\n\nRestaurer les chronos ?' },
    'dsb.heartbeatOk':  { de: '🛡️ {count} Timer wiederhergestellt!', fr: '🛡️ {count} chronos restaurés !' },
    'dsb.startupWarn':  { de: '🛡️ Achtung: Ein Backup enthält {bc} Einträge, aktuell sind nur {ec} geladen.\n\nMöchtest du das Backup wiederherstellen?', fr: '🛡️ Attention : une sauvegarde contient {bc} entrées, seulement {ec} actuellement chargées.\n\nRestaurer la sauvegarde ?' },
    'dsb.startupRestore': { de: '🛡️ Keine Daten geladen, aber Backup gefunden!\n\n{source}: {count} Einträge vom {when}{status}\n\nJetzt wiederherstellen?', fr: '🛡️ Aucune donnée chargée, mais sauvegarde trouvée !\n\n{source} : {count} entrées du {when}{status}\n\nRestaurer maintenant ?' },
    'dsb.crcNote':      { de: '\n⚠️ CRC-Warnung: Backup möglicherweise beschädigt.', fr: '\n⚠️ Avertissement CRC : sauvegarde possiblement corrompue.' },
    // --- DSB Status ---
    'dsb.statusTitle':  { de: '🛡️ DATA SAFETY BELT — Status', fr: '🛡️ DATA SAFETY BELT — État' },
    'dsb.layers':       { de: 'Speicher-Schichten aktiv:', fr: 'Couches de stockage actives :' },
    'dsb.generations':  { de: 'Backup-Generationen:', fr: 'Générations de sauvegarde :' },
    'dsb.savesSession': { de: 'Saves seit Start:', fr: 'Sauvegardes depuis le démarrage :' },
    'dsb.savesTotal':   { de: 'Total Backups geschrieben:', fr: 'Total sauvegardes écrites :' },
    'dsb.nextSlot':     { de: 'Nächster Slot:', fr: 'Prochain slot :' },
    'dsb.available':    { de: 'Verfügbare Backups:', fr: 'Sauvegardes disponibles :' },
    'dsb.noBackups':    { de: 'Keine Backups vorhanden.', fr: 'Aucune sauvegarde disponible.' },
    'dsb.inMemory':     { de: 'Aktuell im Speicher:', fr: 'Actuellement en mémoire :' },
    'dsb.runningTimers': { de: 'Laufende Timer:', fr: 'Chronos actifs :' },
    'dsb.heartbeatActive': { de: '(Heartbeat aktiv)', fr: '(Heartbeat actif)' },
    'dsb.periodicSave': { de: 'Periodischer Save: alle', fr: 'Sauvegarde périodique : toutes les' },
    'dsb.heartbeatInterval': { de: 'Timer-Heartbeat: alle', fr: 'Heartbeat chrono : toutes les' },
    'dsb.crcError':     { de: '⚠️ CRC-Fehler',   fr: '⚠️ Erreur CRC' },
    // --- Period / Zeitraum ---
    'period.label':     { de: 'Zeitraum',         fr: 'Période' },
    'kpi.today':        { de: 'Heute',             fr: "Aujourd'hui" },
    // --- Additional round 2 ---
    'dash.noEntries':   { de: '📭 Keine Einträge im gewählten Zeitraum.<br>Wähle oben eine andere Periode oder erfasse Zeiten im Timer-Tab.', fr: "📭 Aucune entrée pour la période sélectionnée.<br>Choisissez une autre période ou saisissez des temps dans l'onglet Chrono." },
    'dash.noData':      { de: 'Keine Daten.',      fr: 'Aucune donnée.' },
    'confirm.deleteItem': { de: 'wirklich löschen?', fr: 'vraiment supprimer ?' },
    'team.disconnect':  { de: 'Team-Verbindung trennen?', fr: 'Déconnecter l\'équipe ?' },
    'team.noTeamData':  { de: 'Keine Team-Daten vorhanden.', fr: 'Aucune donnée d\'équipe.' },
    'team.noPeriodData': { de: 'Keine Daten im gewählten Zeitraum.', fr: 'Aucune donnée pour la période choisie.' },
    'team.today':       { de: 'heute',             fr: "aujourd'hui" },
    'dsb.prompt':       { de: '🛡️ Verfügbare Backups:', fr: '🛡️ Sauvegardes disponibles :' },
    'dsb.promptInput':  { de: 'Nummer eingeben (1-{n}) oder Abbrechen:', fr: 'Entrez un numéro (1-{n}) ou Annuler :' },
    // --- Static HTML ---
    'welcome.noEntries': { de: 'Noch keine Einträge vorhanden.', fr: 'Aucune entrée enregistrée.' },
    'welcome.hint':     { de: 'Starte einen Timer oder trage Zeit manuell ein.<br>Drücke <strong>Leertaste</strong> für Schnellstart.', fr: 'Lancez un chrono ou saisissez le temps manuellement.<br>Appuyez sur <strong>Espace</strong> pour démarrer.' },
    'edit.title':       { de: 'Eintrag bearbeiten', fr: 'Modifier l\'entrée' },
    'manage.updateHint': { de: 'Vor einem Update: Backup erstellen → HTML-Datei ersetzen → Backup wiederherstellen. Alle Daten bleiben erhalten.', fr: 'Avant une mise à jour : créer une sauvegarde → remplacer le fichier HTML → restaurer la sauvegarde. Toutes les données sont conservées.' },
    'btn.deleteAll':    { de: '🗑️ Alle Daten löschen', fr: '🗑️ Supprimer toutes les données' },
    'btn.backup':       { de: '💾 Komplett-Backup', fr: '💾 Sauvegarde complète' },
    'btn.restore':      { de: '📦 Backup wiederherstellen', fr: '📦 Restaurer la sauvegarde' },
    'btn.csvExport':    { de: '📥 CSV Export',     fr: '📥 Export CSV' },
    'btn.csvImport':    { de: '📤 CSV Import',     fr: '📤 Import CSV' },
    'btn.close':        { de: 'Schliessen',        fr: 'Fermer' },
    'kbd.title':        { de: '⌨️ Tastenkürzel',  fr: '⌨️ Raccourcis clavier' },
    'kbd.space':        { de: 'Timer starten / pausieren', fr: 'Démarrer / mettre en pause' },
    'kbd.s':            { de: 'Timer stoppen & speichern', fr: 'Arrêter & enregistrer' },
    'kbd.n':            { de: 'Neuen Task hinzufügen', fr: 'Ajouter une tâche' },
    'kbd.tabs':         { de: 'Tab wechseln (Timer / Einträge / ...)', fr: 'Changer d\'onglet (Chrono / Entrées / ...)' },
    'kbd.f':            { de: 'Feierabend – alle Timer stoppen', fr: 'Fin de journée – arrêter tous les chronos' },
    'kbd.q':            { de: 'Diese Übersicht anzeigen', fr: 'Afficher cet aperçu' },
    'kbd.esc':          { de: 'Dialog / Overlay schliessen', fr: 'Fermer le dialogue' },
    // --- Round 3: tooltips & small strings ---
    'title.backup':     { de: 'Komplett-Backup', fr: 'Sauvegarde complète' },
    'title.dsbRestore': { de: 'Aus automatischem Backup wiederherstellen', fr: 'Restaurer depuis la sauvegarde automatique' },
    'title.dsbStatus':  { de: 'Backup-Status anzeigen', fr: "Afficher l'état des sauvegardes" },
    'title.csvExport':  { de: 'CSV Export', fr: 'Export CSV' },
    'title.langToggle': { de: 'Sprache / Langue', fr: 'Langue / Sprache' },
    'title.themeToggle': { de: 'Theme wechseln', fr: 'Changer le thème' },
    'title.kbdShortcuts': { de: 'Tastenkürzel (?)', fr: 'Raccourcis clavier (?)' },
    'title.newSh':      { de: 'Neuer Stakeholder', fr: 'Nouveau mandant' },
    'title.newPr':      { de: 'Neues Projekt', fr: 'Nouveau projet' },
    'title.newTa':      { de: 'Neue Tätigkeit', fr: 'Nouvelle activité' },
    'title.stopAll':    { de: 'Feierabend – alle Timer stoppen', fr: 'Fin de journée – arrêter tous les chronos' },
    'title.split':      { de: 'Zeit aufteilen', fr: 'Répartir le temps' },
    'title.filterVon':  { de: 'Von', fr: 'De' },
    'title.filterBis':  { de: 'Bis', fr: "Jusqu'à" },
    'title.filterNotiz': { de: 'Freitext-Suche in Notizen', fr: 'Recherche libre dans les notes' },
    'title.resetFilter': { de: 'Alle Filter zurücksetzen', fr: 'Réinitialiser tous les filtres' },
    'title.resetDashFilter': { de: 'Alle Filter zurücksetzen', fr: 'Réinitialiser tous les filtres' },
    'ts.pause':         { de: 'Pause', fr: 'Pause' },
    'ts.start':         { de: 'Start', fr: 'Démarrer' },
    'ts.stopSave':      { de: 'Stopp & Speichern', fr: 'Arrêter & enregistrer' },
    'ts.remove':        { de: 'Task entfernen', fr: 'Supprimer la tâche' },
    'timer.ready':      { de: 'Bereit', fr: 'Prêt' },
    'timer.startHint':  { de: 'Starte einen Task mit ▶', fr: 'Lancez une tâche avec ▶' },
    'toast.max8':       { de: 'Maximal 8 Tasks.', fr: 'Maximum 8 tâches.' },
    'timer.manualTitle': { de: 'Manueller Eintrag', fr: 'Saisie manuelle' },
    'btn.undo':          { de: 'Rückgängig',       fr: 'Annuler' },
    'title.remove':      { de: 'Entfernen',        fr: 'Supprimer' },
    'title.rename':      { de: 'Umbenennen',       fr: 'Renommer' },
    'title.delete':      { de: 'Löschen',          fr: 'Supprimer' },
    'title.edit':        { de: 'Bearbeiten',       fr: 'Modifier' },
    'app.title':        { de: 'Zeiterfassung',  fr: 'Saisie du temps' },
    'bis':              { de: 'bis',            fr: 'à' },
};

function t(key) {
    const entry = I18N[key];
    if (!entry) return key;
    return entry[appLang] || entry['de'] || key;
}

function toggleLang() {
    appLang = appLang === 'de' ? 'fr' : 'de';
    localStorage.setItem(APP_KEY + '_lang', appLang);
    translateUI();
    renderAll();
    updateLangBtn();
}

function updateLangBtn() {
    const btn = document.getElementById('langLabel');
    if (btn) btn.innerHTML = appLang === 'de'
        ? '<span class="lang-active">DE</span> | FR'
        : 'DE | <span class="lang-active">FR</span>';
}

function translateUI() {
    // Static HTML elements with data-t attribute
    document.querySelectorAll('[data-t]').forEach(el => {
        const key = el.getAttribute('data-t');
        const val = t(key);
        if (el.tagName === 'INPUT' || el.tagName === 'TEXTAREA') {
            el.placeholder = val;
        } else if (el.tagName === 'OPTION' && el.value === '') {
            el.textContent = val;
        } else {
            // Preserve innerHTML for elements with child nodes (e.g. nav tabs with emojis handled via t())
            el.textContent = val;
        }
    });
    document.querySelectorAll('[data-t-title]').forEach(el => {
        el.title = t(el.getAttribute('data-t-title'));
    });
    document.querySelectorAll('[data-t-html]').forEach(el => {
        el.innerHTML = t(el.getAttribute('data-t-html'));
    });
    // App title
    const titleEl = document.querySelector('.top-bar-title span:nth-child(2)');
    if (titleEl) titleEl.textContent = t('app.title');
    // Filter dropdown default options
    document.querySelectorAll('[data-t-option]').forEach(el => {
        const key = el.getAttribute('data-t-option');
        const opt = el.querySelector('option[value=""]');
        if (opt) opt.textContent = t(key);
    });
}
let db = null;

// Stammdaten (verwaltete Listen)
let masterData = {
    stakeholder: [],
    projekt: [],
    taetigkeit: []
};

// Alphabetische Sortierung aller Stammdaten-Listen
function sortMasterData() {
    const coll = new Intl.Collator('de', { sensitivity: 'base' });
    masterData.stakeholder.sort(coll.compare);
    masterData.projekt.sort(coll.compare);
    masterData.taetigkeit.sort(coll.compare);
}

// Zeiteinträge
let entries = [];

// Timer-Zustand
let timerState = {
    running: false,
    paused: false,
    startTime: null,
    lastTickTime: null,
    pausedTime: 0,
    elapsed: 0,
    interval: null
};

// Dashboard-Periode
let dashPeriod = 'week';
let dashNotizQuery = ''; // Notiz-Filtertext für Dashboard

// Task-Slots (persistente Task-Karten)
let taskSlots = [];
let activeSlotId = null;

// Aktiver Filter für Einträge
let activeFilter = { from: null, to: null };

// ============================================================
// INDEXEDDB MIT LOCALSTORAGE-FALLBACK
// ============================================================
function openDB() {
    return new Promise((resolve, reject) => {
        if (typeof indexedDB === 'undefined' || !indexedDB) { reject(new Error('No IndexedDB')); return; }
        const req = indexedDB.open('ZeiterfassungDB', 2);
        req.onupgradeneeded = (e) => {
            const d = e.target.result;
            if (!d.objectStoreNames.contains('master')) d.createObjectStore('master', { keyPath: 'key' });
            if (!d.objectStoreNames.contains('entries')) d.createObjectStore('entries', { keyPath: 'id' });
            if (!d.objectStoreNames.contains('teamConfig')) d.createObjectStore('teamConfig', { keyPath: 'key' });
        };
        req.onsuccess = () => { db = req.result; resolve(); };
        req.onerror = () => reject(req.error);
    });
}

function dbGet(store, key) {
    return new Promise((r, j) => { const q = db.transaction(store).objectStore(store).get(key); q.onsuccess = () => r(q.result); q.onerror = () => j(q.error); });
}
function dbPut(store, val) {
    return new Promise((r, j) => { const q = db.transaction(store, 'readwrite').objectStore(store).put(val); q.onsuccess = () => r(); q.onerror = () => j(q.error); });
}
function dbGetAll(store) {
    return new Promise((r, j) => { const q = db.transaction(store).objectStore(store).getAll(); q.onsuccess = () => r(q.result); q.onerror = () => j(q.error); });
}
function dbDelete(store, key) {
    return new Promise((r, j) => { const q = db.transaction(store, 'readwrite').objectStore(store).delete(key); q.onsuccess = () => r(); q.onerror = () => j(q.error); });
}
function dbClear(store) {
    return new Promise((r, j) => { const q = db.transaction(store, 'readwrite').objectStore(store).clear(); q.onsuccess = () => r(); q.onerror = () => j(q.error); });
}

// ============================================================
// SPEICHERN & LADEN
// ============================================================
async function saveAll() {
    // IMMER localStorage als Sicherheitskopie (synchron, sofort persistent)
    try {
        localStorage.setItem(APP_KEY + '_master', JSON.stringify(masterData));
        localStorage.setItem(APP_KEY + '_entries', JSON.stringify(entries));
    } catch(e) { console.warn('localStorage save error:', e); }

    if (db) {
        try {
            await dbPut('master', { key: 'masterData', value: masterData });
            // Einträge SICHER speichern: put statt clear+rewrite
            const tx = db.transaction('entries', 'readwrite');
            const store = tx.objectStore('entries');
            // Bestehende IDs ermitteln und nur Differenz löschen
            const existing = await new Promise(r => { const q = store.getAllKeys(); q.onsuccess = () => r(q.result); q.onerror = () => r([]); });
            const currentIds = new Set(entries.map(e => e.id));
            // Gelöschte entfernen
            for (const id of existing) { if (!currentIds.has(id)) store.delete(id); }
            // Alle aktuellen upserten (put = insert or update)
            entries.forEach(e => store.put(e));
            await new Promise((r, j) => { tx.oncomplete = r; tx.onerror = () => j(tx.error); });
        } catch(e) { console.error('IndexedDB saveAll error:', e); }
    }
}

async function saveMaster() {
    try { localStorage.setItem(APP_KEY + '_master', JSON.stringify(masterData)); } catch(e) {}
    if (db) {
        try { await dbPut('master', { key: 'masterData', value: masterData }); } catch(e) { console.error('saveMaster DB error:', e); }
    }
}

async function saveEntries() {
    // Sicherheitscheck: Nie speichern wenn entries leer aber DB Daten hat
    if (!entries.length && db) {
        try {
            const existing = await dbGetAll('entries');
            if (existing.length > 0) {
                console.warn('SAFETY: saveEntries() abgebrochen – entries ist leer aber DB hat', existing.length, 'Einträge.');
                entries = existing; // Daten wiederherstellen!
                return;
            }
        } catch(e) {}
    }

    // IMMER localStorage als Sicherheitskopie (synchron, atomar)
    try { localStorage.setItem(APP_KEY + '_entries', JSON.stringify(entries)); } catch(e) {}

    if (db) {
        try {
            const tx = db.transaction('entries', 'readwrite');
            const store = tx.objectStore('entries');
            // Bestehende IDs ermitteln
            const existing = await new Promise(r => { const q = store.getAllKeys(); q.onsuccess = () => r(q.result); q.onerror = () => r([]); });
            const currentIds = new Set(entries.map(e => e.id));
            // Nur gelöschte entfernen (statt ALLES löschen)
            for (const id of existing) { if (!currentIds.has(id)) store.delete(id); }
            // Alle aktuellen upserten
            entries.forEach(e => store.put(e));
            await new Promise((r, j) => { tx.oncomplete = r; tx.onerror = () => j(tx.error); });
        } catch(e) { console.error('IndexedDB saveEntries error:', e); }
    }
}

async function loadAll() {
    let dbEntries = [], lsEntries = [];
    let dbMaster = null, lsMaster = null;

    // 1. Versuche IndexedDB zu laden
    if (db) {
        try {
            const md = await dbGet('master', 'masterData');
            if (md && md.value) dbMaster = md.value;
            dbEntries = await dbGetAll('entries');
        } catch(e) { console.warn('IndexedDB load error:', e); }
    }

    // 2. Versuche localStorage zu laden (immer, als Fallback)
    try {
        const md = localStorage.getItem(APP_KEY + '_master');
        if (md) lsMaster = JSON.parse(md);
        const en = localStorage.getItem(APP_KEY + '_entries');
        if (en) lsEntries = JSON.parse(en);
    } catch(e) { console.warn('localStorage parse error:', e); }

    // 3. Beste Quelle wählen: die mit MEHR Daten gewinnt
    if (dbEntries.length >= lsEntries.length) {
        entries = dbEntries;
        masterData = dbMaster || lsMaster || masterData;
    } else {
        console.warn('localStorage hat mehr Einträge (' + lsEntries.length + ') als IndexedDB (' + dbEntries.length + ') — verwende localStorage.');
        entries = lsEntries;
        masterData = lsMaster || dbMaster || masterData;
        // IndexedDB nachsynchronisieren
        if (db && entries.length) {
            try {
                const tx = db.transaction('entries', 'readwrite');
                const store = tx.objectStore('entries');
                entries.forEach(e => store.put(e));
                await new Promise((r, j) => { tx.oncomplete = r; tx.onerror = () => j(tx.error); });
            } catch(e) {}
        }
    }

    // 4. Deduplizieren (falls Merge nötig war)
    const seen = new Set();
    entries = entries.filter(e => {
        if (!e.id || seen.has(e.id)) return false;
        seen.add(e.id);
        return true;
    });

    // Sicherstellen, dass masterData alle Felder hat
    if (!masterData.stakeholder) masterData.stakeholder = [];
    if (!masterData.projekt) masterData.projekt = [];
    if (!masterData.taetigkeit) masterData.taetigkeit = [];
    sortMasterData();
    // Einträge sanitisieren: durationMs immer als Number
    entries.forEach(e => {
        e.durationMs = Number(e.durationMs) || 0;
        if (e.stakeholder) e.stakeholder = e.stakeholder.trim();
        if (e.projekt) e.projekt = e.projekt.trim();
        if (e.taetigkeit) e.taetigkeit = e.taetigkeit.trim();
    });
}

// ============================================================
// INITIALISIERUNG
// ============================================================
document.addEventListener('DOMContentLoaded', async () => {
    // Theme laden
    const savedTheme = localStorage.getItem(APP_KEY + '_theme') || 'cyber';
    document.documentElement.setAttribute('data-theme', savedTheme);
    updateThemeBtn();

    // IndexedDB mit Timeout (iOS file:// Fallback)
    let dbOk = false;
    try {
        if (typeof indexedDB !== 'undefined' && indexedDB) {
            await Promise.race([openDB(), new Promise((_, rej) => setTimeout(() => rej(new Error('DB timeout')), 2000))]);
            dbOk = true;
        }
    } catch (e) { console.warn('IndexedDB nicht verfügbar, nutze localStorage:', e.message); }
    if (!dbOk) db = null;

    await loadAll();

    // Heutiges Datum als Standard für manuelle Eingabe
    const today = new Date().toISOString().slice(0, 10);
    document.getElementById('manualDate').value = today;

    // Task-Slots laden (persistent)
    try {
        const saved = localStorage.getItem(APP_KEY + '_taskSlots');
        if (saved) taskSlots = JSON.parse(saved);
    } catch(e) {}
    // Mindestens 1 leerer Slot
    if (!taskSlots.length) taskSlots.push(createEmptySlot());
    renderTaskSlots();

    // Filter-Defaults: aktueller Monat
    const y = new Date().getFullYear(), m = String(new Date().getMonth() + 1).padStart(2, '0');
    document.getElementById('filterFrom').value = `${y}-${m}-01`;
    document.getElementById('filterTo').value = today;

    renderAll();

    // Team-Konfiguration laden (Ordner-Handle + Name)
    await teamLoadConfig();

    // 🛡️ DSB initialisieren (Heartbeat, Auto-Save, Tab-Watcher, Integritätsprüfung)
    dsbInit();

    // Welcome-Screen nur wenn wirklich keine Daten (DSB Recovery läuft asynchron)
    const hasData = entries.length > 0 || masterData.stakeholder.length > 0 || masterData.projekt.length > 0 || masterData.taetigkeit.length > 0;
    if (!hasData && !dsbBestBackup()) {
        document.getElementById('welcomeModal').classList.add('open');
    }

    // Sprache initialisieren
    translateUI();
    updateLangBtn();

    // Nav indicator initialisieren
    requestAnimationFrame(() => initNavIndicator());

    // Quick-start rendern
    renderQuickStart();
});

// ============================================================
// AUTO-SAVE: Laufende Timer bei Tab-Schluss/Wechsel speichern
// ============================================================
function autoSaveRunningTimers() {
    // Nicht speichern während Split-Modal offen ist – saveSplitEntries übernimmt das
    if (document.getElementById('splitModal').classList.contains('open')) return false;

    flushTimerTick();
    let saved = 0;
    taskSlots.forEach(slot => {
        if (!slot.running) return;
        const total = slot.earnedMs || 0;
        if (total < 1000) return;
        if (!slot.sh || !slot.pr) return;

        const now = new Date();
        const realStartMs = slot.originalStartTime || (now.getTime() - total);
        const startDt = new Date(realStartMs);
        const startDay = formatDateISO(startDt);
        const endDay = formatDateISO(now);

        if (startDay !== endDay) {
            const midnight = new Date(now); midnight.setHours(0,0,0,0);
            const wallBefore = midnight.getTime() - realStartMs;
            const wallAfter = now.getTime() - midnight.getTime();
            const wallTotal = wallBefore + wallAfter;
            const msBefore = wallTotal > 0 ? Math.round(total * (wallBefore / wallTotal)) : 0;
            const msAfter = wallTotal > 0 ? total - msBefore : 0;
            if (msBefore > 1000) {
                entries.push({ id: generateId(), date: startDay, stakeholder: slot.sh, projekt: slot.pr, taetigkeit: slot.ta, notiz: slot.notiz || '', startTime: formatTime(startDt), endTime: '24:00', durationMs: msBefore });
            }
            if (msAfter > 1000) {
                entries.push({ id: generateId(), date: endDay, stakeholder: slot.sh, projekt: slot.pr, taetigkeit: slot.ta, notiz: slot.notiz || '', startTime: '00:00', endTime: formatTime(now), durationMs: msAfter });
            }
        } else {
            entries.push({ id: generateId(), date: startDay, stakeholder: slot.sh, projekt: slot.pr, taetigkeit: slot.ta, notiz: slot.notiz || '', startTime: formatTime(startDt), endTime: formatTime(now), durationMs: total });
        }
        slot.running = false; slot.paused = false; slot.earnedMs = 0; slot.originalStartTime = null;
        saved++;
    });
    if (saved) {
        // SYNCHRONE Sicherung in localStorage (überlebt Tab-Close)
        try { localStorage.setItem(APP_KEY + '_entries', JSON.stringify(entries)); } catch(e) {}
        // ASYNC Sicherung in IndexedDB (best effort)
        if (db) {
            try {
                const tx = db.transaction('entries', 'readwrite');
                const store = tx.objectStore('entries');
                entries.forEach(e => store.put(e));
                // Kein await möglich in beforeunload – fire and forget
            } catch(e) {}
        }
    }
    return saved > 0;
}

window.addEventListener('beforeunload', () => { autoSaveRunningTimers(); });
window.addEventListener('pagehide', () => { autoSaveRunningTimers(); });
// Freeze-Event (Mobile Safari, Chrome Tab-Discard)
if ('onfreeze' in document) { document.addEventListener('freeze', () => { autoSaveRunningTimers(); }); }

function renderAll() {
    populateDropdowns();
    populateFilterDropdowns();
    renderManageLists();
    renderEntries();
    renderDashboard();
    updateTodayTotal(0);
    updateDailyGoal();
    updateFabState();
    translateUI();
}

// ============================================================
// TASK-SLOT SYSTEM
// ============================================================
function createEmptySlot() {
    return { id: 'ts_' + Date.now() + '_' + Math.random().toString(36).slice(2,6),
             sh: '', pr: '', ta: '', notiz: '',
             running: false, paused: false, startTime: null, pausedTime: 0,
             originalStartTime: null, earnedMs: 0 };
}

function saveTaskSlots() {
    // Nur Konfiguration speichern, nicht laufende Timer-Zeiten
    const toSave = taskSlots.map(s => ({ id: s.id, sh: s.sh, pr: s.pr, ta: s.ta, notiz: s.notiz }));
    try { localStorage.setItem(APP_KEY + '_taskSlots', JSON.stringify(toSave)); } catch(e) {}
}

// Verteilt die seit dem letzten Tick vergangene Zeit auf alle aktiven Timer
function flushTimerTick() {
    const now = Date.now();
    const last = timerState.lastTickTime || now;
    const delta = now - last;
    timerState.lastTickTime = now;
    if (delta <= 0) return;
    const activeSlots = taskSlots.filter(s => s.running && !s.paused);
    if (!activeSlots.length) return;
    const share = delta / activeSlots.length;
    activeSlots.forEach(s => { s.earnedMs = (s.earnedMs || 0) + share; });
}

function getSlotElapsed(slot) {
    if (!slot.running) return 0;
    let total = slot.earnedMs || 0;
    // Anteil seit letztem Tick (für flüssige Anzeige)
    if (!slot.paused && timerState.lastTickTime) {
        const activeCount = taskSlots.filter(s => s.running && !s.paused).length;
        if (activeCount > 0) {
            const sinceLastTick = Date.now() - timerState.lastTickTime;
            total += sinceLastTick / activeCount;
        }
    }
    return total;
}

function addTaskSlot() {
    if (taskSlots.length >= 8) { showToast(t('toast.max8'), 'error'); return; }
    taskSlots.push(createEmptySlot());
    saveTaskSlots();
    renderTaskSlots();
}

async function removeTaskSlot(idx) {
    const slot = taskSlots[idx];
    if (slot.running) {
        // Laufenden Timer erst stoppen und speichern
        await stopSlotTimer(idx);
    }
    taskSlots.splice(idx, 1);
    if (!taskSlots.length) taskSlots.push(createEmptySlot());
    if (activeSlotId === slot.id) activeSlotId = null;
    saveTaskSlots();
    renderTaskSlots();
    updateGlobalTimerDisplay();
}

function updateSlotField(idx, field, value) {
    taskSlots[idx][field] = value;
    saveTaskSlots();
}

function toggleSlotTimer(idx) {
    const slot = taskSlots[idx];
    if (!slot.running) {
        startSlotTimer(idx);
    } else if (slot.paused) {
        resumeSlotTimer(idx);
    } else {
        pauseSlotTimer(idx);
    }
}

function startSlotTimer(idx) {
    const slot = taskSlots[idx];
    if (!slot.sh || !slot.pr) { showToast(t('toast.selectShPr'), 'error'); return; }

    // Erst aktuelle Verteilung abschliessen (Anzahl aktiver Timer ändert sich)
    flushTimerTick();

    slot.running = true;
    slot.paused = false;
    slot.startTime = Date.now();
    slot.pausedTime = 0;
    slot.originalStartTime = Date.now();
    slot.earnedMs = 0;
    activeSlotId = slot.id;

    // Globalen Display-Ticker starten
    if (!timerState.interval) {
        timerState.lastTickTime = Date.now();
        timerState.interval = setInterval(tickTimers, 500);
    }
    timerState.running = true;

    renderTaskSlots();
    updateGlobalTimerDisplay();
    updateNavDot('running');
    updateFabState();
}

function pauseSlotTimer(idx) {
    const slot = taskSlots[idx];
    // Erst aktuelle Verteilung abschliessen (Anzahl aktiver Timer ändert sich)
    flushTimerTick();
    slot.paused = true;
    activeSlotId = slot.id;

    renderTaskSlots();
    updateGlobalTimerDisplay();

    // Prüfe ob noch ein Timer aktiv (nicht pausiert) ist
    const anyActive = taskSlots.some(s => s.running && !s.paused);
    updateNavDot(anyActive ? 'running' : 'paused');
}

function resumeSlotTimer(idx) {
    const slot = taskSlots[idx];
    // Erst aktuelle Verteilung abschliessen (Anzahl aktiver Timer ändert sich)
    flushTimerTick();
    slot.paused = false;
    slot.startTime = Date.now();
    activeSlotId = slot.id;

    if (!timerState.interval) {
        timerState.lastTickTime = Date.now();
        timerState.interval = setInterval(tickTimers, 500);
    }
    timerState.running = true;

    renderTaskSlots();
    updateGlobalTimerDisplay();
    updateNavDot('running');
}

async function stopSlotTimer(idx) {
    const slot = taskSlots[idx];
    if (!slot.running) return;

    // Erst aktuelle Verteilung abschliessen
    flushTimerTick();

    const total = slot.earnedMs || 0;
    slot.running = false;
    slot.paused = false;

    // Echte Startzeit merken, dann Slot zurücksetzen
    const realStartMs = slot.originalStartTime || (Date.now() - total);
    slot.pausedTime = 0;
    slot.startTime = null;
    slot.originalStartTime = null;
    slot.earnedMs = 0;

    if (total < 1000) {
        showToast(t('toast.tooShort'), 'error');
        renderTaskSlots();
        updateGlobalTimerDisplay();
        return;
    }

    const now = new Date();
    const startDt = new Date(realStartMs);

    // Prüfe ob Timer über Mitternacht lief
    const startDay = formatDateISO(startDt);
    const endDay = formatDateISO(now);

    if (startDay !== endDay) {
        // Über Mitternacht → 2 Einträge für korrekte Tages-Auswertung
        const midnight = new Date(now);
        midnight.setHours(0, 0, 0, 0);
        const wallBefore = midnight.getTime() - realStartMs;
        const wallAfter = now.getTime() - midnight.getTime();
        const wallTotal = wallBefore + wallAfter;
        // Aktive Arbeitszeit proportional auf beide Tage verteilen
        const msBefore = wallTotal > 0 ? Math.round(total * (wallBefore / wallTotal)) : 0;
        const msAfter = wallTotal > 0 ? total - msBefore : 0;

        if (msBefore > 1000) {
            entries.push({
                id: generateId(), date: startDay,
                stakeholder: slot.sh, projekt: slot.pr, taetigkeit: slot.ta,
                notiz: slot.notiz || '',
                startTime: formatTime(startDt), endTime: '24:00',
                durationMs: msBefore
            });
        }
        if (msAfter > 1000) {
            entries.push({
                id: generateId(), date: endDay,
                stakeholder: slot.sh, projekt: slot.pr, taetigkeit: slot.ta,
                notiz: slot.notiz || '',
                startTime: '00:00', endTime: formatTime(now),
                durationMs: msAfter
            });
        }
    } else {
        // Normaler Eintrag (kein Mitternachts-Split)
        entries.push({
            id: generateId(),
            date: startDay,
            stakeholder: slot.sh, projekt: slot.pr, taetigkeit: slot.ta,
            notiz: slot.notiz || '',
            startTime: formatTime(startDt), endTime: formatTime(now),
            durationMs: total
        });
    }

    await saveEntries();
    renderEntries();
    renderDashboard();
    renderTaskSlots();
    updateGlobalTimerDisplay();
    showToast(`${formatDuration(total)} ${t('toast.saved')} (${slot.sh} / ${slot.pr})${startDay !== endDay ? ' — ' + t('toast.midnight2') : ''}.`, 'success');

    // Prüfe ob noch Timer laufen
    const anyRunning = taskSlots.some(s => s.running);
    if (!anyRunning) {
        clearInterval(timerState.interval);
        timerState.interval = null;
        timerState.running = false;
        timerState.lastTickTime = null;
        updateNavDot('off');
    } else {
        const anyActive = taskSlots.some(s => s.running && !s.paused);
        updateNavDot(anyActive ? 'running' : 'paused');
    }
    updateDailyGoal();
    updateFabState();
    // Heartbeat sofort aktualisieren (löscht wenn keine Timer mehr laufen)
    dsbHeartbeat();
}

// Zentraler Tick – aktualisiert alle laufenden Slot-Anzeigen + globalen Timer
function tickTimers() {
    // Proportionale Verteilung der vergangenen Zeit
    flushTimerTick();

    let totalRunningMs = 0;
    let anyRunning = false;

    taskSlots.forEach((slot, idx) => {
        if (!slot.running) return;
        anyRunning = true;
        const elapsed = getSlotElapsed(slot);
        totalRunningMs += elapsed;

        // Slot-Timer-Anzeige aktualisieren
        const elEl = document.getElementById('tsElapsed_' + idx);
        if (elEl) elEl.textContent = formatDuration(elapsed);
    });

    if (!anyRunning) {
        clearInterval(timerState.interval);
        timerState.interval = null;
        timerState.running = false;
        updateNavDot('off');
        document.title = 'Zeiterfassung';
        document.getElementById('timerDisplay').textContent = '00:00:00';
        document.getElementById('timerLabel').textContent = t('timer.ready');
        document.getElementById('timerProgress').style.strokeDashoffset = '628.32';
        return;
    }

    // Globaler Display: Zeige aktiven (zuletzt angeklickten) Slot
    const activeSlot = taskSlots.find(s => s.id === activeSlotId && s.running);
    const displayMs = activeSlot ? getSlotElapsed(activeSlot) : totalRunningMs;

    document.getElementById('timerDisplay').textContent = formatDuration(displayMs);
    document.title = formatDuration(displayMs) + ' – Zeiterfassung';

    const label = activeSlot ? `${activeSlot.sh} / ${activeSlot.pr}` : t('timer.multipleTasks');
    document.getElementById('timerLabel').textContent = label;
    document.getElementById('timerStatus').textContent = label;
    document.getElementById('timerStatus').className = 'timer-status active';

    // Fortschrittsring
    const circumference = 2 * Math.PI * 94;
    const pct = (displayMs / 3600000) % 1;
    document.getElementById('timerProgress').style.strokeDashoffset = circumference * (1 - pct);

    updateTodayTotal(totalRunningMs);
    updateDailyGoal();
    updateFabState();
}

function updateGlobalTimerDisplay() {
    const anyRunning = taskSlots.some(s => s.running);
    const splitBtn = document.getElementById('btnSplit');
    const stopAllBtn = document.getElementById('btnStopAll');

    if (!anyRunning) {
        document.getElementById('timerDisplay').textContent = '00:00:00';
        document.getElementById('timerLabel').textContent = t('timer.ready');
        document.getElementById('timerStatus').textContent = t('timer.startHint');
        document.getElementById('timerStatus').className = 'timer-status idle';
        document.getElementById('timerProgress').style.strokeDashoffset = '628.32';
        document.title = 'Zeiterfassung';
        splitBtn.disabled = true;
        stopAllBtn.disabled = true;
        updateTodayTotal(0);
    } else {
        splitBtn.disabled = false;
        stopAllBtn.disabled = false;
    }
}

// Feierabend: Alle laufenden Timer stoppen & speichern
async function stopAllTimers() {
    const running = taskSlots.filter(s => s.running);
    if (!running.length) return;
    if (running.length > 1 && !confirm(`${running.length} ${t('toast.confirmStopMulti')}`)) return;

    let totalSaved = 0;
    // Rückwärts iterieren, da stopSlotTimer den Zustand ändert
    for (let i = taskSlots.length - 1; i >= 0; i--) {
        if (taskSlots[i].running) {
            await stopSlotTimer(i);
            totalSaved++;
        }
    }
}

function renderTaskSlots() {
    const container = document.getElementById('taskSlotList');
    container.innerHTML = taskSlots.map((slot, idx) => {
        const isActive = slot.running && !slot.paused;
        const isPaused = slot.running && slot.paused;
        const stateClass = isActive ? 'active' : isPaused ? 'paused' : '';
        const elapsed = getSlotElapsed(slot);
        const playIcon = isActive ? '⏸' : '▶';
        const playClass = isActive ? 'running' : isPaused ? 'paused' : '';
        const statusText = isActive ? t('timer.running') : isPaused ? t('timer.paused') : '';
        const dis = '';
        const hideAdd = '';

        return `
        <div class="task-slot ${stateClass}">
            <div class="ts-header">
                <button class="ts-play-btn ${playClass}" onclick="toggleSlotTimer(${idx})" title="${isActive ? t('ts.pause') : t('ts.start')}">${playIcon}</button>
                <button class="ts-stop-btn" onclick="stopSlotTimer(${idx})" title="${t('ts.stopSave')}">■</button>
                <span class="ts-elapsed" id="tsElapsed_${idx}">${slot.running ? formatDuration(elapsed) : ''}</span>
                <span class="ts-status">${statusText}</span>
                <span class="ts-spacer"></span>
                <button class="ts-remove-btn" onclick="removeTaskSlot(${idx})" title="${t('ts.remove')}">✕</button>
            </div>
            <div class="ts-fields">
                <div class="field-with-add">
                    <select class="form-select" onchange="updateSlotField(${idx},'sh',this.value)"${dis}>
                        <option value="">${t('ph.stakeholder')}</option>
                        ${masterData.stakeholder.map(s => `<option value="${esc(s)}"${s === slot.sh ? ' selected' : ''}>${esc(s)}</option>`).join('')}
                    </select>
                    <button class="inline-add-btn" onclick="inlineAddForSlot(${idx},'stakeholder','sh')" title="${t('title.newSh')}"${hideAdd}>+</button>
                </div>
                <div class="field-with-add">
                    <select class="form-select" onchange="updateSlotField(${idx},'pr',this.value)"${dis}>
                        <option value="">${t('ph.projekt')}</option>
                        ${masterData.projekt.map(p => `<option value="${esc(p)}"${p === slot.pr ? ' selected' : ''}>${esc(p)}</option>`).join('')}
                    </select>
                    <button class="inline-add-btn" onclick="inlineAddForSlot(${idx},'projekt','pr')" title="${t('title.newPr')}"${hideAdd}>+</button>
                </div>
                <div class="field-with-add">
                    <select class="form-select" onchange="updateSlotField(${idx},'ta',this.value)"${dis}>
                        <option value="">${t('ph.taetigkeit')}</option>
                        ${masterData.taetigkeit.map(ta => `<option value="${esc(ta)}"${ta === slot.ta ? ' selected' : ''}>${esc(ta)}</option>`).join('')}
                    </select>
                    <button class="inline-add-btn" onclick="inlineAddForSlot(${idx},'taetigkeit','ta')" title="${t('title.newTa')}"${hideAdd}>+</button>
                </div>
            </div>
            <input type="text" class="ts-notiz" placeholder="Notiz (optional)" data-t="ph.notiz" value="${esc(slot.notiz || '')}"
                onchange="updateSlotField(${idx},'notiz',this.value)" oninput="taskSlots[${idx}].notiz=this.value"
                list="notizSuggestions" onfocus="updateNotizDatalist(taskSlots[${idx}].sh, taskSlots[${idx}].pr)">
        </div>`;
    }).join('');
}

// Inline-Add speziell für Task-Slots: fügt hinzu UND setzt den Wert im Slot
function inlineAddForSlot(idx, type, field) {
    const name = inlineAdd(type);
    if (name) {
        taskSlots[idx][field] = name;
        saveTaskSlots();
        renderTaskSlots();
    }
}

// Inline-Add für manuellen Eintrag: fügt hinzu UND wählt im Dropdown aus
function inlineAddForManual(type, selectId) {
    const name = inlineAdd(type);
    if (name) {
        const sel = document.getElementById(selectId);
        if (sel) sel.value = name;
    }
}

// ============================================================
// SPLIT-BUCHUNG
// ============================================================
let splitState = { totalMs: 0, startDt: null, endDt: null, rows: [] };

function openSplitModal() {
    // Sammle alle laufenden Timer
    const running = taskSlots.filter(s => s.running);
    if (!running.length) { showToast(t('toast.noTimer'), 'error'); return; }

    // Aktuelle Verteilung abschliessen
    flushTimerTick();
    const now = new Date();

    // Wanduhrzeit: vom frühesten echten Start bis jetzt
    const earliestStart = running.reduce((min, s) => {
        const orig = s.originalStartTime || s.startTime - (s.pausedTime || 0);
        return orig < min ? orig : min;
    }, Infinity);
    let totalMs = now.getTime() - earliestStart;

    if (totalMs < 1000) { showToast(t('toast.tooShort2'), 'error'); return; }

    // Individuelle aktive Zeiten für prozentuale Gewichtung
    const elapsedPerSlot = running.map(s => getSlotElapsed(s));
    const elapsedSum = elapsedPerSlot.reduce((a, b) => a + b, 0);

    splitState = { totalMs, startDt: new Date(earliestStart), endDt: now, rows: [], runningSlotIds: running.map(s => s.id) };
    document.getElementById('splitTotalTime').textContent = formatDuration(totalMs);

    // Zeilen aus laufenden Tasks vorbelegen — gewichtet nach aktiver Zeit
    document.getElementById('splitRows').innerHTML = '';
    splitState.rows = [];

    if (running.length === 1) {
        addSplitRow(running[0].sh, running[0].pr, running[0].ta, 100);
    } else {
        let usedPct = 0;
        running.forEach((s, i) => {
            let pct;
            if (i < running.length - 1) {
                pct = elapsedSum > 0 ? Math.round(elapsedPerSlot[i] / elapsedSum * 100) : Math.floor(100 / running.length);
                usedPct += pct;
            } else {
                pct = 100 - usedPct;
            }
            addSplitRow(s.sh, s.pr, s.ta, pct);
        });
    }

    updateSplitAllocation();
    document.getElementById('splitModal').classList.add('open');
}

function addSplitRow(sh, pr, ta, pct) {
    const idx = splitState.rows.length;
    if (idx >= 6) { showToast('Maximal 6 Aufteilungen.', 'error'); return; }

    if (pct === undefined) {
        const n = splitState.rows.length + 1;
        const even = Math.floor(100 / n);
        splitState.rows.forEach(r => { r.pct = even; });
        pct = 100 - even * (n - 1);
    }

    splitState.rows.push({ sh: sh || '', pr: pr || '', ta: ta || '', pct: pct });
    renderSplitRows();
    updateSplitAllocation();
}

function renderSplitRows() {
    const container = document.getElementById('splitRows');
    container.innerHTML = splitState.rows.map((row, i) => {
        const dur = Math.round(splitState.totalMs * row.pct / 100);
        const canRemove = splitState.rows.length > 1;
        return `
        <div class="split-row">
            <div class="form-group">
                <label class="form-label" data-t="label.stakeholder">Stakeholder</label>
                <select class="form-select" onchange="splitState.rows[${i}].sh=this.value">
                    <option value="">${t('ph.select')}</option>
                    ${masterData.stakeholder.map(s => `<option value="${esc(s)}"${s === row.sh ? ' selected' : ''}>${esc(s)}</option>`).join('')}
                </select>
            </div>
            <div class="form-group">
                <label class="form-label" data-t="label.projekt">Projekt</label>
                <select class="form-select" onchange="splitState.rows[${i}].pr=this.value">
                    <option value="">${t('ph.select')}</option>
                    ${masterData.projekt.map(p => `<option value="${esc(p)}"${p === row.pr ? ' selected' : ''}>${esc(p)}</option>`).join('')}
                </select>
            </div>
            <div class="form-group">
                <label class="form-label">${t('label.taetigkeit')}</label>
                <select class="form-select" onchange="splitState.rows[${i}].ta=this.value">
                    <option value="">${t('ph.select')}</option>
                    ${masterData.taetigkeit.map(ta => `<option value="${esc(ta)}"${ta === row.ta ? ' selected' : ''}>${esc(ta)}</option>`).join('')}
                </select>
            </div>
            <div class="split-pct-wrap">
                <label class="form-label">${t('label.anteil')}</label>
                <input type="number" class="split-pct-input" value="${row.pct}" min="1" max="100"
                    onchange="updateSplitPct(${i}, this.value)" oninput="updateSplitPct(${i}, this.value)">
                <div class="split-pct-dur">${formatDurationHM(dur)}</div>
            </div>
            <button class="split-remove-btn" onclick="removeSplitRow(${i})" title="${t('title.remove')}"${canRemove ? '' : ' disabled style="opacity:0.2;cursor:default"'}>✕</button>
        </div>`;
    }).join('');
}

function updateSplitPct(idx, val) {
    const newPct = Math.max(1, Math.min(99, parseInt(val) || 0));
    splitState.rows[idx].pct = newPct;

    const others = splitState.rows.filter((_, i) => i !== idx);
    if (others.length > 0) {
        const remaining = 100 - newPct;
        const oldOtherSum = others.reduce((s, r) => s + r.pct, 0);
        if (oldOtherSum > 0) {
            let distributed = 0;
            others.forEach((r, i) => {
                if (i < others.length - 1) {
                    r.pct = Math.max(1, Math.round(r.pct / oldOtherSum * remaining));
                    distributed += r.pct;
                } else {
                    r.pct = Math.max(1, remaining - distributed);
                }
            });
        } else {
            const each = Math.floor(remaining / others.length);
            others.forEach((r, i) => {
                r.pct = i < others.length - 1 ? each : remaining - each * (others.length - 1);
            });
        }
    }

    const inputs = document.querySelectorAll('.split-pct-input');
    const durs = document.querySelectorAll('.split-pct-dur');
    splitState.rows.forEach((r, i) => {
        if (inputs[i] && i !== idx) inputs[i].value = r.pct;
        if (durs[i]) durs[i].textContent = formatDurationHM(Math.round(splitState.totalMs * r.pct / 100));
    });
    updateSplitAllocation();
}

function removeSplitRow(idx) {
    if (splitState.rows.length <= 1) return;
    const removed = splitState.rows.splice(idx, 1)[0];
    const extra = Math.floor(removed.pct / splitState.rows.length);
    splitState.rows.forEach(r => r.pct += extra);
    const sum = splitState.rows.reduce((s, r) => s + r.pct, 0);
    if (sum < 100) splitState.rows[0].pct += 100 - sum;
    renderSplitRows();
    updateSplitAllocation();
}

function updateSplitAllocation() {
    const total = splitState.rows.reduce((s, r) => s + r.pct, 0);
    const bar = document.getElementById('splitAllocBar');
    const rem = document.getElementById('splitRemaining');
    const saveBtn = document.getElementById('splitSaveBtn');

    bar.innerHTML = splitState.rows.map((r, i) => {
        const w = Math.max(r.pct / Math.max(total, 100) * 100, 1);
        return `<div class="split-alloc-seg bar-fill ${BAR_COLORS[i % 6]}" style="width:${w}%"></div>`;
    }).join('');

    if (total === 100) {
        rem.textContent = t('split.complete');
        rem.className = 'split-remaining ok';
        saveBtn.disabled = false;
    } else if (total > 100) {
        rem.textContent = `${total}${t('split.tooMuch').replace('{n}', total - 100)}`;
        rem.className = 'split-remaining over';
        saveBtn.disabled = true;
    } else {
        rem.textContent = `${total}${t('split.remaining').replace('{n}', 100 - total)}`;
        rem.className = 'split-remaining under';
        saveBtn.disabled = true;
    }
}

function saveSplitEntries() {
    const total = splitState.rows.reduce((s, r) => s + r.pct, 0);
    if (total !== 100) { showToast('Bitte genau 100% verteilen.', 'error'); return; }

    for (let i = 0; i < splitState.rows.length; i++) {
        if (!splitState.rows[i].sh || !splitState.rows[i].pr) {
            showToast(`${t('csv.datum')} ${i + 1}: ${t('toast.splitRow')}`, 'error');
            return;
        }
    }

    // 1. Split-Einträge erstellen
    let runningStart = splitState.startDt;
    splitState.rows.forEach((r, i) => {
        const ms = Math.round(splitState.totalMs * r.pct / 100);
        const entryEnd = new Date(runningStart.getTime() + ms);
        entries.push({
            id: generateId(),
            date: formatDateISO(runningStart),
            stakeholder: r.sh, projekt: r.pr, taetigkeit: r.ta,
            notiz: `Split ${i + 1}/${splitState.rows.length} (${r.pct}%)`,
            startTime: formatTime(runningStart), endTime: formatTime(entryEnd),
            durationMs: ms
        });
        runningStart = entryEnd;
    });
    saveEntries();

    // 2. Snapshot: welche Slots sollen weiterlaufen?
    const restartIds = (splitState.runningSlotIds || []).slice();

    // 3. Alle Timer komplett stoppen (OHNE Einträge zu erstellen)
    if (timerState.interval) { clearInterval(timerState.interval); timerState.interval = null; }
    timerState.running = false;
    timerState.lastTickTime = null;
    taskSlots.forEach(s => {
        s.running = false;
        s.paused = false;
        s.startTime = null;
        s.pausedTime = 0;
        s.originalStartTime = null;
        s.earnedMs = 0;
    });

    // 4. Modal schliessen, UI aktualisieren im gestoppten Zustand
    document.getElementById('splitModal').classList.remove('open');
    renderEntries();
    renderDashboard();

    // 5. Timer NACH dem Rendering sauber neu starten (wie frischer Start)
    const now = Date.now();
    taskSlots.forEach(s => {
        if (restartIds.includes(s.id)) {
            s.running = true;
            s.paused = false;
            s.startTime = now;
            s.pausedTime = 0;
            s.originalStartTime = now;
            s.earnedMs = 0;
            activeSlotId = s.id;
        }
    });

    // 6. Interval starten, rendern, sofort ticken
    timerState.lastTickTime = Date.now();
    timerState.running = true;
    timerState.interval = setInterval(tickTimers, 500);
    renderTaskSlots();
    updateGlobalTimerDisplay();
    updateNavDot('running');
    tickTimers();

    showToast(`✂ ${splitState.rows.length} ${t('toast.splitSaved')}`, 'success');
}

function closeSplitModal() {
    document.getElementById('splitModal').classList.remove('open');
}

function updateNavDot(state) {
    const dot = document.getElementById('navTimerDot');
    dot.className = 'timer-dot' + (state === 'running' ? ' running' : state === 'paused' ? ' paused' : '');
    // Timer-Ring Glow-Effekt
    const circle = document.querySelector('.timer-circle');
    if (circle) {
        circle.classList.toggle('running', state === 'running');
        circle.classList.toggle('paused', state === 'paused');
    }
}

function updateTodayTotal(runningMs) {
    const today = formatDateISO(new Date());
    const savedMs = entries.filter(e => e.date === today).reduce((s, e) => s + (Number(e.durationMs) || 0), 0);
    const totalMs = savedMs + (runningMs || 0);
    document.getElementById('todayTotalDisplay').textContent = formatDurationHM(totalMs, '0:00');
}

// ============================================================
// INLINE-ADD: Neuen Eintrag direkt aus Dropdown-Nähe hinzufügen
// ============================================================
function inlineAdd(type) {
    const label = type === 'stakeholder' ? t('manage.labelSh') : type === 'projekt' ? t('manage.labelPr') : t('manage.labelTa');
    const val = prompt(t('prompt.addNew').replace('{label}', label));
    if (!val || !val.trim()) return;
    const name = val.trim();
    if (masterData[type].includes(name)) { showToast(`"${name}" ${t('toast.duplicate')}`, 'error'); return; }
    masterData[type].push(name);
    sortMasterData();
    saveMaster();
    populateDropdowns();
    renderManageLists();
    showToast(`"${name}" ${t('toast.added')}`, 'success');
    return name;
}

// ============================================================
// DROPDOWNS
// ============================================================
function populateDropdowns() {
    // Manual entry dropdowns
    populateSelect('manualStakeholder', masterData.stakeholder);
    populateSelect('manualProjekt', masterData.projekt);
    populateSelect('manualTaetigkeit', masterData.taetigkeit);
    // Edit-Modal-Dropdowns
    populateSelect('editStakeholder', masterData.stakeholder);
    populateSelect('editProjekt', masterData.projekt);
    populateSelect('editTaetigkeit', masterData.taetigkeit);
    // Task-Slots neu rendern (haben eigene Dropdowns)
    renderTaskSlots();
}

function populateSelect(id, items) {
    const sel = document.getElementById(id);
    if (!sel) return;
    const current = sel.value;
    sel.innerHTML = '<option value="">' + t('ph.select') + '</option>' + items.map(i => `<option value="${esc(i)}">${esc(i)}</option>`).join('');
    if (items.includes(current)) sel.value = current;
}

// ============================================================
// MANUELLER EINTRAG
// ============================================================
function saveManualEntry() {
    const sh = document.getElementById('manualStakeholder').value;
    const pr = document.getElementById('manualProjekt').value;
    const ta = document.getElementById('manualTaetigkeit').value;
    const date = document.getElementById('manualDate').value;
    const start = document.getElementById('manualStart').value;
    const end = document.getElementById('manualEnd').value;

    if (!sh || !pr) { showToast(t('toast.selectShPr'), 'error'); return; }
    if (!date) { showToast(t('toast.selectDate'), 'error'); return; }
    if (!start || !end) { showToast(t('toast.selectTime'), 'error'); return; }

    const [sh1, sm1] = start.split(':').map(Number);
    const [eh1, em1] = end.split(':').map(Number);
    let startMin = sh1 * 60 + sm1;
    let endMin = eh1 * 60 + em1;

    // Mitternachts-Überschreitung: z.B. 23:00 – 01:00
    if (endMin <= startMin) {
        const beforeMidnight = 24 * 60 - startMin;
        const afterMidnight = endMin;
        const nextDate = new Date(date + 'T12:00:00');
        nextDate.setDate(nextDate.getDate() + 1);
        const nextDateStr = formatDateISO(nextDate);
        const notiz = (document.getElementById('manualNotiz').value || '').trim();

        if (beforeMidnight > 0) {
            entries.push({ id: generateId(), date: date, stakeholder: sh, projekt: pr, taetigkeit: ta, notiz, startTime: start, endTime: '24:00', durationMs: beforeMidnight * 60000 });
        }
        if (afterMidnight > 0) {
            entries.push({ id: generateId(), date: nextDateStr, stakeholder: sh, projekt: pr, taetigkeit: ta, notiz, startTime: '00:00', endTime: end, durationMs: afterMidnight * 60000 });
        }
        const totalMin = beforeMidnight + afterMidnight;
        saveEntries(); renderEntries(); renderDashboard();
        document.getElementById('manualStart').value = '';
        document.getElementById('manualEnd').value = '';
        document.getElementById('manualNotiz').value = '';
        showToast(`${formatDuration(totalMin * 60000)} ${t('toast.midnightManual')}`, 'success');
        return;
    }

    let durationMin = endMin - startMin;
    if (durationMin <= 0) { showToast(t('toast.endAfterStart'), 'error'); return; }

    const entry = {
        id: generateId(),
        date: date,
        stakeholder: sh, projekt: pr, taetigkeit: ta,
        notiz: (document.getElementById('manualNotiz').value || '').trim(),
        startTime: start, endTime: end,
        durationMs: durationMin * 60 * 1000
    };

    entries.push(entry);
    saveEntries();
    renderEntries();
    renderDashboard();

    document.getElementById('manualStart').value = '';
    document.getElementById('manualEnd').value = '';
    document.getElementById('manualNotiz').value = '';
    showToast(`${formatDuration(entry.durationMs)} ${t('toast.manualOk')}`, 'success');
}

// ============================================================
// VIEW-SWITCHING
// ============================================================
function switchView(name) {
    document.querySelectorAll('.view').forEach(v => v.classList.remove('active'));
    document.querySelectorAll('.nav-tab').forEach(t => t.classList.remove('active'));
    document.querySelectorAll('.bnav-item').forEach(t => t.classList.remove('active'));
    document.getElementById('view-' + name).classList.add('active');
    const viewNames = ['timer','entries','dashboard','manage','team'];
    const idx = viewNames.indexOf(name);
    const tabs = document.querySelectorAll('.nav-tab');
    const bnavItems = document.querySelectorAll('.bnav-item');
    if (tabs[idx]) { tabs[idx].classList.add('active'); updateNavIndicator(tabs[idx]); }
    if (bnavItems[idx]) bnavItems[idx].classList.add('active');
    if (name === 'entries') renderEntries();
    if (name === 'dashboard') renderDashboard();
    if (name === 'manage') renderManageLists();
    if (name === 'team') teamOnViewOpen();
    if (name === 'timer') renderQuickStart();
    // Scroll to top on view switch
    window.scrollTo({ top: 0, behavior: 'smooth' });
}

// Animated nav indicator
function updateNavIndicator(activeTab) {
    const indicator = document.getElementById('navIndicator');
    const navBar = document.getElementById('navBar');
    if (!indicator || !navBar || !activeTab) return;
    const navRect = navBar.getBoundingClientRect();
    const tabRect = activeTab.getBoundingClientRect();
    indicator.style.left = (tabRect.left - navRect.left + navBar.scrollLeft) + 'px';
    indicator.style.width = tabRect.width + 'px';
}

// Init nav indicator on load
function initNavIndicator() {
    const activeTab = document.querySelector('.nav-tab.active');
    if (activeTab) {
        const indicator = document.getElementById('navIndicator');
        if (indicator) indicator.style.transition = 'none';
        updateNavIndicator(activeTab);
        requestAnimationFrame(() => {
            if (indicator) indicator.style.transition = '';
        });
    }
}

// ============================================================
// THEME TOGGLE
// ============================================================
// Hamburger Menu
function toggleHamMenu(e) {
    e && e.stopPropagation();
    const m = document.getElementById('hamMenu');
    m.classList.toggle('open');
    if (m.classList.contains('open')) {
        setTimeout(() => document.addEventListener('click', _closeHamOnDoc, { once: true }), 50);
    }
}
function _closeHamOnDoc(e) {
    const m = document.getElementById('hamMenu');
    if (m && !m.contains(e.target)) closeHamMenu();
    else if (m && m.classList.contains('open')) {
        setTimeout(() => document.addEventListener('click', _closeHamOnDoc, { once: true }), 10);
    }
}
function closeHamMenu() {
    document.getElementById('hamMenu').classList.remove('open');
}

// Header Folder Button — smart: sync if connected, else switch to Team view
function headerFolderAction() {
    if (typeof teamDirHandle !== 'undefined' && teamDirHandle && teamName) {
        teamSync();
    } else {
        switchView('team');
    }
}

function toggleTheme() {
    const current = document.documentElement.getAttribute('data-theme');
    const next = current === 'cyber' ? 'light' : 'cyber';
    document.documentElement.setAttribute('data-theme', next);
    localStorage.setItem(APP_KEY + '_theme', next);
    updateThemeBtn();
}
function updateThemeBtn() {
    const isCyber = document.documentElement.getAttribute('data-theme') === 'cyber';
    document.getElementById('themeIcon').innerHTML = isCyber
        ? '<svg viewBox="0 0 24 24"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>'
        : '<svg viewBox="0 0 24 24"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"/></svg>';
}

// ============================================================
// STAMMDATEN-VERWALTUNG
// ============================================================
function addItem(type) {
    const input = document.getElementById('add' + capitalize(type));
    const val = input.value.trim();
    if (!val) return;
    if (masterData[type].includes(val)) { showToast('Existiert bereits.', 'error'); return; }
    masterData[type].push(val);
    sortMasterData();
    input.value = '';
    saveMaster();
    renderManageLists();
    populateDropdowns();
    showToast(`"${val}" ${t('toast.added')}`, 'success');
}

function removeItem(type, idx) {
    const name = masterData[type][idx];
    if (!confirm(`"${name}" ${t('confirm.deleteItem')}`)) return;
    masterData[type].splice(idx, 1);
    saveMaster();
    renderManageLists();
    populateDropdowns();
    showToast(`"${name}" ${t('manage.deleted')}`);
}

function renameItem(type, idx) {
    const old = masterData[type][idx];
    const val = prompt(t('prompt.rename'), old);
    if (!val || val.trim() === old) return;
    const newName = val.trim();
    const field = type === 'stakeholder' ? 'stakeholder' : type === 'projekt' ? 'projekt' : 'taetigkeit';
    entries.forEach(e => { if (e[field] === old) e[field] = newName; });
    // Auch Task-Slots aktualisieren
    const slotField = field === 'stakeholder' ? 'sh' : field === 'projekt' ? 'pr' : 'ta';
    taskSlots.forEach(s => { if (s[slotField] === old) s[slotField] = newName; });
    masterData[type][idx] = newName;
    sortMasterData();
    saveMaster();
    saveEntries();
    saveTaskSlots();
    renderManageLists();
    populateDropdowns();
    renderEntries();
    showToast(`${t('toast.renamed')} "${newName}".`, 'success');
}

function renderManageLists() {
    ['stakeholder', 'projekt', 'taetigkeit'].forEach(type => {
        const list = document.getElementById('list' + capitalize(type));
        if (!list) return;
        if (!masterData[type].length) {
            list.innerHTML = `<li class="manage-item" style="color:var(--text-muted); font-style:italic;">${t('manage.noEntries')}</li>`;
            return;
        }
        list.innerHTML = masterData[type].map((name, i) => `
            <li class="manage-item">
                <span class="item-name">${esc(name)}</span>
                <span class="item-actions">
                    <button class="entry-btn" onclick="renameItem('${type}',${i})" title="${t('title.rename')}">✏️</button>
                    <button class="entry-btn delete" onclick="removeItem('${type}',${i})" title="${t('title.delete')}">🗑️</button>
                </span>
            </li>
        `).join('');
    });
}


// ============================================================
// EINTRÄGE-ANSICHT
// ============================================================
let _entryNotizTimer = null;
function onEntryNotizFilter() {
    clearTimeout(_entryNotizTimer);
    _entryNotizTimer = setTimeout(() => renderEntries(), 250);
}

function populateFilterDropdowns() {
    const shSet = [...new Set(entries.map(e => e.stakeholder).filter(Boolean))].sort();
    const prSet = [...new Set(entries.map(e => e.projekt).filter(Boolean))].sort();
    const taSet = [...new Set(entries.map(e => e.taetigkeit).filter(Boolean))].sort();

    const fillSelect = (id, options, i18nKey) => {
        const el = document.getElementById(id);
        if (!el) return;
        const val = el.value;
        el.innerHTML = '<option value="">' + t(i18nKey) + '</option>' + options.map(o => '<option value="' + esc(o) + '">' + esc(o) + '</option>').join('');
        el.value = val;
    };

    fillSelect('filterSh', shSet, 'all.stakeholder');
    fillSelect('filterPr', prSet, 'all.projekte');
    fillSelect('filterTa', taSet, 'all.taetigkeiten');
    fillSelect('dashFilterSh', shSet, 'all.stakeholder');
    fillSelect('dashFilterPr', prSet, 'all.projekte');
    fillSelect('dashFilterTa', taSet, 'all.taetigkeiten');
}

function renderEntries() {
    let filtered = [...entries];

    // Datum-Filter
    const from = document.getElementById('filterFrom').value;
    const to = document.getElementById('filterTo').value;
    if (from) filtered = filtered.filter(e => e.date >= from);
    if (to) filtered = filtered.filter(e => e.date <= to);

    // Dropdown-Filter
    const fSh = document.getElementById('filterSh').value;
    const fPr = document.getElementById('filterPr').value;
    const fTa = document.getElementById('filterTa').value;
    const fNotiz = (document.getElementById('filterNotiz').value || '').trim().toLowerCase();
    if (fSh) filtered = filtered.filter(e => e.stakeholder === fSh);
    if (fPr) filtered = filtered.filter(e => e.projekt === fPr);
    if (fTa) filtered = filtered.filter(e => e.taetigkeit === fTa);
    if (fNotiz) filtered = filtered.filter(e => (e.notiz || '').toLowerCase().includes(fNotiz));

    // Aktive Filter anzeigen
    const filterBar = document.getElementById('entryFilterBar');
    const activeFilters = [];
    if (from) activeFilters.push(t('filter.from') + ' ' + formatDateDE(from));
    if (to) activeFilters.push(t('filter.to') + ' ' + formatDateDE(to));
    if (fSh) activeFilters.push('👤 ' + fSh);
    if (fPr) activeFilters.push('📁 ' + fPr);
    if (fTa) activeFilters.push('⚡ ' + fTa);
    if (fNotiz) activeFilters.push('🔍 «' + fNotiz + '»');
    if (activeFilters.length && filterBar) {
        filterBar.style.display = 'flex';
        filterBar.innerHTML = activeFilters.map(f => '<span class="filter-tag">' + f + '</span>').join('') +
            '<span class="filter-clear-all" onclick="clearFilter()">' + t('filter.clearAll') + '</span>';
    } else if (filterBar) {
        filterBar.style.display = 'none';
    }

    // Nach Datum absteigend sortieren
    filtered.sort((a, b) => {
        const dc = b.date.localeCompare(a.date);
        if (dc !== 0) return dc;
        return (b.startTime || '').localeCompare(a.startTime || '');
    });

    const tbody = document.getElementById('entriesBody');
    const noEl = document.getElementById('noEntries');

    if (!filtered.length) {
        tbody.innerHTML = '';
        noEl.style.display = 'block';
        document.getElementById('entriesSummary').innerHTML = entries.length
            ? '<div class="summary-item" style="color:var(--text-muted);">' + t('entries.noMatch') + ' (' + entries.length + ' ' + t('entries.totalSuffix') + ')</div>'
            : '';
        return;
    }

    noEl.style.display = 'none';

    // Zusammenfassung
    const totalMs = filtered.reduce((s, e) => s + (Number(e.durationMs) || 0), 0);
    const totalLabel = entries.length !== filtered.length ? ' <span style="color:var(--text-muted);">(' + t('entries.of') + ' ' + entries.length + ')</span>' : '';
    document.getElementById('entriesSummary').innerHTML = `
        <div class="summary-item"><strong>${filtered.length}</strong> ${t('entries.count')}${totalLabel}</div>
        <div class="summary-item">${t('entries.total')} <strong>${formatDuration(totalMs)}</strong></div>
    `;

    tbody.innerHTML = filtered.map((e, ri) => `
        <tr style="animation: staggerIn 0.3s ease both; animation-delay: ${Math.min(ri * 30, 300)}ms;">
            <td class="col-date">${formatDateDE(e.date)}</td>
            <td><span class="entry-badge sh">${esc(e.stakeholder || '')}</span></td>
            <td><span class="entry-badge pr">${esc(e.projekt || '')}</span></td>
            <td><span class="entry-badge ta">${esc(e.taetigkeit || '')}</span></td>
            <td class="col-time">${e.startTime || ''}</td>
            <td class="col-time">${e.endTime || ''}</td>
            <td class="col-duration">${formatDuration(Number(e.durationMs) || 0)}</td>
            <td style="max-width:150px; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;" title="${esc(e.notiz || '')}">${esc(e.notiz || '')}</td>
            <td class="col-actions">
                <div class="entry-actions">
                    <button class="entry-btn" onclick="editEntry('${e.id}')" title="${t('title.edit')}">✏️</button>
                    <button class="entry-btn delete" onclick="deleteEntry('${e.id}')" title="${t('title.delete')}">🗑️</button>
                </div>
            </td>
        </tr>
    `).join('');
}

function filterEntries() { renderEntries(); }
function clearFilter() {
    document.getElementById('filterFrom').value = '';
    document.getElementById('filterTo').value = '';
    document.getElementById('filterSh').value = '';
    document.getElementById('filterPr').value = '';
    document.getElementById('filterTa').value = '';
    document.getElementById('filterNotiz').value = '';
    renderEntries();
}

// ============================================================
// EINTRAG BEARBEITEN
// ============================================================
function editEntry(id) {
    const entry = entries.find(e => e.id === id);
    if (!entry) return;

    populateDropdowns();
    document.getElementById('editId').value = id;
    document.getElementById('editDate').value = entry.date;
    document.getElementById('editStakeholder').value = entry.stakeholder;
    document.getElementById('editProjekt').value = entry.projekt;
    document.getElementById('editTaetigkeit').value = entry.taetigkeit || '';
    document.getElementById('editStart').value = entry.startTime;
    document.getElementById('editEnd').value = entry.endTime;
    document.getElementById('editNotiz').value = entry.notiz || '';

    document.getElementById('editModal').classList.add('open');
}

function closeEditModal() {
    document.getElementById('editModal').classList.remove('open');
}

function saveEdit() {
    const id = document.getElementById('editId').value;
    const entry = entries.find(e => e.id === id);
    if (!entry) return;

    const start = document.getElementById('editStart').value;
    const end = document.getElementById('editEnd').value;
    if (!start || !end) { showToast(t('toast.selectTime'), 'error'); return; }

    const [sh1, sm1] = start.split(':').map(Number);
    const [eh1, em1] = end.split(':').map(Number);
    let startMin = sh1 * 60 + sm1;
    let endMin = eh1 * 60 + em1;
    // Mitternachts-Überschreitung erlauben (z.B. 23:00–01:00 = 2h)
    let durationMin = endMin - startMin;
    if (durationMin <= 0) durationMin += 24 * 60; // Über Mitternacht

    entry.date = document.getElementById('editDate').value;
    entry.stakeholder = document.getElementById('editStakeholder').value;
    entry.projekt = document.getElementById('editProjekt').value;
    entry.taetigkeit = document.getElementById('editTaetigkeit').value;
    entry.startTime = start;
    entry.endTime = end;
    entry.notiz = document.getElementById('editNotiz').value.trim();
    entry.durationMs = durationMin * 60 * 1000;

    saveEntries();
    closeEditModal();
    renderEntries();
    renderDashboard();
    showToast(t('toast.entryUpdated'), 'success');
}

function deleteEntry(id) {
    const deleted = entries.find(e => e.id === id);
    if (!deleted) return;
    const idx = entries.indexOf(deleted);
    entries = entries.filter(e => e.id !== id);
    saveEntries();
    renderEntries();
    renderDashboard();
    showToast(t('toast.entryDeleted'), '', () => {
        entries.splice(idx, 0, deleted);
        saveEntries();
        renderEntries();
        renderDashboard();
        showToast(t('toast.entryRestored'), 'success');
    });
}

// ============================================================
// DASHBOARD – Variante 5: KPIs + Heatmap + Balken + Zeitverlauf
// ============================================================
const PERIOD_LABELS = { get week() { return t('dash.week'); }, get month() { return t('dash.thisMonth'); }, get year() { return t('dash.thisYear'); }, get all() { return t('dash.all'); } };
const BAR_COLORS = ['c0','c1','c2','c3','c4','c5'];
const WT_SHORT = t('wd.short');

// ========== PREMIUM UX FEATURES ==========

// --- Button Ripple Effect ---
document.addEventListener('click', function(e) {
    try {
        if (!e.target || typeof e.target.closest !== 'function') return;
        const btn = e.target.closest('.btn, .btn-primary, .btn-danger, .btn-success, .period-btn');
        if (!btn) return;
        const ripple = document.createElement('span');
        ripple.classList.add('ripple');
        const rect = btn.getBoundingClientRect();
        const size = Math.max(rect.width, rect.height);
        ripple.style.width = ripple.style.height = size + 'px';
        ripple.style.left = (e.clientX - rect.left - size/2) + 'px';
        ripple.style.top = (e.clientY - rect.top - size/2) + 'px';
        btn.appendChild(ripple);
        setTimeout(() => ripple.remove(), 600);
    } catch(ex) {}
});

// --- Daily Goal Progress ---
const DAILY_GOAL_MS = 8.4 * 60 * 60 * 1000; // 8h 24min (= 8.4h)
let _lastGoalCelebrated = null;

function updateDailyGoal() {
    const now = new Date();
    const today = formatDateISO(now);
    const todayMs = entries.filter(e => e.date === today).reduce((s, e) => s + (Number(e.durationMs) || 0), 0);

    // Laufende Timer mitzählen (proportional)
    let runningMs = 0;
    taskSlots.forEach(s => {
        if (s.running) {
            runningMs += getSlotElapsed(s);
        }
    });
    const totalMs = todayMs + runningMs;

    const pct = Math.min((totalMs / DAILY_GOAL_MS) * 100, 120);
    const fill = document.getElementById('dailyGoalFill');
    const text = document.getElementById('dailyGoalText');
    if (fill) {
        fill.style.width = Math.min(pct, 100) + '%';
        fill.classList.toggle('over', pct > 100);
    }
    if (text) text.textContent = formatDurationHM(totalMs, '0:00') + ' / 8:24';

    // Confetti bei Zielerreichung (einmal pro Tag)
    if (totalMs >= DAILY_GOAL_MS && _lastGoalCelebrated !== today) {
        _lastGoalCelebrated = today;
        triggerConfetti();
        showToast('🎉 Tagesziel erreicht! Gut gemacht!', 'success');
    }
}

// --- Confetti Celebration ---
function triggerConfetti() {
    const container = document.getElementById('confettiContainer');
    if (!container) return;
    const colors = ['#C9A962', '#C48B9F', '#9B8EC4', '#6EC49E', '#E5A84B', '#D4956A', '#D4706E'];
    for (let i = 0; i < 60; i++) {
        const piece = document.createElement('div');
        piece.classList.add('confetti-piece');
        piece.style.left = Math.random() * 100 + '%';
        piece.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
        piece.style.animationDelay = Math.random() * 1 + 's';
        piece.style.animationDuration = (2 + Math.random() * 2) + 's';
        piece.style.borderRadius = Math.random() > 0.5 ? '50%' : '2px';
        piece.style.width = (5 + Math.random() * 8) + 'px';
        piece.style.height = (5 + Math.random() * 8) + 'px';
        container.appendChild(piece);
    }
    setTimeout(() => container.innerHTML = '', 5000);
}

// --- FAB: Quick-Start letzte Aufgabe ---
function fabQuickStart() {
    // Wenn Timer läuft, zum Timer-Tab wechseln
    const anyRunning = taskSlots.some(s => s.running);
    if (anyRunning) {
        switchView('timer');
        return;
    }
    // Sonst: Letzten Eintrag als neuen Task starten
    if (entries.length > 0) {
        const last = entries[entries.length - 1];
        // Prüfen ob ein leerer Slot existiert
        let slot = taskSlots.find(s => !s.sh && !s.pr);
        if (!slot) {
            addTaskSlot();
            slot = taskSlots[taskSlots.length - 1];
        }
        const idx = taskSlots.indexOf(slot);
        slot.sh = last.stakeholder || '';
        slot.pr = last.projekt || '';
        slot.ta = last.taetigkeit || '';
        slot.notiz = last.notiz || '';
        renderTaskSlots();
        switchView('timer');
        // Timer starten nach kurzer Verzögerung für visuelles Feedback
        setTimeout(() => toggleSlotTimer(idx), 200);
    } else {
        switchView('timer');
    }
}

// FAB-Zustand aktualisieren (Symbol ändern wenn Timer läuft)
function updateFabState() {
    const fab = document.getElementById('fabBtn');
    if (!fab) return;
    const anyRunning = taskSlots.some(s => s.running);
    const anyPaused = taskSlots.some(s => s.paused);
    if (anyRunning) {
        fab.textContent = '⏱';
        fab.title = t('fab.goTimer');
        fab.style.background = 'linear-gradient(135deg, var(--neon-green), rgba(52,211,153,0.8))';
    } else if (anyPaused) {
        fab.textContent = '⏸';
        fab.title = t('fab.resume');
        fab.style.background = 'linear-gradient(135deg, var(--neon-yellow), rgba(251,191,36,0.8))';
    } else {
        fab.textContent = '▶';
        fab.title = t('fab.resumeLast');
        fab.style.background = '';
    }
}

// --- Keyboard Shortcuts ---
document.addEventListener('keydown', function(e) {
    // Ignorieren wenn in Inputfeld
    if (['INPUT', 'TEXTAREA', 'SELECT'].includes(e.target.tagName)) return;
    // Ignorieren wenn Modal offen
    const modalOpen = document.querySelector('.modal-overlay.open');
    const kbdOpen = document.getElementById('kbdOverlay').classList.contains('open');

    if (e.key === 'Escape') {
        if (kbdOpen) { document.getElementById('kbdOverlay').classList.remove('open'); return; }
        if (modalOpen) { modalOpen.classList.remove('open'); return; }
    }
    if (e.key === '?' || (e.key === '/' && e.shiftKey)) {
        e.preventDefault();
        document.getElementById('kbdOverlay').classList.toggle('open');
        return;
    }
    if (kbdOpen || modalOpen) return;

    switch(e.key) {
        case ' ':
            e.preventDefault();
            // Toggle ersten aktiven oder ersten Slot
            const runIdx = taskSlots.findIndex(s => s.running);
            const pauseIdx = taskSlots.findIndex(s => s.paused);
            if (runIdx >= 0) toggleSlotTimer(runIdx);
            else if (pauseIdx >= 0) toggleSlotTimer(pauseIdx);
            else if (taskSlots.length > 0) toggleSlotTimer(0);
            break;
        case 's': case 'S':
            const activeIdx = taskSlots.findIndex(s => s.running || s.paused);
            if (activeIdx >= 0) stopSlotTimer(activeIdx);
            break;
        case 'n': case 'N':
            switchView('timer');
            addTaskSlot();
            break;
        case 'f': case 'F':
            stopAllTimers();
            break;
        case '1': switchView('timer'); break;
        case '2': switchView('entries'); break;
        case '3': switchView('dashboard'); break;
        case '4': switchView('manage'); break;
        case '5': switchView('team'); break;
    }
});

// --- Hook into existing timer updates for daily goal ---
const _origUpdateTimerDisplays = typeof updateTimerDisplays === 'function' ? updateTimerDisplays : null;

// ========== NOTIZ-AUTOCOMPLETE ==========
// Aktualisiert die Notiz-Vorschläge basierend auf aktuellem Stakeholder/Projekt
function updateNotizDatalist(sh, pr) {
    const dl = document.getElementById('notizSuggestions');
    if (!dl) return;
    // Alle bisherigen Notizen sammeln
    const allNotizen = entries.map(e => e.notiz).filter(Boolean);
    // Kontextbezogen: gleicher Stakeholder/Projekt zuerst, dann alle anderen
    const contextMatch = [], rest = [];
    const seen = new Set();
    for (const e of entries) {
        if (!e.notiz || seen.has(e.notiz)) continue;
        seen.add(e.notiz);
        if ((sh && e.stakeholder === sh) || (pr && e.projekt === pr)) {
            contextMatch.push(e.notiz);
        } else {
            rest.push(e.notiz);
        }
    }
    const sorted = [...contextMatch.sort(), ...rest.sort()];
    dl.innerHTML = sorted.map(n => `<option value="${esc(n)}">`).join('');
}

// ========== DASHBOARD NOTIZ-FILTER ==========
let _dashNotizTimer = null;
function onDashNotizFilter() {
    clearTimeout(_dashNotizTimer);
    _dashNotizTimer = setTimeout(() => {
        dashNotizQuery = (document.getElementById('dashNotizSearch').value || '').trim();
        renderDashboard();
    }, 250);
}

function clearDashFilters() {
    dashNotizQuery = '';
    const ids = ['dashNotizSearch', 'dashFilterSh', 'dashFilterPr', 'dashFilterTa'];
    ids.forEach(id => { const el = document.getElementById(id); if (el) el.value = ''; });
    renderDashboard();
}

function clearDashNotizFilter() { clearDashFilters(); }

function setDashPeriod(period, btn) {
    dashPeriod = period;
    document.querySelectorAll('.period-btn').forEach(b => b.classList.remove('active'));
    if (btn) btn.classList.add('active');
    renderDashboard();
}

function renderDashboard() {
    const now = new Date();
    const today = formatDateISO(now);
    let filtered = getFilteredByPeriod();

    // Smart-Fallback: Wenn gewählte Periode leer ist, automatisch erweitern
    if (!filtered.length && entries.length > 0) {
        const fallbacks = ['week', 'month', 'year', 'all'];
        const currentIdx = fallbacks.indexOf(dashPeriod);
        for (let i = currentIdx + 1; i < fallbacks.length; i++) {
            const oldPeriod = dashPeriod;
            dashPeriod = fallbacks[i];
            filtered = getFilteredByPeriod();
            if (filtered.length > 0) {
                // UI-Button aktualisieren
                document.querySelectorAll('.period-btn').forEach(b => b.classList.remove('active'));
                document.querySelectorAll('.period-btn')[i].classList.add('active');
                break;
            }
        }
    }

    // Notiz-Datalist aktualisieren
    const allNotizen = [...new Set(filtered.map(e => e.notiz).filter(Boolean))].sort();
    const dlDash = document.getElementById('dashNotizList');
    if (dlDash) dlDash.innerHTML = allNotizen.map(n => `<option value="${esc(n)}">`).join('');

    // Erweiterte Filter anwenden (Stakeholder, Projekt, Tätigkeit, Notiz)
    const dSh = (document.getElementById('dashFilterSh') || {}).value || '';
    const dPr = (document.getElementById('dashFilterPr') || {}).value || '';
    const dTa = (document.getElementById('dashFilterTa') || {}).value || '';
    if (dSh) filtered = filtered.filter(e => e.stakeholder === dSh);
    if (dPr) filtered = filtered.filter(e => e.projekt === dPr);
    if (dTa) filtered = filtered.filter(e => e.taetigkeit === dTa);
    if (dashNotizQuery) {
        const q = dashNotizQuery.toLowerCase();
        filtered = filtered.filter(e => (e.notiz || '').toLowerCase().includes(q));
    }

    // Filter-Info & Reset-Button
    const filterInfo = document.getElementById('dashFilterInfo');
    const clearBtn = document.getElementById('dashFilterClear');
    const activeDF = [];
    if (dSh) activeDF.push('👤 ' + dSh);
    if (dPr) activeDF.push('📁 ' + dPr);
    if (dTa) activeDF.push('⚡ ' + dTa);
    if (dashNotizQuery) activeDF.push('🔍 «' + dashNotizQuery + '»');
    if (activeDF.length) {
        if (filterInfo) { filterInfo.style.display = 'block'; filterInfo.innerHTML = activeDF.map(f => '<span class="filter-tag" style="display:inline-flex;align-items:center;gap:4px;padding:2px 8px;border-radius:10px;background:rgba(201,169,98,0.08);font-weight:500;margin-right:4px;">' + f + '</span>').join('') + ' — ' + filtered.length + ' ' + t('entries.count'); }
        if (clearBtn) clearBtn.style.display = 'block';
    } else {
        if (filterInfo) filterInfo.style.display = 'none';
        if (clearBtn) clearBtn.style.display = 'none';
    }

    const totalMs = filtered.reduce((s, e) => s + (Number(e.durationMs) || 0), 0);

    // --- Zone A: KPIs mit animierten Countern ---
    const todayEntries = entries.filter(e => e.date === today);
    const todayMs = todayEntries.reduce((s, e) => s + (Number(e.durationMs) || 0), 0);

    // Anwesenheit (Wanduhrzeit): frühester Start bis spätester Schluss pro Tag
    const presenceMs = calcPresenceMs(todayEntries);
    animateKPIValue('kpiToday', formatDurationHM(todayMs, '0:00'));
    animateKPIValue('kpiPresence', formatDurationHM(presenceMs, '0:00'));
    animateKPIValue('kpiPeriod', formatDurationHM(totalMs, '0:00'));
    animateKPIValue('kpiEntries', String(filtered.length));
    document.getElementById('kpiPeriodLabel').textContent = PERIOD_LABELS[dashPeriod] || t('period.label');

    // --- Zone B links: Heatmap Stakeholder × Projekt ---
    renderHeatmap(filtered);

    // --- Zone B rechts: Tätigkeiten-Balken ---
    const byTaetigkeit = aggregate(filtered, 'taetigkeit');
    renderBarChart('chartTaetigkeit', byTaetigkeit);

    // --- Zone C: Zeitverlauf ---
    renderTimeline(filtered);
}

// Wanduhrzeit (Anwesenheit): frühester Start bis spätester Schluss
// Berücksichtigt laufende Timer für heute
function calcPresenceMs(dayEntries) {
    if (!dayEntries.length && !taskSlots.some(s => s.running)) return 0;

    let earliestMin = Infinity;
    let latestMin = -Infinity;

    // Aus gespeicherten Einträgen
    dayEntries.forEach(e => {
        if (!e.startTime || !e.endTime) return;
        const [sh, sm] = e.startTime.split(':').map(Number);
        const [eh, em] = e.endTime.split(':').map(Number);
        const startMin = sh * 60 + sm;
        let endMin = eh * 60 + em;
        if (e.endTime === '24:00') endMin = 24 * 60;
        if (startMin < earliestMin) earliestMin = startMin;
        if (endMin > latestMin) latestMin = endMin;
    });

    // Laufende Timer berücksichtigen
    const now = new Date();
    const today = formatDateISO(now);
    taskSlots.forEach(s => {
        if (!s.running) return;
        const orig = s.originalStartTime || s.startTime;
        if (!orig) return;
        const startDt = new Date(orig);
        // Nur wenn Timer heute gestartet wurde
        if (formatDateISO(startDt) !== today) return;
        const startMin = startDt.getHours() * 60 + startDt.getMinutes();
        const nowMin = now.getHours() * 60 + now.getMinutes();
        if (startMin < earliestMin) earliestMin = startMin;
        if (nowMin > latestMin) latestMin = nowMin;
    });

    if (earliestMin === Infinity || latestMin === -Infinity) return 0;
    return Math.max(0, (latestMin - earliestMin) * 60000);
}

function getFilteredByPeriod() {
    const now = new Date();
    const today = formatDateISO(now);
    switch (dashPeriod) {
        case 'week': {
            const dow = now.getDay();
            const diff = dow === 0 ? -6 : 1 - dow;
            const monday = new Date(now); monday.setDate(now.getDate() + diff);
            return entries.filter(e => e.date >= formatDateISO(monday) && e.date <= today);
        }
        case 'month': {
            const ms = today.slice(0, 7) + '-01';
            return entries.filter(e => e.date >= ms && e.date <= today);
        }
        case 'year': {
            const ys = now.getFullYear() + '-01-01';
            return entries.filter(e => e.date >= ys && e.date <= today);
        }
        default: return [...entries];
    }
}

function aggregate(list, field) {
    const map = {};
    list.forEach(e => { const k = e[field] || t('empty'); map[k] = (map[k] || 0) + (Number(e.durationMs) || 0); });
    return Object.entries(map).filter(([_, ms]) => ms > 0).sort((a, b) => b[1] - a[1]);
}

// --- Heatmap: Stakeholder (Zeilen) × Projekt (Spalten) ---
function renderHeatmap(filtered) {
    const wrap = document.getElementById('heatmapWrap');
    if (!filtered.length) { wrap.innerHTML = '<div style="color:var(--text-muted); font-size:12px; padding:20px; text-align:center; line-height:1.6;">' + t('dash.noEntries') + '</div>'; return; }

    // Kreuz-Aggregation
    const matrix = {}; const stakeholders = new Set(); const projekte = new Set();
    filtered.forEach(e => {
        const sh = e.stakeholder || t('empty'); const pr = e.projekt || t('empty');
        stakeholders.add(sh); projekte.add(pr);
        if (!matrix[sh]) matrix[sh] = {};
        matrix[sh][pr] = (matrix[sh][pr] || 0) + (Number(e.durationMs) || 0);
    });
    const shArr = [...stakeholders].sort((a, b) => a.localeCompare(b, 'de'));
    const prArr = [...projekte].sort((a, b) => a.localeCompare(b, 'de'));

    // Maximum für Farbstufen bestimmen
    let maxMs = 0;
    shArr.forEach(sh => prArr.forEach(pr => { const v = (matrix[sh] && matrix[sh][pr]) || 0; if (v > maxMs) maxMs = v; }));

    function heatLevel(ms) {
        if (!ms) return 0;
        const pct = ms / maxMs;
        if (pct < 0.1) return 1;
        if (pct < 0.3) return 2;
        if (pct < 0.55) return 3;
        if (pct < 0.8) return 4;
        return 5;
    }

    // Spaltentotale
    const colTotals = {};
    prArr.forEach(pr => { colTotals[pr] = 0; shArr.forEach(sh => { colTotals[pr] += (matrix[sh] && matrix[sh][pr]) || 0; }); });

    let html = '<table class="heatmap"><thead><tr><th class="hm-row-label"></th>';
    prArr.forEach(pr => { html += `<th title="${esc(pr)}">${esc(pr.length > 10 ? pr.slice(0, 9) + '…' : pr)}</th>`; });
    html += '<th>' + t('heatmap.total') + '</th></tr></thead><tbody>';

    shArr.forEach(sh => {
        let rowTotal = 0;
        html += `<tr><td class="hm-row-label" title="${esc(sh)}">${esc(sh)}</td>`;
        prArr.forEach(pr => {
            const ms = (matrix[sh] && matrix[sh][pr]) || 0;
            rowTotal += ms;
            const lvl = heatLevel(ms);
            html += `<td class="hm-cell hm-${lvl}" title="${esc(sh)} × ${esc(pr)}: ${formatDurationHM(ms)}">${formatDurationHM(ms)}</td>`;
        });
        html += `<td class="hm-total">${formatDurationHM(rowTotal)}</td></tr>`;
    });

    // Fusszeile: Spaltentotale
    html += '<tr><td class="hm-row-label hm-total">' + t('heatmap.total') + '</td>';
    let grandTotal = 0;
    prArr.forEach(pr => { grandTotal += colTotals[pr]; html += `<td class="hm-total">${formatDurationHM(colTotals[pr])}</td>`; });
    html += `<td class="hm-total">${formatDurationHM(grandTotal)}</td></tr>`;

    html += '</tbody></table>';
    wrap.innerHTML = html;
}

// --- Balkendiagramm ---
function renderBarChart(containerId, data) {
    const container = document.getElementById(containerId);
    if (!data.length) { container.innerHTML = '<div style="color:var(--text-muted); font-size:12px; padding:10px;">' + t('team.noperiod') + '</div>'; return; }
    const maxMs = data[0][1];
    container.innerHTML = data.map(([label, ms], i) => {
        const pct = maxMs > 0 ? (ms / maxMs * 100) : 0;
        return `<div class="bar-row" style="animation: staggerIn 0.4s ease both; animation-delay: ${i * 80}ms;">
            <div class="bar-label" title="${esc(label)}">${esc(label)}</div>
            <div class="bar-track"><div class="bar-fill ${BAR_COLORS[i % 6]}" style="width:0%; transition: width 0.8s cubic-bezier(0.22, 1, 0.36, 1) ${i * 100}ms;" data-target-width="${Math.max(pct, 8)}%">${formatDurationHM(ms)}</div></div>
        </div>`;
    }).join('');
    // Trigger bar animation nach mini-delay
    requestAnimationFrame(() => {
        container.querySelectorAll('.bar-fill[data-target-width]').forEach(el => {
            el.style.width = el.dataset.targetWidth;
        });
    });
}

// --- Zeitverlauf: gestapelte Tagesbalken ---
function renderTimeline(filtered) {
    const container = document.getElementById('timelineChart');
    if (!filtered.length) { container.innerHTML = '<div style="color:var(--text-muted); font-size:12px; padding:10px;">' + t('team.noperiod') + '</div>'; return; }

    // Tage im Zeitraum bestimmen
    const dates = filtered.map(e => e.date).sort();
    const minDate = dates[0]; const maxDate = dates[dates.length - 1];

    // Alle Tage zwischen min und max erzeugen (max 60 Tage)
    const days = [];
    const cur = new Date(minDate + 'T00:00:00');
    const end = new Date(maxDate + 'T00:00:00');
    let safety = 0;
    while (cur <= end && safety < 60) {
        days.push(formatDateISO(cur));
        cur.setDate(cur.getDate() + 1);
        safety++;
    }

    // Pro Tag nach Projekt aufschlüsseln
    const dayData = {};
    filtered.forEach(e => {
        if (!dayData[e.date]) dayData[e.date] = {};
        const pr = e.projekt || t('empty');
        dayData[e.date][pr] = (dayData[e.date][pr] || 0) + (Number(e.durationMs) || 0);
    });

    // Alle vorkommenden Projekte sammeln für konsistente Farben
    const allProjekte = [...new Set(filtered.map(e => e.projekt || t('empty')))].sort((a, b) => a.localeCompare(b, 'de'));
    const colorMap = {};
    allProjekte.forEach((p, i) => { colorMap[p] = BAR_COLORS[i % 6]; });

    // Maximale Stunden pro Tag für Skalierung
    let maxDayMs = 0;
    days.forEach(d => {
        const dd = dayData[d];
        if (dd) { const total = Object.values(dd).reduce((s, v) => s + v, 0); if (total > maxDayMs) maxDayMs = total; }
    });

    let html = '';
    days.forEach(d => {
        const dt = new Date(d + 'T00:00:00');
        const dow = dt.getDay();
        const isWe = dow === 0 || dow === 6;
        const dd = dayData[d] || {};
        const dayTotal = Object.values(dd).reduce((s, v) => s + v, 0);
        const dayPct = maxDayMs > 0 ? (dayTotal / maxDayMs) : 0;

        html += `<div class="tl-row${isWe ? ' tl-weekend' : ''}">`;
        html += `<div class="tl-label">${pad(dt.getDate())}.${pad(dt.getMonth()+1)} <span class="tl-day">${WT_SHORT[dow]}</span></div>`;
        html += '<div class="tl-bar-wrap">';

        if (dayTotal > 0) {
            allProjekte.forEach(pr => {
                const ms = dd[pr] || 0;
                if (ms <= 0) return;
                const segPct = (ms / maxDayMs) * 100;
                const cls = colorMap[pr];
                html += `<div class="tl-segment bar-fill ${cls}" style="width:${Math.max(segPct, 2)}%" title="${esc(pr)}: ${formatDurationHM(ms)}">${segPct > 8 ? formatDurationHM(ms) : ''}</div>`;
            });
        }
        html += '</div>';
        html += `<div class="tl-hours">${dayTotal > 0 ? formatDurationHM(dayTotal) : ''}</div>`;
        html += '</div>';
    });

    // Legende
    html += '<div class="tl-legend">';
    allProjekte.forEach((pr, i) => {
        html += `<div class="tl-legend-item"><div class="tl-legend-dot bar-fill ${BAR_COLORS[i % 6]}" style="width:10px;height:10px;border-radius:2px;"></div>${esc(pr)}</div>`;
    });
    html += '</div>';

    container.innerHTML = html;
}

// Formatierung: Stunden + Minuten (kompakt)
// zeroDisplay: was bei 0 gezeigt wird ('–' für Tabellen, '0:00' für KPIs)
function formatDurationHM(ms, zeroDisplay) {
    const n = Number(ms) || 0;
    if (n <= 0) return zeroDisplay !== undefined ? zeroDisplay : '–';
    const totalMin = Math.round(n / 60000);
    if (totalMin < 1) return '<1m';
    const h = Math.floor(totalMin / 60);
    const m = totalMin % 60;
    return h + ':' + pad(m);
}

// ============================================================
// KOMPLETT-BACKUP (JSON)
// ============================================================
function closeWelcomeModal() {
    document.getElementById('welcomeModal').classList.remove('open');
}

function handleWelcomeBackup(event) {
    // Gleiche Logik wie handleBackupImport, aber ohne confirm-Dialog
    const file = event.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = async function(e) {
        try {
            const backup = JSON.parse(e.target.result);
            if (!backup.masterData || !backup.entries) {
                showToast(t('toast.invalidBackup'), 'error');
                return;
            }
            masterData = {
                stakeholder: backup.masterData.stakeholder || [],
                projekt: backup.masterData.projekt || [],
                taetigkeit: backup.masterData.taetigkeit || []
            };
            entries = backup.entries || [];
            entries.forEach(en => { if (!en.id) en.id = generateId(); });
            sortMasterData();
            await saveAll();
            renderAll();
            closeWelcomeModal();
            showToast(`${t('toast.backupLoaded')} ${entries.length} ${t('backup.entries')}, ${masterData.stakeholder.length} ${t('manage.labelSh')}, ${masterData.projekt.length} ${t('manage.labelPr')}, ${masterData.taetigkeit.length} ${t('manage.labelTa')}.`, 'success');
        } catch (err) {
            showToast(t('toast.error') + ' ' + err.message, 'error');
        }
    };
    reader.readAsText(file, 'UTF-8');
    event.target.value = '';
}

function exportBackup() {
    const backup = {
        _meta: {
            app: 'Zeiterfassung',
            version: '1.5',
            exportDate: new Date().toISOString(),
            entriesCount: entries.length
        },
        masterData: masterData,
        entries: entries
    };

    const json = JSON.stringify(backup, null, 2);
    const blob = new Blob([json], { type: 'application/json;charset=utf-8;' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `Zeiterfassung_Backup_${new Date().toISOString().slice(0,10)}.json`;
    a.click();
    URL.revokeObjectURL(url);
    showToast(`${t('toast.backupSaved2')} (${entries.length} ${t('backup.entries')}, ${masterData.stakeholder.length} ${t('manage.labelSh')}, ${masterData.projekt.length} ${t('manage.labelPr')}, ${masterData.taetigkeit.length} ${t('manage.labelTa')}).`, 'success');
}

function handleBackupImport(event) {
    const file = event.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = async function(e) {
        try {
            const backup = JSON.parse(e.target.result);

            // Validierung: Standard-Backup ODER Team-Sync-JSON akzeptieren
            if (!backup.entries) {
                showToast(t('toast.invalidNoEntries'), 'error');
                return;
            }
            // Team-Sync-JSONs haben evtl. kein masterData-Feld
            if (!backup.masterData) backup.masterData = { stakeholder: [], projekt: [], taetigkeit: [] };

            const count = backup.entries.length;
            const sh = (backup.masterData.stakeholder || []).length;
            const pr = (backup.masterData.projekt || []).length;
            const ta = (backup.masterData.taetigkeit || []).length;

            const mode = confirm(
                `${t('backup.contains')} ${count} ${t('backup.entries')}, ${sh} ${t('manage.labelSh')}, ${pr} ${t('manage.labelPr')}, ${ta} ${t('manage.labelTa')}.\n\n` +
                t('confirm.replaceData')
            );

            if (!mode) return;

            // Daten komplett ersetzen
            masterData = {
                stakeholder: backup.masterData.stakeholder || [],
                projekt: backup.masterData.projekt || [],
                taetigkeit: backup.masterData.taetigkeit || []
            };
            entries = backup.entries || [];

            // Sicherstellen, dass jeder Eintrag eine ID hat
            entries.forEach(en => { if (!en.id) en.id = generateId(); });

            sortMasterData();
            await saveAll();
            renderAll();
            showToast(`${t('toast.backupRestored')} ${count} ${t('backup.entries')}, ${sh} ${t('manage.labelSh')}, ${pr} ${t('manage.labelPr')}, ${ta} ${t('manage.labelTa')}.`, 'success');
        } catch (err) {
            showToast(t('toast.backupReadError') + ' ' + err.message, 'error');
        }
    };
    reader.readAsText(file, 'UTF-8');
    event.target.value = '';
}

// ============================================================
// CSV EXPORT / IMPORT
// ============================================================
function exportCSV() {
    if (!entries.length) { showToast(t('toast.noExport'), 'error'); return; }
    const headers = [t('csv.datum'), t('csv.stakeholder'), t('csv.projekt'), t('csv.taetigkeit'), t('csv.von'), t('csv.bis'), t('csv.dauer'), t('csv.notiz')];
    const rows = entries.sort((a, b) => a.date.localeCompare(b.date)).map(e => [
        formatDateDE(e.date),
        e.stakeholder || '',
        e.projekt || '',
        e.taetigkeit || '',
        e.startTime || '',
        e.endTime || '',
        ((Number(e.durationMs) || 0) / 3600000).toFixed(2),
        e.notiz || ''
    ]);

    // BOM für Excel-Kompatibilität (UTF-8)
    let csv = '\uFEFF' + headers.join(';') + '\n';
    rows.forEach(r => csv += r.map(c => '"' + String(c).replace(/"/g, '""') + '"').join(';') + '\n');

    const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `Zeiterfassung_${new Date().toISOString().slice(0,10)}.csv`;
    a.click();
    URL.revokeObjectURL(url);
    showToast(t('toast.csvExported'), 'success');
}

function importCSV() {
    document.getElementById('csvFileInput').click();
}

function handleCSVImport(event) {
    const file = event.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = async function(e) {
        const lines = e.target.result.split('\n').filter(l => l.trim());
        if (lines.length < 2) { showToast(t('toast.csvEmpty'), 'error'); return; }

        let imported = 0;
        for (let i = 1; i < lines.length; i++) {
            // Semikolon-getrennt (für CH/DE Excel)
            const cols = lines[i].split(';').map(c => c.replace(/^"|"$/g, '').trim());
            if (cols.length < 6) continue;

            const entry = {
                id: generateId(),
                date: parseDateDE(cols[0]),
                stakeholder: cols[1],
                projekt: cols[2],
                taetigkeit: cols[3],
                startTime: cols[4],
                endTime: cols[5],
                durationMs: cols[6] ? parseFloat(cols[6]) * 3600000 : 0,
                notiz: cols[7] || ''
            };

            if (entry.date) {
                entries.push(entry);
                // Stammdaten ergänzen
                if (entry.stakeholder && !masterData.stakeholder.includes(entry.stakeholder)) masterData.stakeholder.push(entry.stakeholder);
                if (entry.projekt && !masterData.projekt.includes(entry.projekt)) masterData.projekt.push(entry.projekt);
                if (entry.taetigkeit && !masterData.taetigkeit.includes(entry.taetigkeit)) masterData.taetigkeit.push(entry.taetigkeit);
                imported++;
            }
        }

        sortMasterData();
        await saveAll();
        renderAll();
        showToast(`${imported} ${t('toast.imported')}`, 'success');
    };
    reader.readAsText(file, 'UTF-8');
    event.target.value = '';
}

// ============================================================
// ALLE DATEN LÖSCHEN
// ============================================================
async function confirmClearAll() {
    if (!confirm(t('confirm.deleteAll'))) return;
    const input = prompt('Zur Bestätigung bitte exakt eintippen:\n\nYes, nuke them all!');
    if (input !== 'Yes, nuke them all!') {
        showToast('Abgebrochen — Eingabe stimmte nicht überein.', 'error');
        return;
    }
    // 🛡️ DSB: Sicherheits-Export VOR dem Löschen
    try {
        const safetyBackup = JSON.stringify({ entries, masterData, ts: Date.now() });
        localStorage.setItem(APP_KEY + '_dsb_lastResort', safetyBackup);
    } catch(e) {}
    // DSB-Backups aufräumen
    try {
        ['A','B','C'].forEach(s => localStorage.removeItem(APP_KEY + '_dsb_gen_' + s));
        localStorage.removeItem(APP_KEY + '_dsb_meta');
        localStorage.removeItem(APP_KEY + '_dsb_heartbeat');
        localStorage.removeItem(APP_KEY + '_safeBackup');
    } catch(e) {}
    entries = [];
    masterData = { stakeholder: [], projekt: [], taetigkeit: [] };
    await saveAll();
    renderAll();
    showToast(t('toast.allDeleted2'), 'success');
}

// ============================================================
// HILFSFUNKTIONEN
// ============================================================
function generateId() {
    return Date.now().toString(36) + Math.random().toString(36).slice(2, 7);
}

function capitalize(s) {
    return s.charAt(0).toUpperCase() + s.slice(1);
}

function esc(str) {
    const d = document.createElement('div');
    d.textContent = str;
    return d.innerHTML;
}

function pad(n) { return String(n).padStart(2, '0'); }

function formatDateISO(d) {
    return d.getFullYear() + '-' + pad(d.getMonth() + 1) + '-' + pad(d.getDate());
}

function formatDateDE(isoDate) {
    if (!isoDate) return '';
    const parts = isoDate.split('-');
    if (parts.length !== 3) return isoDate;
    return parts[2] + '.' + parts[1] + '.' + parts[0];
}

function parseDateDE(deDate) {
    if (!deDate) return null;
    // Akzeptiere TT.MM.JJJJ
    const m = deDate.match(/(\d{1,2})[.\/-](\d{1,2})[.\/-](\d{2,4})/);
    if (!m) return deDate; // Vielleicht schon ISO
    const year = m[3].length === 2 ? '20' + m[3] : m[3];
    return year + '-' + pad(m[2]) + '-' + pad(m[1]);
}

function formatTime(d) {
    return pad(d.getHours()) + ':' + pad(d.getMinutes());
}

function formatDuration(ms) {
    if (!ms || ms <= 0) return '00:00';
    const totalSec = Math.floor(ms / 1000);
    const h = Math.floor(totalSec / 3600);
    const m = Math.floor((totalSec % 3600) / 60);
    const s = totalSec % 60;
    if (h > 0) return pad(h) + ':' + pad(m) + ':' + pad(s);
    return pad(m) + ':' + pad(s);
}

// ============================================================
// TOAST
// ============================================================
function showToast(msg, type = '', undoFn = null) {
    const container = document.getElementById('toastContainer');
    const toast = document.createElement('div');
    toast.className = 'toast ' + type;
    const msgSpan = document.createElement('span');
    msgSpan.textContent = msg;
    toast.appendChild(msgSpan);
    if (undoFn) {
        const undoBtn = document.createElement('button');
        undoBtn.className = 'toast-undo';
        undoBtn.textContent = t('btn.undo');
        undoBtn.onclick = () => { undoFn(); toast.remove(); };
        toast.appendChild(undoBtn);
    }
    container.appendChild(toast);
    setTimeout(() => { toast.style.opacity = '0'; toast.style.transform = 'translateX(40px)'; toast.style.transition = 'all 0.3s'; setTimeout(() => toast.remove(), 300); }, undoFn ? 5000 : 3000);
}

// ============================================================
// TEAM: FILE SYSTEM ACCESS API – Shared Folder Sync
// ============================================================
const TEAM_COLORS = ['tpc0','tpc1','tpc2','tpc3','tpc4','tpc5','tpc6','tpc7'];
let teamDirHandle = null;   // FileSystemDirectoryHandle
let teamStaleHandle = null; // Handle gespeichert aber Berechtigung fehlt
let teamLastFolder = '';    // Name des zuletzt verbundenen Ordners
let teamName = '';           // Mein Name
let teamAllData = {};        // { name: {entries:[], masterData:{}} }
let teamPeriod = 'week';
const TEAM_DB_STORE = 'teamConfig';

// --- Setup & Connect ---
async function teamConnect() {
    const nameInput = document.getElementById('teamNameInput');
    const name = nameInput.value.trim();
    if (!name) { showToast('Bitte Namen eingeben.', 'error'); nameInput.focus(); return; }

    if (!('showDirectoryPicker' in window)) {
        showToast('Dein Browser unterstützt die Ordner-Verbindung nicht. Nutze Chrome oder Edge.', 'error');
        return;
    }

    try {
        const handle = await window.showDirectoryPicker({ mode: 'readwrite' });
        teamDirHandle = handle;
        teamStaleHandle = null;
        teamLastFolder = handle.name;
        teamName = name;
        try { localStorage.setItem(APP_KEY + '_teamFolder', handle.name); } catch(e){}
        await teamSaveConfig();
        await teamSyncWrite();
        await teamSyncRead();
        teamRenderUI();
        showToast(`${t('toast.connected')} "${name}".`, 'success');
    } catch (e) {
        if (e.name !== 'AbortError') showToast('Verbindung fehlgeschlagen: ' + e.message, 'error');
    }
}

async function teamDisconnect() {
    if (!confirm(t('team.disconnect'))) return;
    teamDirHandle = null;
    teamStaleHandle = null;
    teamLastFolder = '';
    teamName = '';
    teamAllData = {};
    if (db) { try { await dbDelete(TEAM_DB_STORE, 'dirHandle'); await dbDelete(TEAM_DB_STORE, 'name'); } catch(e){} }
    try { localStorage.removeItem(APP_KEY + '_teamName'); localStorage.removeItem(APP_KEY + '_teamFolder'); } catch(e){}
    teamRenderUI();
    showToast(t('toast.disconnected'));
}

// --- Config Persistence (IndexedDB) ---
async function teamSaveConfig() {
    try { localStorage.setItem(APP_KEY + '_teamName', teamName); } catch(e){}
    if (db) {
        try {
            // Store handle in IndexedDB (survives sessions)
            const tx = db.transaction(TEAM_DB_STORE, 'readwrite');
            const store = tx.objectStore(TEAM_DB_STORE);
            store.put({ key: 'dirHandle', value: teamDirHandle });
            store.put({ key: 'name', value: teamName });
            await new Promise((r, j) => { tx.oncomplete = r; tx.onerror = () => j(tx.error); });
        } catch(e) { console.warn('Team config save failed', e); }
    }
}

async function teamLoadConfig() {
    try {
        const savedName = localStorage.getItem(APP_KEY + '_teamName');
        if (savedName) teamName = savedName;
        const savedFolder = localStorage.getItem(APP_KEY + '_teamFolder');
        if (savedFolder) teamLastFolder = savedFolder;
    } catch(e){}

    if (db) {
        try {
            const handleResult = await dbGet(TEAM_DB_STORE, 'dirHandle');
            if (handleResult && handleResult.value) {
                const h = handleResult.value;
                try { teamLastFolder = h.name; localStorage.setItem(APP_KEY + '_teamFolder', h.name); } catch(e){}
                const perm = await h.queryPermission({ mode: 'readwrite' });
                if (perm === 'granted') {
                    teamDirHandle = h;
                    teamStaleHandle = null;
                } else {
                    // Handle behalten für Reconnect per User-Geste
                    teamDirHandle = null;
                    teamStaleHandle = h;
                }
            }
            const nameResult = await dbGet(TEAM_DB_STORE, 'name');
            if (nameResult && nameResult.value) teamName = nameResult.value;
        } catch(e) { console.warn('Team config load failed', e); }
    }
}

async function teamReconnect() {
    if (!teamDirHandle) return false;
    try {
        const perm = await teamDirHandle.requestPermission({ mode: 'readwrite' });
        if (perm === 'granted') {
            await teamSyncRead();
            teamRenderUI();
            return true;
        }
    } catch(e) {}
    return false;
}

// Erneut verbinden mit gespeichertem Ordner-Handle
async function teamReconnectStale() {
    const handle = teamStaleHandle || teamDirHandle;
    if (!handle) {
        showToast(t('team.reconnectFail'), 'error');
        return;
    }
    try {
        const perm = await handle.requestPermission({ mode: 'readwrite' });
        if (perm === 'granted') {
            teamDirHandle = handle;
            teamStaleHandle = null;
            teamLastFolder = handle.name;
            try { localStorage.setItem(APP_KEY + '_teamFolder', handle.name); } catch(e){}
            await teamSyncRead();
            teamRenderUI();
            showToast(`${t('toast.connected')} "${teamName}".`, 'success');
            return;
        }
    } catch(e) {}
    // Fallback: Neuen Ordner wählen
    showToast(t('team.reconnectFail'), 'error');
}

// --- Sync: Write own data ---
async function teamSyncWrite() {
    if (!teamDirHandle || !teamName) return;

    // 🛡️ SAFETY: Niemals leere Daten auf Netzwerk schreiben!
    if (!entries.length) {
        console.warn('teamSyncWrite: ABGEBROCHEN — entries ist leer. Netzwerk-Backup wird geschützt.');
        return;
    }

    try {
        // Zusätzlicher Schutz: Bestehende Datei prüfen
        try {
            const existingHandle = await teamDirHandle.getFileHandle(teamName + '.json', { create: false });
            const existingFile = await existingHandle.getFile();
            const existingText = await existingFile.text();
            const existing = JSON.parse(existingText);
            if (existing.entries && existing.entries.length > entries.length + 5) {
                console.warn('teamSyncWrite: ABGEBROCHEN — bestehende Datei hat', existing.entries.length, 'Einträge, aktuell nur', entries.length, '. Schutz vor Datenverlust.');
                return;
            }
        } catch(e) { /* Datei existiert noch nicht → OK, neu anlegen */ }

        const data = { name: teamName, entries: entries, masterData: masterData, timestamp: Date.now() };
        const fileHandle = await teamDirHandle.getFileHandle(teamName + '.json', { create: true });
        const writable = await fileHandle.createWritable();
        await writable.write(JSON.stringify(data, null, 2));
        await writable.close();
    } catch(e) { console.warn('Team sync write failed', e); }
}

// --- Sync: Read all team data ---
async function teamSyncRead() {
    if (!teamDirHandle) return;
    const newData = {};
    try {
        for await (const [name, handle] of teamDirHandle) {
            if (handle.kind !== 'file' || !name.endsWith('.json')) continue;
            try {
                const file = await handle.getFile();
                const text = await file.text();
                const parsed = JSON.parse(text);
                if (parsed.entries && parsed.name) {
                    newData[parsed.name] = parsed;
                }
            } catch(e) { /* Skip invalid files */ }
        }
        teamAllData = newData;
    } catch(e) { console.warn('Team sync read failed', e); }
}

async function teamSync() {
    if (!teamDirHandle) return;
    try {
        const perm = await teamDirHandle.requestPermission({ mode: 'readwrite' });
        if (perm !== 'granted') { showToast('Ordner-Berechtigung verweigert.', 'error'); return; }
    } catch(e) { showToast('Berechtigung fehlgeschlagen.', 'error'); return; }
    await teamSyncWrite();
    await teamSyncRead();
    renderTeamDashboard();
    showToast(`Sync: ${Object.keys(teamAllData).length} ${t('toast.teamSync')}`, 'success');
}

// --- Hook into existing save functions ---
const _origSaveEntries = saveEntries;
saveEntries = async function() {
    await _origSaveEntries();
    teamSyncWrite(); // Fire and forget
};

// --- UI Rendering ---
function teamOnViewOpen() {
    if (teamDirHandle && teamName) {
        teamReconnect().then(ok => {
            if (!ok) teamRenderUI();
            else { teamSyncWrite().then(() => teamSyncRead().then(() => renderTeamDashboard())); }
        });
    }
    teamRenderUI();
}

function teamRenderUI() {
    const connected = teamDirHandle && teamName;
    const hasStale = !connected && (teamStaleHandle || teamLastFolder) && teamName;
    document.getElementById('teamSetupCard').style.display = connected ? 'none' : '';
    document.getElementById('teamConnected').style.display = connected ? '' : 'none';

    // Reconnect-Hinweis anzeigen wenn Ordner bekannt aber Berechtigung fehlt
    let reconEl = document.getElementById('teamReconnectHint');
    if (hasStale) {
        if (!reconEl) {
            reconEl = document.createElement('div');
            reconEl.id = 'teamReconnectHint';
            reconEl.style.cssText = 'margin-bottom:12px; padding:14px 18px; border-radius:var(--radius); border:1px solid var(--border); background:var(--surface);';
            const setupCard = document.getElementById('teamSetupCard');
            setupCard.parentNode.insertBefore(reconEl, setupCard);
        }
        const folderDisplay = teamLastFolder || '?';
        const canReconnect = !!teamStaleHandle;
        reconEl.innerHTML = `
            <div style="display:flex; align-items:center; gap:10px; flex-wrap:wrap;">
                <span style="color:var(--text-secondary); font-size:12px;">
                    📂 ${t('team.lastFolder')}: <strong style="color:var(--text);">${folderDisplay}</strong>
                </span>
                ${canReconnect ? `<button class="btn btn-primary" onclick="teamReconnectStale()" style="padding:8px 16px; font-size:11px;">
                    🔗 ${t('team.reconnect')}
                </button>` : ''}
            </div>`;
        reconEl.style.display = '';
    } else if (reconEl) {
        reconEl.style.display = 'none';
    }

    // Header sync button indicator
    const hBtn = document.getElementById('headerSyncBtn');
    if (hBtn) {
        if (connected) { hBtn.classList.add('sync-active'); hBtn.title = teamName + ' ✓'; }
        else { hBtn.classList.remove('sync-active'); hBtn.title = t('team.connect') || 'Ordner verbinden'; }
    }
    if (!connected) {
        document.getElementById('teamNameInput').value = teamName || '';
        return;
    }
    document.getElementById('teamMyName').textContent = teamName;
    renderTeamDashboard();
}

function renderTeamDashboard() {
    const persons = Object.keys(teamAllData).sort();
    const emptyMsg = '<div style="text-align:center;padding:14px;color:var(--text-muted);font-size:12px;">' + t('team.noperiod') + '</div>';

    if (!persons.length) {
        document.getElementById('teamMembers').innerHTML = '<span style="color:var(--text-muted); font-size:12px;">' + t('team.nodata') + '</span>';
        document.getElementById('teamKpis').innerHTML = '';
        ['teamMatrixContainer','teamProjektMatrixContainer','teamCompareContainer','teamTimelineContainer','teamAttendanceContainer'].forEach(id => {
            const el = document.getElementById(id); if (el) el.innerHTML = '';
        });
        return;
    }

    // Filter-Dropdowns befüllen
    teamPopulateFilters(persons);

    // Datum-Felder synchronisieren wenn nicht 'custom'
    if (teamPeriod !== 'custom') {
        const { from, to } = teamGetDateRange();
        const fromEl = document.getElementById('teamDateFrom');
        const toEl = document.getElementById('teamDateTo');
        if (fromEl) fromEl.value = from;
        if (toEl) toEl.value = to;
    }

    // Team Chips
    document.getElementById('teamMembers').innerHTML = persons.map((p, i) => {
        const ci = i % TEAM_COLORS.length;
        const count = teamAllData[p].entries ? teamAllData[p].entries.length : 0;
        const isMe = p === teamName ? ' me' : '';
        return `<span class="team-chip${isMe}"><span class="dot ${TEAM_COLORS[ci]}"></span>${esc(p)} <span class="count">(${count})</span></span>`;
    }).join('');

    // Filter anwenden
    const filtered = teamFilterByPeriod(persons);
    const filteredPersons = Object.keys(filtered).sort();

    // KPIs
    let totalH = 0, totalEntries = 0;
    filteredPersons.forEach(p => filtered[p].forEach(e => { totalH += (Number(e.durationMs) || 0) / 3600000; totalEntries++; }));
    const avgPerPerson = filteredPersons.length ? totalH / filteredPersons.length : 0;

    // Anzahl Arbeitstage im Zeitraum
    const { from: rFrom, to: rTo } = teamGetDateRange();
    let workDays = 0;
    if (rFrom && rTo) {
        const d = new Date(rFrom);
        const end = new Date(rTo);
        while (d <= end) { const dow = d.getDay(); if (dow > 0 && dow < 6) workDays++; d.setDate(d.getDate() + 1); }
    }
    const avgPerDay = workDays > 0 ? teamFmtH(totalH / workDays) : '-';

    document.getElementById('teamKpis').innerHTML = `
        <span class="tm-kpi"><strong>${teamFmtH(totalH)}</strong> ${t('team.kpiTotal')}</span>
        <span class="tm-kpi"><strong>${filteredPersons.length}</strong> ${t('team.kpiPersons')}</span>
        <span class="tm-kpi"><strong>${totalEntries}</strong> ${t('team.kpiEntries')}</span>
        <span class="tm-kpi"><strong>${teamFmtH(avgPerPerson)}</strong> ${t('team.kpiPerPerson')}</span>
        <span class="tm-kpi"><strong>${avgPerDay}</strong> ${t('team.kpiPerDay')}</span>
    `;

    if (!filteredPersons.length) {
        ['teamMatrixContainer','teamProjektMatrixContainer','teamCompareContainer','teamTimelineContainer','teamAttendanceContainer'].forEach(id => {
            const el = document.getElementById(id); if (el) el.innerHTML = emptyMsg;
        });
        return;
    }

    teamRenderAttendance(filtered, filteredPersons);
    teamRenderMatrix(filtered, filteredPersons);
    teamRenderProjektMatrix(filtered, filteredPersons);
    teamRenderCompare(filtered, filteredPersons);
    teamRenderTimeline(filtered, filteredPersons);
}

// --- Filter ---
function teamGetDateRange() {
    // Berechne Start/End basierend auf Periode oder Custom
    const now = new Date();
    const today = formatDateISO(now);
    let from = '', to = today;

    if (teamPeriod === 'custom') {
        from = (document.getElementById('teamDateFrom') || {}).value || '';
        to = (document.getElementById('teamDateTo') || {}).value || today;
        return { from, to };
    }
    if (teamPeriod === 'week') {
        const dow = now.getDay() || 7;
        const mon = new Date(now); mon.setDate(now.getDate() - dow + 1);
        from = formatDateISO(mon);
    } else if (teamPeriod === 'month') {
        from = now.getFullYear() + '-' + String(now.getMonth() + 1).padStart(2, '0') + '-01';
    } else if (teamPeriod === 'year') {
        from = now.getFullYear() + '-01-01';
    }
    // 'all' → from bleibt ''
    return { from, to };
}

function teamFilterByPeriod(persons) {
    const { from, to } = teamGetDateRange();
    const fSh = (document.getElementById('teamFilterSh') || {}).value || '';
    const fPr = (document.getElementById('teamFilterPr') || {}).value || '';

    const result = {};
    persons.forEach(p => {
        const all = teamAllData[p].entries || [];
        const f = all.filter(e => {
            if (from && e.date < from) return false;
            if (to && e.date > to) return false;
            if (fSh && e.stakeholder !== fSh) return false;
            if (fPr && e.projekt !== fPr) return false;
            return true;
        });
        if (f.length) result[p] = f;
    });
    return result;
}

function setTeamPeriod(period, btn) {
    teamPeriod = period;
    btn.parentElement.querySelectorAll('.period-btn').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');

    // Date inputs: nur bei 'custom' editierbar, sonst automatisch setzen
    const fromEl = document.getElementById('teamDateFrom');
    const toEl = document.getElementById('teamDateTo');
    if (period === 'custom') {
        if (fromEl && !fromEl.value) {
            const d = new Date(); d.setDate(d.getDate() - 30);
            fromEl.value = formatDateISO(d);
        }
        if (toEl && !toEl.value) toEl.value = formatDateISO(new Date());
    } else {
        const { from, to } = teamGetDateRange();
        if (fromEl) fromEl.value = from;
        if (toEl) toEl.value = to;
    }
    renderTeamDashboard();
}

function teamPopulateFilters(persons) {
    const shSet = new Set(), prSet = new Set();
    persons.forEach(p => {
        const all = teamAllData[p].entries || [];
        all.forEach(e => {
            if (e.stakeholder) shSet.add(e.stakeholder);
            if (e.projekt) prSet.add(e.projekt);
        });
    });
    const fillSel = (id, opts, i18nKey) => {
        const el = document.getElementById(id);
        if (!el) return;
        const val = el.value;
        el.innerHTML = '<option value="">' + t(i18nKey) + '</option>' + [...opts].sort().map(o => '<option value="' + esc(o) + '">' + esc(o) + '</option>').join('');
        el.value = val;
    };
    fillSel('teamFilterSh', shSet, 'all.stakeholder');
    fillSel('teamFilterPr', prSet, 'all.projekte');
}

function teamFmtH(hours) {
    if (!hours || hours < 0.005) return '0:00';
    const h = Math.floor(hours);
    const m = Math.round((hours - h) * 60);
    return `${h}:${String(m).padStart(2, '0')}`;
}

function teamGetH(entries) {
    return entries.reduce((s, e) => s + (Number(e.durationMs) || 0) / 3600000, 0);
}

// --- 1. Stakeholder × Person Matrix ---
function teamRenderMatrix(data, persons) {
    const shSet = new Set();
    persons.forEach(p => data[p].forEach(e => { if (e.stakeholder) shSet.add(e.stakeholder); }));
    const shs = [...shSet].sort();
    const mx = {};
    shs.forEach(sh => { mx[sh] = {}; persons.forEach(p => mx[sh][p] = 0); });
    persons.forEach(p => data[p].forEach(e => { if (mx[e.stakeholder]) mx[e.stakeholder][p] += (Number(e.durationMs)||0)/3600000; }));

    let html = '<table class="tm-table"><thead><tr><th></th>';
    persons.forEach((p, i) => { html += `<th><span class="${TEAM_COLORS[i%8]}t">${esc(p)}</span></th>`; });
    html += '<th>' + t('heatmap.total') + '</th></tr></thead><tbody>';
    shs.forEach(sh => {
        html += `<tr><td>${esc(sh)}</td>`;
        let rt = 0;
        persons.forEach(p => { const h = mx[sh][p]; rt += h; html += `<td class="tm-cell${h<0.005?' zero':''}" style="font-family:var(--font-mono);font-size:12px;">${teamFmtH(h)}</td>`; });
        html += `<td style="font-family:var(--font-mono);font-size:12px;">${teamFmtH(rt)}</td></tr>`;
    });
    html += '<tr><td>' + t('heatmap.total') + '</td>';
    let gt = 0;
    persons.forEach(p => { const t = teamGetH(data[p]); gt += t; html += `<td style="font-family:var(--font-mono);font-size:12px;">${teamFmtH(t)}</td>`; });
    html += `<td style="font-family:var(--font-mono);font-size:12px;">${teamFmtH(gt)}</td></tr></tbody></table>`;
    document.getElementById('teamMatrixContainer').innerHTML = html;
}

// --- 2. Wer arbeitet woran ---
function teamRenderCompare(data, persons) {
    const shSet = new Set();
    persons.forEach(p => data[p].forEach(e => { if (e.stakeholder) shSet.add(e.stakeholder); }));
    const shs = [...shSet].sort();
    let maxH = 0;
    persons.forEach(p => { const t = teamGetH(data[p]); if (t > maxH) maxH = t; });
    if (maxH === 0) maxH = 1;

    let html = '';
    persons.forEach((p, pi) => {
        const ci = pi % 8;
        const shH = {}; shs.forEach(sh => shH[sh] = 0);
        data[p].forEach(e => { if (shH[e.stakeholder] !== undefined) shH[e.stakeholder] += (Number(e.durationMs)||0)/3600000; });
        const tot = Object.values(shH).reduce((s,v) => s+v, 0);
        const pct = tot / maxH * 100;
        html += `<div class="tm-bar-row"><div class="tm-bar-label"><span class="${TEAM_COLORS[ci]}t">${esc(p)}</span></div><div class="tm-bar-track"><div class="tm-stacked" style="width:${Math.max(pct,3)}%">`;
        shs.forEach((sh, si) => { if (shH[sh] < 0.005) return; html += `<div class="tm-stacked-seg tpc${si%8}" style="width:${shH[sh]/tot*100}%" title="${esc(sh)}: ${teamFmtH(shH[sh])}"></div>`; });
        html += `</div></div><div class="tm-bar-value">${teamFmtH(tot)}</div></div>`;
    });
    document.getElementById('teamCompareContainer').innerHTML = html;
    document.getElementById('teamCompareLegend').innerHTML = shs.map((sh,i) => `<span class="tm-legend-item"><span class="tm-legend-dot tpc${i%8}"></span>${esc(sh)}</span>`).join('');
}

// teamRenderProjekt replaced by teamRenderProjektMatrix (see below)

// --- 4. Zeitverlauf ---
function teamRenderTimeline(data, persons) {
    const dateSet = new Set();
    persons.forEach(p => data[p].forEach(e => dateSet.add(e.date)));
    const dates = [...dateSet].sort();
    if (!dates.length) { document.getElementById('teamTimelineContainer').innerHTML = ''; return; }
    const grid = {};
    dates.forEach(d => { grid[d] = {}; persons.forEach(p => grid[d][p] = 0); });
    persons.forEach(p => data[p].forEach(e => { if (grid[e.date]) grid[e.date][p] += (Number(e.durationMs)||0)/3600000; }));
    let maxDay = 0;
    dates.forEach(d => { let t = 0; persons.forEach(p => t += grid[d][p]); if (t > maxDay) maxDay = t; });
    if (maxDay === 0) maxDay = 1;
    const WT = t('wd.short');
    let html = '';
    dates.forEach(d => {
        const dt = new Date(d);
        const label = `${d.slice(8,10)}.${d.slice(5,7)} ${WT[dt.getDay()]}`;
        let dayT = 0; persons.forEach(p => dayT += grid[d][p]);
        html += `<div class="tm-tl-row"><div class="tm-tl-date">${label}</div><div style="flex:1;"><div class="tm-stacked" style="height:16px;border-radius:3px;overflow:hidden;background:rgba(255,255,255,0.04);">`;
        persons.forEach((p, pi) => { const h = grid[d][p]; if (h < 0.005) return; html += `<div class="tm-stacked-seg ${TEAM_COLORS[pi%8]}" style="width:${h/maxDay*100}%" title="${esc(p)}: ${teamFmtH(h)}"></div>`; });
        html += `</div></div><div class="tm-tl-total">${teamFmtH(dayT)}</div></div>`;
    });
    document.getElementById('teamTimelineContainer').innerHTML = html;
    document.getElementById('teamTimelineLegend').innerHTML = persons.map((p,i) => `<span class="tm-legend-item"><span class="tm-legend-dot ${TEAM_COLORS[i%8]}"></span>${esc(p)}</span>`).join('');
}

// --- 5. Projekt × Person Matrix ---
function teamRenderProjektMatrix(data, persons) {
    const prSet = new Set();
    persons.forEach(p => data[p].forEach(e => { if (e.projekt) prSet.add(e.projekt); }));
    const prs = [...prSet].sort();
    if (!prs.length) { document.getElementById('teamProjektMatrixContainer').innerHTML = ''; return; }
    const mx = {};
    prs.forEach(pr => { mx[pr] = {}; persons.forEach(p => mx[pr][p] = 0); });
    persons.forEach(p => data[p].forEach(e => { if (mx[e.projekt]) mx[e.projekt][p] += (Number(e.durationMs)||0)/3600000; }));

    let html = '<table class="tm-table"><thead><tr><th data-t="th.projekt">Projekt</th>';
    persons.forEach((p, i) => { html += '<th><span class="' + TEAM_COLORS[i%8] + 't">' + esc(p) + '</span></th>'; });
    html += '<th>' + t('heatmap.total') + '</th></tr></thead><tbody>';
    prs.forEach(pr => {
        html += '<tr><td>' + esc(pr) + '</td>';
        let rt = 0;
        persons.forEach(p => { const h = mx[pr][p]; rt += h; html += '<td class="tm-cell' + (h<0.005?' zero':'') + '" style="font-family:var(--font-mono);font-size:12px;">' + teamFmtH(h) + '</td>'; });
        html += '<td style="font-family:var(--font-mono);font-size:12px;">' + teamFmtH(rt) + '</td></tr>';
    });
    // Total row
    html += '<tr><td>' + t('heatmap.total') + '</td>';
    let gt = 0;
    persons.forEach(p => { const t = teamGetH(data[p]); gt += t; html += '<td style="font-family:var(--font-mono);font-size:12px;">' + teamFmtH(t) + '</td>'; });
    html += '<td style="font-family:var(--font-mono);font-size:12px;">' + teamFmtH(gt) + '</td></tr></tbody></table>';
    document.getElementById('teamProjektMatrixContainer').innerHTML = html;
}

// --- 6. Tagesübersicht (Attendance Grid) ---
function teamRenderAttendance(data, persons) {
    // Alle Daten sammeln
    const dateSet = new Set();
    persons.forEach(p => data[p].forEach(e => dateSet.add(e.date)));
    const dates = [...dateSet].sort();
    if (!dates.length) { document.getElementById('teamAttendanceContainer').innerHTML = ''; return; }

    // Stunden pro Person pro Tag
    const grid = {};
    dates.forEach(d => { grid[d] = {}; persons.forEach(p => grid[d][p] = 0); });
    persons.forEach(p => data[p].forEach(e => { if (grid[e.date]) grid[e.date][p] += (Number(e.durationMs)||0)/3600000; }));

    const WT = t('wd.short');
    const WTfull = t('wd.long');

    // Person-Totals
    const personTotal = {};
    persons.forEach(p => { personTotal[p] = 0; dates.forEach(d => personTotal[p] += grid[d][p]); });

    // Tabelle bauen
    let html = '<table class="tm-att"><thead><tr><th data-t="th.datum">Datum</th>';
    persons.forEach((p, i) => { html += '<th><span class="' + TEAM_COLORS[i%8] + 't">' + esc(p) + '</span></th>'; });
    html += '<th class="total-col">Total</th></tr></thead><tbody>';

    dates.forEach(d => {
        const dt = new Date(d);
        const dow = dt.getDay();
        const isWe = dow === 0 || dow === 6;
        const label = d.slice(8,10) + '.' + d.slice(5,7) + '.' + d.slice(2,4) + ' ' + WT[dow];
        html += '<tr title="' + WTfull[dow] + ', ' + d.slice(8,10) + '.' + d.slice(5,7) + '.' + d.slice(0,4) + '">';
        html += '<td' + (isWe ? ' class="weekend"' : '') + '>' + label + '</td>';
        let dayTotal = 0;
        persons.forEach(p => {
            const h = grid[d][p];
            dayTotal += h;
            let cls = 'h0';
            if (h >= 0.005 && h < 4) cls = 'h-low';
            else if (h >= 4 && h < 7) cls = 'h-med';
            else if (h >= 7) cls = 'h-high';
            html += '<td class="' + cls + (isWe ? ' weekend' : '') + '" style="font-family:var(--font-mono);font-size:11px;">' + (h < 0.005 ? '–' : teamFmtH(h)) + '</td>';
        });
        html += '<td class="total-col" style="font-family:var(--font-mono);font-size:11px;">' + (dayTotal < 0.005 ? '–' : teamFmtH(dayTotal)) + '</td>';
        html += '</tr>';
    });

    // Total-Zeile
    html += '<tr class="total-row"><td>' + t('heatmap.total') + '</td>';
    let grandTotal = 0;
    persons.forEach(p => {
        grandTotal += personTotal[p];
        html += '<td style="font-family:var(--font-mono);font-size:11px;">' + teamFmtH(personTotal[p]) + '</td>';
    });
    html += '<td class="total-col" style="font-family:var(--font-mono);font-size:11px;">' + teamFmtH(grandTotal) + '</td></tr>';

    // Durchschnitt-Zeile
    const workDates = dates.filter(d => { const dow = new Date(d).getDay(); return dow > 0 && dow < 6; });
    if (workDates.length > 0) {
        html += '<tr style="color:var(--text-muted);font-style:italic;"><td>' + t('team.attAvgDay') + '</td>';
        persons.forEach(p => {
            const wH = workDates.reduce((s, d) => s + (grid[d][p] || 0), 0);
            html += '<td style="font-family:var(--font-mono);font-size:11px;">' + teamFmtH(wH / workDates.length) + '</td>';
        });
        const wTotal = workDates.reduce((s, d) => { let t = 0; persons.forEach(p => t += grid[d][p]); return s + t; }, 0);
        html += '<td class="total-col" style="font-family:var(--font-mono);font-size:11px;">' + teamFmtH(wTotal / workDates.length) + '</td>';
        html += '</tr>';
    }

    html += '</tbody></table>';
    document.getElementById('teamAttendanceContainer').innerHTML = html;
}

// --- 7. Excel-Export für Sitzungen ---
function teamExportExcel() {
    const persons = Object.keys(teamAllData).sort();
    if (!persons.length) { showToast(t('team.noTeamData'), 'error'); return; }
    const filtered = teamFilterByPeriod(persons);
    const fp = Object.keys(filtered).sort();
    if (!fp.length) { showToast(t('team.noPeriodData'), 'error'); return; }

    const { from: rFrom, to: rTo } = teamGetDateRange();
    const dateLabel = (rFrom ? formatDateDE(rFrom) : '') + ' – ' + (rTo ? formatDateDE(rTo) : t('team.today'));

    // Daten sammeln
    const dateSet = new Set();
    fp.forEach(p => filtered[p].forEach(e => dateSet.add(e.date)));
    const dates = [...dateSet].sort();

    const grid = {};
    dates.forEach(d => { grid[d] = {}; fp.forEach(p => grid[d][p] = 0); });
    fp.forEach(p => filtered[p].forEach(e => { if (grid[e.date]) grid[e.date][p] += (Number(e.durationMs)||0)/3600000; }));

    const WT = t('wd.short');

    // CSV bauen (Semikolon für CH/DE Excel)
    let csv = t('team.exportLabel') + ';' + dateLabel + '\n\n';

    // Blatt 1: Tagesübersicht
    csv += t('team.attTitle') + '\n';
    csv += t('csv.datum') + ';' + t('csv.wochentag') + ';' + fp.join(';') + ';' + t('heatmap.total') + '\n';
    dates.forEach(d => {
        const dt = new Date(d);
        const day = d.slice(8,10) + '.' + d.slice(5,7) + '.' + d.slice(0,4);
        const wt = WT[dt.getDay()];
        let row = day + ';' + wt;
        let dayT = 0;
        fp.forEach(p => { const h = grid[d][p]; dayT += h; row += ';' + (h < 0.005 ? '' : h.toFixed(2)); });
        row += ';' + (dayT < 0.005 ? '' : dayT.toFixed(2));
        csv += row + '\n';
    });
    // Totals
    csv += 'TOTAL;;';
    let gt = 0;
    fp.forEach(p => { const t = teamGetH(filtered[p]); gt += t; csv += t.toFixed(2) + ';'; });
    csv += gt.toFixed(2) + '\n\n';

    // Blatt 2: Stakeholder × Person
    csv += t('team.shXperson') + '\n';
    const shSet = new Set();
    fp.forEach(p => filtered[p].forEach(e => { if (e.stakeholder) shSet.add(e.stakeholder); }));
    const shs = [...shSet].sort();
    csv += t('csv.stakeholder') + ';' + fp.join(';') + ';' + t('heatmap.total') + '\n';
    shs.forEach(sh => {
        let row = sh;
        let rt = 0;
        fp.forEach(p => {
            const h = filtered[p].filter(e => e.stakeholder === sh).reduce((s,e) => s + (Number(e.durationMs)||0)/3600000, 0);
            rt += h; row += ';' + (h < 0.005 ? '' : h.toFixed(2));
        });
        row += ';' + rt.toFixed(2);
        csv += row + '\n';
    });
    csv += '\n';

    // Blatt 3: Projekt × Person
    csv += t('team.prXperson') + '\n';
    const prSet = new Set();
    fp.forEach(p => filtered[p].forEach(e => { if (e.projekt) prSet.add(e.projekt); }));
    const prs = [...prSet].sort();
    csv += t('csv.projekt') + ';' + fp.join(';') + ';' + t('heatmap.total') + '\n';
    prs.forEach(pr => {
        let row = pr;
        let rt = 0;
        fp.forEach(p => {
            const h = filtered[p].filter(e => e.projekt === pr).reduce((s,e) => s + (Number(e.durationMs)||0)/3600000, 0);
            rt += h; row += ';' + (h < 0.005 ? '' : h.toFixed(2));
        });
        row += ';' + rt.toFixed(2);
        csv += row + '\n';
    });

    // Download
    const BOM = '\uFEFF'; // UTF-8 BOM für Excel
    const blob = new Blob([BOM + csv], { type: 'text/csv;charset=utf-8;' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    const fn = 'Team_Auswertung_' + (rFrom || 'all') + '_' + (rTo || 'all') + '.csv';
    a.download = fn;
    a.click();
    URL.revokeObjectURL(url);
    showToast('Excel-Export heruntergeladen: ' + fn, 'success');
}

// Modal-Overlay schliessen bei Klick ausserhalb
document.addEventListener('click', (e) => {
    if (e.target.classList.contains('modal-overlay')) {
        if (e.target.id === 'splitModal') closeSplitModal();
        else e.target.classList.remove('open');
    }
});

// Keyboard: Escape schliesst Modal
document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape') {
        if (document.getElementById('splitModal').classList.contains('open')) {
            closeSplitModal();
        }
        document.querySelectorAll('.modal-overlay.open').forEach(m => m.classList.remove('open'));
    }
});

// ============================================================
// SERVICE WORKER REGISTRIERUNG (PWA)
// ============================================================
if ('serviceWorker' in navigator) {
    navigator.serviceWorker.register('./sw.js').then(reg => {
        // Automatisch nach Updates suchen
        reg.addEventListener('updatefound', () => {
            const newWorker = reg.installing;
            newWorker.addEventListener('statechange', () => {
                if (newWorker.state === 'activated') {
                    showToast('Update verfügbar – Seite neu laden.', 'success');
                }
            });
        });
    }).catch(() => {});
}
// ========== QUICK-START RECENT TASKS ==========
function renderQuickStart() {
    const panel = document.getElementById('quickStart');
    if (!panel) return;

    // Sammle die 5 häufigsten Stakeholder+Projekt Kombinationen
    const combos = {};
    entries.forEach(e => {
        if (!e.stakeholder || !e.projekt) return;
        const key = e.stakeholder + '|' + e.projekt;
        combos[key] = (combos[key] || 0) + 1;
    });
    const sorted = Object.entries(combos).sort((a, b) => b[1] - a[1]).slice(0, 5);

    if (!sorted.length) { panel.style.display = 'none'; return; }
    panel.style.display = 'flex';

    panel.innerHTML = sorted.map(([key, count]) => {
        const [sh, pr] = key.split('|');
        // Häufigste Tätigkeit für Tooltip ermitteln
        const actCounts = {};
        entries.forEach(e => {
            if (e.stakeholder === sh && e.projekt === pr && e.taetigkeit)
                actCounts[e.taetigkeit] = (actCounts[e.taetigkeit] || 0) + 1;
        });
        const topAct = Object.entries(actCounts).sort((a, b) => b[1] - a[1])[0];
        const actHint = topAct ? `\nTätigkeit: ${topAct[0]}` : '';
        return `<div class="quick-chip" onclick="quickStartTask('${esc(sh)}','${esc(pr)}')" title="${count}× verwendet${actHint}">
            <span class="qc-icon">⚡</span>${esc(sh)} / ${esc(pr)}
        </div>`;
    }).join('');
}

function quickStartTask(sh, pr) {
    // Finde leeren Slot oder erstelle neuen
    let idx = taskSlots.findIndex(s => !s.sh && !s.pr && !s.running);
    if (idx < 0) {
        addTaskSlot();
        idx = taskSlots.length - 1;
    }
    taskSlots[idx].sh = sh;
    taskSlots[idx].pr = pr;
    // Häufigste Tätigkeit für diese Kombination ermitteln
    const actCounts = {};
    entries.forEach(e => {
        if (e.stakeholder === sh && e.projekt === pr && e.taetigkeit) {
            actCounts[e.taetigkeit] = (actCounts[e.taetigkeit] || 0) + 1;
        }
    });
    const topAct = Object.entries(actCounts).sort((a, b) => b[1] - a[1])[0];
    if (topAct) taskSlots[idx].ta = topAct[0];
    renderTaskSlots();
    saveTaskSlots();
    // Timer starten
    toggleSlotTimer(idx);
}

// ========== RESIZE HANDLER ==========
window.addEventListener('resize', () => { requestAnimationFrame(() => initNavIndicator()); });

// ============================================================
// ANIMATED KPI COUNTER
// ============================================================
function animateKPIValue(elementId, newValue) {
    const el = document.getElementById(elementId);
    if (!el) return;
    const oldValue = el.textContent;
    if (oldValue === newValue) return;
    el.style.transition = 'none';
    el.style.transform = 'scale(1.15)';
    el.style.opacity = '0.6';
    el.textContent = newValue;
    requestAnimationFrame(() => {
        el.style.transition = 'transform 0.5s cubic-bezier(0.22, 1, 0.36, 1), opacity 0.3s ease';
        el.style.transform = 'scale(1)';
        el.style.opacity = '1';
    });
}

// ========== SAVE HOOK: Daily Goal + DSB nach jedem Speichern ==========
const _origSaveEntriesForGoal = saveEntries;
saveEntries = async function() {
    await _origSaveEntriesForGoal.apply(this, arguments);
    if (typeof updateDailyGoal === 'function') updateDailyGoal();
    if (typeof updateFabState === 'function') updateFabState();
    if (typeof checkAchievements === 'function') checkAchievements();
    // DSB: Rotierendes Backup nach jedem Save
    dsbBackupAfterSave();
};

// ╔══════════════════════════════════════════════════════════════╗
// ║  🛡️ DSB — DATA SAFETY BELT (Bulletproof Persistence)       ║
// ║  6 Schichten · 3 Generationen · CRC32 · Heartbeat          ║
// ╚══════════════════════════════════════════════════════════════╝
//
// Schicht 1: IndexedDB          (primär, async, diff-basiert)
// Schicht 2: localStorage       (sync-Mirror, sofort bei jedem Save)
// Schicht 3: Backup Generation A (rotierend, mit CRC32)
// Schicht 4: Backup Generation B (rotierend, mit CRC32)
// Schicht 5: Backup Generation C (rotierend, mit CRC32)
// Schicht 6: Timer-Heartbeat    (laufende Timer überleben Crash)
//
// Zusätzlich:
// • Periodischer Auto-Save alle 30s bei laufenden Timern
// • Tab-Visibility-Watcher (Save bei Tab-Wechsel, Check bei Rückkehr)
// • Startup-Integritätsprüfung über alle 6 Quellen
// • Recovery-Dialog mit Auswahl aller Generationen
// • Doppelte Absicherung bei beforeunload + pagehide + visibilitychange

const DSB = {
    PREFIX:     APP_KEY + '_dsb_',
    SLOTS:      ['A', 'B', 'C'],
    PERIODIC:   30000,   // 30s Auto-Save bei laufenden Timern
    HEARTBEAT:  10000,   // 10s Heartbeat für Timer-State
    BK_COOLDOWN: 45000,  // 45s Mindestabstand zwischen Backup-Rotationen
    lastBackup: 0,
    periodicId: null,
    heartbeatId: null,
    saveCounter: 0       // Zählt Saves seit App-Start
};

// --- CRC32 Prüfsumme (Industriestandard-Polynom) ---
function dsbCRC32(str) {
    let crc = 0xFFFFFFFF;
    for (let i = 0; i < str.length; i++) {
        crc ^= str.charCodeAt(i);
        for (let j = 0; j < 8; j++) crc = (crc >>> 1) ^ (crc & 1 ? 0xEDB88320 : 0);
    }
    return (crc ^ 0xFFFFFFFF) >>> 0;
}

// --- Backup-Metadaten (welcher Slot als nächstes, Statistiken) ---
function dsbMeta() {
    try {
        const m = localStorage.getItem(DSB.PREFIX + 'meta');
        return m ? JSON.parse(m) : { next: 0, saves: 0, lastSave: 0 };
    } catch(e) { return { next: 0, saves: 0, lastSave: 0 }; }
}
function dsbSetMeta(m) {
    try { localStorage.setItem(DSB.PREFIX + 'meta', JSON.stringify(m)); } catch(e) {}
}

// --- Rotierendes Backup schreiben (A→B→C→A→...) ---
function dsbBackupAfterSave() {
    if (!entries.length) return;
    const now = Date.now();
    // Cooldown: max 1 Rotation pro 45s (aber sofort beim ersten Save)
    if (DSB.saveCounter > 0 && now - DSB.lastBackup < DSB.BK_COOLDOWN) return;
    DSB.lastBackup = now;
    DSB.saveCounter++;
    dsbWriteBackup();
}

function dsbWriteBackup() {
    if (!entries.length) return;
    const meta = dsbMeta();
    const slot = DSB.SLOTS[meta.next % DSB.SLOTS.length];
    const payload = JSON.stringify(entries);
    const backup = {
        v: 3,
        ts: Date.now(),
        slot: slot,
        count: entries.length,
        crc: dsbCRC32(payload),
        entries: entries,
        master: masterData
    };
    try {
        const key = DSB.PREFIX + 'gen_' + slot;
        localStorage.setItem(key, JSON.stringify(backup));
        meta.next = (meta.next + 1) % DSB.SLOTS.length;
        meta.saves++;
        meta.lastSave = Date.now();
        dsbSetMeta(meta);
        console.log('DSB: Backup Slot ' + slot + ' geschrieben (' + entries.length + ' Einträge, CRC ' + backup.crc + ')');
    } catch(e) {
        console.warn('DSB: Backup-Schreiben fehlgeschlagen:', e);
        // localStorage voll? Versuche ältesten Slot zu löschen
        try {
            const oldest = DSB.SLOTS[(meta.next + 1) % DSB.SLOTS.length];
            localStorage.removeItem(DSB.PREFIX + 'gen_' + oldest);
            localStorage.setItem(DSB.PREFIX + 'gen_' + slot, JSON.stringify(backup));
        } catch(e2) { console.error('DSB: Auch nach Cleanup kein Platz:', e2); }
    }
}

// --- Alle Backup-Generationen lesen & validieren ---
function dsbGetAllBackups() {
    const backups = [];

    // DSB-Generationen (A, B, C)
    for (const slot of DSB.SLOTS) {
        try {
            const raw = localStorage.getItem(DSB.PREFIX + 'gen_' + slot);
            if (!raw) continue;
            const b = JSON.parse(raw);
            if (!b.entries || !b.entries.length) continue;
            // CRC-Integritäts-Check
            b.valid = true;
            if (b.crc !== undefined) {
                const expected = dsbCRC32(JSON.stringify(b.entries));
                if (b.crc !== expected) {
                    console.warn('DSB: Slot ' + slot + ' CRC MISMATCH (' + b.crc + ' vs ' + expected + ') — markiert als korrupt.');
                    b.valid = false;
                }
            }
            b.source = 'DSB-' + slot;
            backups.push(b);
        } catch(e) {}
    }

    // Abwärtskompatibel: altes safeBackup-Format
    try {
        const old = localStorage.getItem(APP_KEY + '_safeBackup');
        if (old) {
            const b = JSON.parse(old);
            if (b.entries && b.entries.length) {
                backups.push({
                    v: 2, ts: b.timestamp || 0, count: b.entryCount || b.entries.length,
                    entries: b.entries, master: b.masterData, slot: 'legacy',
                    source: 'Legacy', valid: true
                });
            }
        }
    } catch(e) {}

    // Notfall: lastResort (wird bei "Alle Daten löschen" angelegt)
    try {
        const lr = localStorage.getItem(APP_KEY + '_dsb_lastResort');
        if (lr) {
            const b = JSON.parse(lr);
            if (b.entries && b.entries.length) {
                backups.push({
                    v: 0, ts: b.ts || 0, count: b.entries.length,
                    entries: b.entries, master: b.masterData, slot: 'LR',
                    source: 'Notfall-Backup', valid: true
                });
            }
        }
    } catch(e) {}

    // localStorage-Mirror als Backup-Quelle
    try {
        const lsRaw = localStorage.getItem(APP_KEY + '_entries');
        if (lsRaw) {
            const lsEntries = JSON.parse(lsRaw);
            if (lsEntries.length) {
                backups.push({
                    v: 0, ts: Date.now(), count: lsEntries.length,
                    entries: lsEntries, master: null, slot: 'LS',
                    source: 'localStorage', valid: true
                });
            }
        }
    } catch(e) {}

    // Sortieren: valide zuerst, dann nach Anzahl (meiste), dann nach Zeit (neueste)
    backups.sort((a, b) => {
        if (a.valid !== b.valid) return a.valid ? -1 : 1;
        if (a.count !== b.count) return b.count - a.count;
        return b.ts - a.ts;
    });
    return backups;
}

// --- Bestes valides Backup ---
function dsbBestBackup() {
    const all = dsbGetAllBackups();
    return all.find(b => b.valid) || (all.length ? all[0] : null);
}

// --- Wiederherstellung mit Auswahl ---
async function dsbRestore() {
    const all = dsbGetAllBackups();
    if (!all.length) { showToast(t('toast.noBackup'), 'error'); return; }

    const lines = all.map((b, i) => {
        const d = new Date(b.ts);
        const loc = appLang === 'fr' ? 'fr-CH' : 'de-CH'; const when = d.toLocaleDateString(loc) + ' ' + d.toLocaleTimeString(loc);
        const status = b.valid ? '✅' : t('dsb.crcError');
        return `[${i + 1}] ${b.source}: ${b.count} ${t('backup.entries')} (${when}) ${status}`;
    }).join('\\n');

    const choice = prompt(
        t('dsb.prompt') + '\\n\\n' + lines +
        '\\n\\n' + t('dsb.promptInput').replace('{n}', all.length)
    );
    const idx = parseInt(choice) - 1;
    if (isNaN(idx) || idx < 0 || idx >= all.length) { showToast(t('dsb.cancelled'), ''); return; }

    const backup = all[idx];
    if (!backup.valid) {
        if (!confirm(t('dsb.crcWarn'))) return;
    }
    if (!confirm(t('dsb.confirmRestore').replace('{count}', backup.count).replace('{source}', backup.source))) return;

    entries = backup.entries;
    if (backup.master) masterData = backup.master;
    await saveAll();
    renderAll();
    showToast(t('dsb.restored').replace('{count}', backup.count).replace('{source}', backup.source), 'success');
}

// --- Legacy-Aliases (Abwärtskompatibilität) ---
function hasAutoBackup() { return dsbBestBackup(); }
async function restoreFromAutoBackup() { return dsbRestore(); }

// --- Timer-Heartbeat: Sichert laufende Timer-States alle 10s ---
function dsbHeartbeat() {
    const running = taskSlots.filter(s => s.running);
    if (!running.length) {
        try { localStorage.removeItem(DSB.PREFIX + 'heartbeat'); } catch(e) {}
        return;
    }
    try {
        const hb = {
            ts: Date.now(),
            slots: running.map(s => ({
                id: s.id, sh: s.sh, pr: s.pr, ta: s.ta, notiz: s.notiz,
                startTime: s.startTime, pausedTime: s.pausedTime, paused: s.paused,
                originalStartTime: s.originalStartTime, earnedMs: s.earnedMs || 0
            }))
        };
        localStorage.setItem(DSB.PREFIX + 'heartbeat', JSON.stringify(hb));
    } catch(e) {}
}

function dsbRecoverHeartbeat() {
    try {
        const raw = localStorage.getItem(DSB.PREFIX + 'heartbeat');
        if (!raw) return;
        const hb = JSON.parse(raw);
        // Nur wiederherstellen wenn Heartbeat max. 2 Minuten alt
        if (Date.now() - hb.ts > 120000) {
            localStorage.removeItem(DSB.PREFIX + 'heartbeat');
            return;
        }
        if (!hb.slots || !hb.slots.length) {
            localStorage.removeItem(DSB.PREFIX + 'heartbeat');
            return;
        }

        // Nur Slots wiederherstellen die tatsächlich laufen sollten (startTime vorhanden)
        const validSlots = hb.slots.filter(s => s.startTime);
        if (!validSlots.length) {
            localStorage.removeItem(DSB.PREFIX + 'heartbeat');
            return;
        }

        // Prüfe ob es laufende Timer gibt die nicht in taskSlots sind
        const currentIds = new Set(taskSlots.filter(s => s.running).map(s => s.id));
        const lost = validSlots.filter(s => !currentIds.has(s.id));
        if (!lost.length) {
            localStorage.removeItem(DSB.PREFIX + 'heartbeat');
            return;
        }

        const names = lost.map(s => (s.sh || '?') + '/' + (s.pr || '?')).join(', ');
        if (confirm(t('dsb.heartbeatFound').replace('{names}', names))) {
            lost.forEach(s => {
                const existing = taskSlots.find(ts => ts.id === s.id);
                if (existing) {
                    Object.assign(existing, s, { running: true });
                } else {
                    taskSlots.push({ ...s, running: true });
                }
            });
            // Tick-Interval starten für wiederhergestellte Timer
            if (!timerState.interval) {
                timerState.lastTickTime = Date.now();
                timerState.interval = setInterval(tickTimers, 500);
                timerState.running = true;
            }
            renderTaskSlots();
            showToast(t('dsb.heartbeatOk').replace('{count}', lost.length), 'success');
        }
        localStorage.removeItem(DSB.PREFIX + 'heartbeat');
    } catch(e) { console.warn('DSB: Heartbeat-Recovery fehlgeschlagen:', e); }
}

// --- Periodischer Auto-Save (alle 30s wenn Timer laufen) ---
function dsbPeriodicSave() {
    const hasRunning = taskSlots.some(s => s.running);
    if (!hasRunning) return;
    // Synchrones localStorage-Update der Entries
    try { localStorage.setItem(APP_KEY + '_entries', JSON.stringify(entries)); } catch(e) {}
    dsbHeartbeat();
}

// --- Tab-Visibility-Watcher ---
function dsbVisibilityHandler() {
    if (document.hidden || document.visibilityState === 'hidden') {
        // Tab verborgen (z.B. Tab-Wechsel, System-Dialog, Berechtigungs-Popup)
        // WICHTIG: Timer NICHT stoppen! autoSaveRunningTimers() ist nur für
        // beforeunload/pagehide (endgültiger Tab-Close) gedacht.
        // Stattdessen: Nur aktuelle Daten sichern ohne Timer-State zu ändern.
        try { localStorage.setItem(APP_KEY + '_entries', JSON.stringify(entries)); } catch(e) {}
        dsbHeartbeat();
        // Backup (Cooldown ignorieren)
        DSB.lastBackup = 0;
        if (entries.length) dsbWriteBackup();
        console.log('DSB: Tab hidden → Daten gesichert (Timer laufen weiter).');
    } else {
        // Tab zurück → Integritäts-Quick-Check
        console.log('DSB: Tab visible → Quick-Check.');
        dsbQuickCheck();
    }
}

function dsbQuickCheck() {
    // Schneller Check: Stimmen localStorage und RAM überein?
    try {
        const lsRaw = localStorage.getItem(APP_KEY + '_entries');
        if (!lsRaw) return;
        const lsEntries = JSON.parse(lsRaw);
        if (lsEntries.length > entries.length + 5) {
            console.warn('DSB Quick-Check: localStorage hat', lsEntries.length, 'Einträge, RAM nur', entries.length, '— synchronisiere!');
            entries = lsEntries;
            renderAll();
            showToast('🛡️ Daten aus Hintergrund-Tab synchronisiert.', 'success');
        }
    } catch(e) {}
}

// --- Startup-Integritätsprüfung ---
function dsbStartupCheck() {
    if (entries.length > 0) {
        // Alles OK, aber trotzdem mit Backups vergleichen
        const best = dsbBestBackup();
        if (best && best.valid && best.count > entries.length + 10) {
            console.warn('DSB Startup: Backup hat deutlich mehr Einträge (' + best.count + ' vs ' + entries.length + ')');
            setTimeout(() => {
                if (confirm(t('dsb.startupWarn').replace('{bc}', best.count).replace('{ec}', entries.length))) {
                    entries = best.entries;
                    if (best.master) masterData = best.master;
                    saveAll().then(() => { renderAll(); showToast(t('dsb.restored').replace('{count}', best.count).replace('{source}', 'Backup'), 'success'); });
                }
            }, 800);
        }
        // Sofort ein Backup schreiben damit aktuelle Daten gesichert sind
        dsbWriteBackup();
        return;
    }

    // Keine Daten geladen! → Alle Quellen durchsuchen
    const best = dsbBestBackup();
    if (!best || !best.entries.length) return; // Wirklich nichts da

    const d = new Date(best.ts);
    const loc = appLang === 'fr' ? 'fr-CH' : 'de-CH'; const when = d.toLocaleDateString(loc) + ' ' + d.toLocaleTimeString(loc);
    const status = best.valid ? '' : t('dsb.crcNote');
    setTimeout(() => {
        if (confirm(t('dsb.startupRestore').replace('{source}', best.source).replace('{count}', best.count).replace('{when}', when).replace('{status}', status))) {
            entries = best.entries;
            if (best.master) masterData = best.master;
            saveAll().then(() => { renderAll(); showToast(t('dsb.restored').replace('{count}', best.count).replace('{source}', best.source), 'success'); });
        } else {
            document.getElementById('welcomeModal').classList.add('open');
        }
    }, 400);
}

// --- DSB initialisieren ---
function dsbInit() {
    // 1. Heartbeat-Recovery (Absturz-Timer)
    dsbRecoverHeartbeat();

    // 2. Periodischen Auto-Save starten
    DSB.periodicId = setInterval(dsbPeriodicSave, DSB.PERIODIC);

    // 3. Heartbeat starten
    DSB.heartbeatId = setInterval(dsbHeartbeat, DSB.HEARTBEAT);

    // 4. Tab-Visibility-Watcher
    document.addEventListener('visibilitychange', dsbVisibilityHandler);

    // 5. Zusätzlicher Save bei Fokusverlust (Desktop-Browser)
    window.addEventListener('blur', () => {
        if (taskSlots.some(s => s.running)) dsbHeartbeat();
    });

    // 6. Startup-Integritätsprüfung (verzögert, damit loadAll() fertig ist)
    setTimeout(dsbStartupCheck, 600);

    console.log('🛡️ DSB (Data Safety Belt) aktiv — 6 Schichten, 3 Generationen, CRC32');
}

// Legacy-Alias
function checkAutoBackupRecovery() { /* handled by dsbInit/dsbStartupCheck */ }

// --- DSB Status-Anzeige ---
function dsbShowStatus() {
    const all = dsbGetAllBackups();
    const meta = dsbMeta();
    const loc = appLang === 'fr' ? 'fr-CH' : 'de-CH';
    let msg = t('dsb.statusTitle') + '\n';
    msg += '═══════════════════════════════\n\n';
    msg += t('dsb.layers') + ' 6\n';
    msg += t('dsb.generations') + ' ' + DSB.SLOTS.length + ' (A/B/C)\n';
    msg += t('dsb.savesSession') + ' ' + DSB.saveCounter + '\n';
    msg += t('dsb.savesTotal') + ' ' + meta.saves + '\n';
    msg += t('dsb.nextSlot') + ' ' + DSB.SLOTS[meta.next % DSB.SLOTS.length] + '\n\n';

    if (all.length) {
        msg += t('dsb.available') + '\n';
        msg += '───────────────────\n';
        all.forEach((b, i) => {
            const d = new Date(b.ts);
            const when = d.toLocaleDateString(loc) + ' ' + d.toLocaleTimeString(loc);
            const ok = b.valid ? '✅' : t('dsb.crcError');
            msg += (i + 1) + '. ' + b.source + ': ' + b.count + ' ' + t('backup.entries') + ' (' + when + ') ' + ok + '\n';
        });
    } else {
        msg += t('dsb.noBackups') + '\n';
    }

    msg += '\n' + t('dsb.inMemory') + ' ' + entries.length + ' ' + t('backup.entries');
    const running = taskSlots.filter(s => s.running).length;
    if (running) msg += '\n' + t('dsb.runningTimers') + ' ' + running + ' ' + t('dsb.heartbeatActive');
    msg += '\n\n' + t('dsb.periodicSave') + ' ' + (DSB.PERIODIC / 1000) + 's';
    msg += '\n' + t('dsb.heartbeatInterval') + ' ' + (DSB.HEARTBEAT / 1000) + 's';

    alert(msg);
}

// CONFETTI CELEBRATION 🎉
// ============================================================
function spawnConfetti() {
    const container = document.getElementById('confettiContainer');
    if (!container) return;
    const colors = ['#C9A962', '#C48B9F', '#9B8EC4', '#6EC49E', '#E5A84B', '#D4956A'];
    for (let i = 0; i < 50; i++) {
        const piece = document.createElement('div');
        piece.className = 'confetti-piece';
        piece.style.left = Math.random() * 100 + '%';
        piece.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
        piece.style.animationDelay = Math.random() * 0.8 + 's';
        piece.style.animationDuration = (2 + Math.random() * 2) + 's';
        piece.style.borderRadius = Math.random() > 0.5 ? '50%' : '2px';
        piece.style.width = (4 + Math.random() * 8) + 'px';
        piece.style.height = (4 + Math.random() * 8) + 'px';
        container.appendChild(piece);
    }
    setTimeout(() => { container.innerHTML = ''; }, 4000);
}

// ============================================================
// ACHIEVEMENT SYSTEM – Meilensteine feiern
// ============================================================
let _lastAchievementHour = 0;

function checkAchievements() {
    const now = new Date();
    const today = formatDateISO(now);
    const todayMs = entries.filter(e => e.date === today).reduce((s, e) => s + (Number(e.durationMs) || 0), 0);
    const hours = Math.floor(todayMs / 3600000);
    const milestones = {
        1: { emoji: '☕', text: 'Erste Stunde geschafft!' },
        4: { emoji: '🚀', text: '4 Stunden – Halbzeit!' },
        8: { emoji: '🎯', text: '8 Stunden – Tagesziel erreicht!' },
    };
    if (hours > _lastAchievementHour && milestones[hours]) {
        const m = milestones[hours];
        showToast(`${m.emoji} ${m.text}`, 'success');
        if (hours === 8) spawnConfetti();
        _lastAchievementHour = hours;
    }
}

// ============================================================
// KEYBOARD SHORTCUTS: ? zeigt Overlay
// ============================================================
document.addEventListener('keydown', (e) => {
    if (['INPUT', 'TEXTAREA', 'SELECT'].includes(e.target.tagName)) return;
    if (e.key === '?' && !e.ctrlKey && !e.metaKey) {
        const overlay = document.getElementById('kbdOverlay');
        if (overlay) overlay.classList.toggle('open');
    }
    if (e.key === 'Escape') {
        const overlay = document.getElementById('kbdOverlay');
        if (overlay) overlay.classList.remove('open');
    }
});

// ============================================================
// BUTTON HOVER GLOW EFFECT (Cursor-Position-Tracking)
// ============================================================
document.addEventListener('mousemove', (e) => {
    try {
        const t = e.target;
        if (!t || typeof t.closest !== 'function') return;
        const btn = t.closest('.btn, .timer-btn, .quick-chip');
        if (btn) {
            const rect = btn.getBoundingClientRect();
            btn.style.setProperty('--x', ((e.clientX - rect.left) / rect.width * 100) + '%');
            btn.style.setProperty('--y', ((e.clientY - rect.top) / rect.height * 100) + '%');
        }
    } catch(ex) {}
});

// ============================================================
// INIT: Achievement-Stand bei App-Start setzen
// ============================================================
(function initAchievements() {
    const now = new Date();
    const today = formatDateISO(now);
    const todayMs = entries.filter(e => e.date === today).reduce((s, e) => s + (Number(e.durationMs) || 0), 0);
    _lastAchievementHour = Math.floor(todayMs / 3600000);
})();

</script>
</body>
</html>
